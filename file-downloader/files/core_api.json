{
  "info": {
    "title": "Core Api",
    "version": "v1"
  },
  "paths": {
    "/v1/account-schedule-tags": {
      "get": {
        "summary": "Retrieves all AccountScheduleTags.",
        "operationId": "ListAccountScheduleTags",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/account_schedule_tagsListAccountScheduleTagsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The number of results to be listed.\n\nRequired.\nMin value: 1.\nMax value: 500.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "Token of the page the results are to be retrieved from. If empty, returns the first page of results. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIAccountScheduleTags"
        ],
        "x-section": "Account schedule tags",
        "x-release-info": {
          "releaseVersion": {
            "major": 2,
            "minor": 2
          },
          "changeType": "ADD_METHOD",
          "featureFlag": "KERN_399_ACCOUNT_SCHEDULE_TAGS_API"
        },
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.account_schedule_tags:read"
        ]
      },
      "post": {
        "summary": "Creates an AccountScheduleTag. The AccountScheduleTag can be created with a status of `ACCOUNT_SCHEDULE_TAG_SCHEDULE_STATUS_OVERRIDE_NO_OVERRIDE`, `ACCOUNT_SCHEDULE_TAG_SCHEDULE_STATUS_OVERRIDE_TO_ENABLED`, `ACCOUNT_SCHEDULE_TAG_SCHEDULE_STATUS_OVERRIDE_TO_FAST_FORWARDED` or `ACCOUNT_SCHEDULE_TAG_SCHEDULE_STATUS_OVERRIDE_TO_SKIPPED`.",
        "operationId": "CreateAccountScheduleTag",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/account_schedule_tagsAccountScheduleTag"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIAccountScheduleTags"
        ],
        "x-section": "Account schedule tags",
        "x-release-info": {
          "releaseVersion": {
            "major": 2,
            "minor": 2
          },
          "changeType": "ADD_METHOD",
          "featureFlag": "KERN_399_ACCOUNT_SCHEDULE_TAGS_API"
        },
        "x-permission-scopes": [
          "core:write",
          "core.account_schedule_tags:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/account_schedule_tagsCreateAccountScheduleTagRequest"
        }
      }
    },
    "/v1/account-schedule-tags/{account_schedule_tag.id}": {
      "put": {
        "summary": "Updates an AccountScheduleTag.",
        "operationId": "UpdateAccountScheduleTag",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/account_schedule_tagsAccountScheduleTag"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The ID of the AccountScheduleTag; it is used to tag schedules in a Smart Contract or Supervisor Contract.",
            "name": "account_schedule_tag.id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIAccountScheduleTags"
        ],
        "x-section": "Account schedule tags",
        "x-release-info": {
          "releaseVersion": {
            "major": 2,
            "minor": 2
          },
          "changeType": "ADD_METHOD",
          "featureFlag": "KERN_399_ACCOUNT_SCHEDULE_TAGS_API"
        },
        "x-permission-scopes": [
          "core:write",
          "core.account_schedule_tags:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/account_schedule_tagsUpdateAccountScheduleTagRequest"
        }
      }
    },
    "/v1/account-schedule-tags:batchGet": {
      "get": {
        "summary": "Retrieves one or more AccountScheduleTags based on their AccountScheduleTag IDs.",
        "operationId": "BatchGetAccountScheduleTags",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/account_schedule_tagsBatchGetAccountScheduleTagsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A list of the IDs of the AccountScheduleTags that are to be retrieved. The 5.0 release will reduce the maximum number of IDs to 50.\n\nRequired.\nMin count: 1.\nMax count: 500.",
            "name": "ids",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIAccountScheduleTags"
        ],
        "x-section": "Account schedule tags",
        "x-release-info": {
          "releaseVersion": {
            "major": 2,
            "minor": 2
          },
          "changeType": "ADD_METHOD",
          "featureFlag": "KERN_399_ACCOUNT_SCHEDULE_TAGS_API"
        },
        "x-permission-scopes": [
          "core:read",
          "core.account_schedule_tags:read"
        ]
      }
    },
    "/v1/account-migrations": {
      "get": {
        "summary": "Lists and filters account migrations.",
        "operationId": "ListAccountMigrations",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accountsListAccountMigrationsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The statuses of account migrations; these are used to filter on. Optional.",
            "name": "statuses",
            "in": "query",
            "required": false,
            "x-enum-value-descriptions": {
              "ACCOUNT_MIGRATION_STATUS_COMPLETED": "Indicates that the account migration has been completed.",
              "ACCOUNT_MIGRATION_STATUS_PAUSED": "Indicates that the account migration has been paused.",
              "ACCOUNT_MIGRATION_STATUS_PENDING_EXECUTION": "Indicates that the account migration is in progress.",
              "ACCOUNT_MIGRATION_STATUS_UNKNOWN": "Default value."
            },
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "ACCOUNT_MIGRATION_STATUS_UNKNOWN",
                  "ACCOUNT_MIGRATION_STATUS_PENDING_EXECUTION",
                  "ACCOUNT_MIGRATION_STATUS_PAUSED",
                  "ACCOUNT_MIGRATION_STATUS_COMPLETED"
                ]
              }
            }
          },
          {
            "description": "The number of results to be listed. Required; must be non-zero. The 5.0 release will reduce the maximum page size to 100.\n\nRequired.\nMin value: 1.\nMax value: 1000.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "Token of the page the results are to be retrieved from. If empty, returns the first page of results. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIAccounts"
        ],
        "x-section": "Accounts",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.account_migrations:read"
        ]
      },
      "post": {
        "summary": "Creates an account migration.",
        "operationId": "CreateAccountMigration",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accountsAccountMigration"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIAccounts"
        ],
        "x-section": "Accounts",
        "x-permission-scopes": [
          "core:write",
          "core.account_migrations:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/accountsCreateAccountMigrationRequest"
        }
      }
    },
    "/v1/account-migrations/{account_migration.id}": {
      "put": {
        "summary": "Updates an account migration. Only updates to the account migration status are currently supported.",
        "operationId": "UpdateAccountMigration",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accountsAccountMigration"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A unique identifier for the account migration. Optional.",
            "name": "account_migration.id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIAccounts"
        ],
        "x-section": "Accounts",
        "x-permission-scopes": [
          "core:write",
          "core.account_migrations:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/accountsUpdateAccountMigrationRequest"
        }
      }
    },
    "/v1/account-migrations:batchGet": {
      "get": {
        "summary": "Retrieves one or more account migrations by account migration ID.",
        "operationId": "BatchGetAccountMigrations",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accountsBatchGetAccountMigrationsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A list of the IDs of account migrations that are to be retrieved. Required; must be non-empty. The 5.0 release will enforce a maximum number of IDs of 50.\n\nRequired.\nMin count: 1.",
            "name": "ids",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIAccounts"
        ],
        "x-section": "Accounts",
        "x-permission-scopes": [
          "core:read",
          "core.account_migrations:read"
        ]
      }
    },
    "/v1/account-schedule-assocs": {
      "get": {
        "summary": "Lists the associations of an account and its Schedules.",
        "operationId": "ListAccountScheduleAssocs",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accountsListAccountScheduleAssocsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The account ID that Account Schedule associations are to be listed for.\n\nRequired.",
            "name": "account_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The number of results to be listed.\n\nRequired.\nMin value: 1.\nMax value: 500.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "Token of the page the results are to be retrieved from. If empty, returns the first page of results. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIAccounts"
        ],
        "x-section": "Accounts",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.account_schedule_assocs:read"
        ]
      }
    },
    "/v1/account-schedule-assocs/{id}": {
      "get": {
        "summary": "Retrieves a specified association between an account and a Schedule.",
        "operationId": "GetAccountScheduleAssoc",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accountsAccountScheduleAssoc"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The ID of the Account Schedule association that is to be retrieved. Required.",
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIAccounts"
        ],
        "x-section": "Accounts",
        "x-permission-scopes": [
          "core:read",
          "core.account_schedule_assocs:read"
        ]
      }
    },
    "/v1/account-update-batches": {
      "get": {
        "summary": "Lists and filters account update batches.",
        "operationId": "ListAccountUpdateBatches",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accountsListAccountUpdateBatchesResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The IDs of the account migrations that account update batches are to be listed for. Required; must be non-empty.",
            "name": "account_migration_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "The number of results to be listed. Required; must be non-zero.\n\nRequired.\nMin value: 1.\nMax value: 20.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "The token of the page the results are to be retrieved from. If empty, returns the first page of results. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIAccounts"
        ],
        "x-section": "Accounts",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.account_update_batches:read"
        ]
      },
      "post": {
        "summary": "Creates a batch of account updates. Account update batches are used to update multiple accounts.",
        "operationId": "CreateAccountUpdateBatch",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accountsAccountUpdateBatch"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIAccounts"
        ],
        "x-section": "Accounts",
        "x-permission-scopes": [
          "core:write",
          "core.account_update_batches:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/accountsCreateAccountUpdateBatchRequest"
        }
      }
    },
    "/v1/account-update-batches:batchGet": {
      "get": {
        "summary": "Retrieves one or more account update batches by account update batch ID.",
        "operationId": "BatchGetAccountUpdateBatches",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accountsBatchGetAccountUpdateBatchesResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A list of the IDs of account update batches that are to be retrieved. Required; must be non-empty.\n\nRequired.\nMin count: 1.\nMax count: 20.",
            "name": "ids",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIAccounts"
        ],
        "x-section": "Accounts",
        "x-permission-scopes": [
          "core:read",
          "core.account_update_batches:read"
        ]
      }
    },
    "/v1/account-updates": {
      "get": {
        "summary": "Lists and filters account updates for a specified account ID.",
        "operationId": "ListAccountUpdates",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accountsListAccountUpdatesResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The ID of the account that updates are to be listed for. Required.",
            "name": "account_id",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Statuses of account updates to filter on. Optional.",
            "name": "statuses",
            "in": "query",
            "required": false,
            "x-enum-value-descriptions": {
              "ACCOUNT_UPDATE_STATUS_COMPLETED": "The AccountUpdate was successfully executed.",
              "ACCOUNT_UPDATE_STATUS_ERRORED": "The AccountUpdate errored.",
              "ACCOUNT_UPDATE_STATUS_PENDING_EXECUTION": "The AccountUpdate hasn't been picked up from the queue or is in progress.",
              "ACCOUNT_UPDATE_STATUS_REJECTED": "The AccountUpdate failed validation of a constraint in the async pipeline.",
              "ACCOUNT_UPDATE_STATUS_UNKNOWN": "Default value."
            },
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "ACCOUNT_UPDATE_STATUS_UNKNOWN",
                  "ACCOUNT_UPDATE_STATUS_PENDING_EXECUTION",
                  "ACCOUNT_UPDATE_STATUS_COMPLETED",
                  "ACCOUNT_UPDATE_STATUS_REJECTED",
                  "ACCOUNT_UPDATE_STATUS_ERRORED"
                ]
              }
            }
          },
          {
            "description": "The number of results to be listed. Required; must be non-zero. The 5.0 release will reduce the maximum page size to 100.\n\nRequired.\nMin value: 1.\nMax value: 1000.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "Token of the page the results are to be retrieved from. If empty, returns the first page of results. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIAccounts"
        ],
        "x-section": "Accounts",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.account_updates:read"
        ]
      },
      "post": {
        "summary": "Registers a request for an account update to be created and executed asynchronously. The account_id field is required for the creation of an account update. The ID of an account update can be specified for create requests. An account update can be created to either update the instance parameter values, the product version of an account or to retry a closure update.",
        "operationId": "CreateAccountUpdate",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accountsAccountUpdate"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIAccounts"
        ],
        "x-section": "Accounts",
        "x-permission-scopes": [
          "core:write",
          "core.account_updates:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/accountsCreateAccountUpdateRequest"
        }
      }
    },
    "/v1/account-updates/{id}": {
      "get": {
        "summary": "Retrieves a specific account update by account update ID.",
        "operationId": "GetAccountUpdate",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accountsAccountUpdate"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The ID of the account update that is to be retrieved. Required.",
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIAccounts"
        ],
        "x-section": "Accounts",
        "x-permission-scopes": [
          "core:read",
          "core.account_updates:read"
        ]
      }
    },
    "/v1/account-updates:batchGet": {
      "get": {
        "summary": "Retrieves one or more account updates based on their account update IDs.",
        "operationId": "BatchGetAccountUpdates",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accountsBatchGetAccountUpdatesResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A list of the IDs of account updates that are to be retrieved. Required; must be non-empty. The 5.0 release will enforce a maximum number of IDs of 50.\n\nRequired.\nMin count: 1.",
            "name": "ids",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIAccounts"
        ],
        "x-section": "Accounts",
        "x-permission-scopes": [
          "core:read",
          "core.account_updates:read"
        ]
      }
    },
    "/v1/accounts": {
      "get": {
        "summary": "Retrieves all the accounts for a customer.",
        "operationId": "ListAccounts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accountsListAccountsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The  ID of the stakeholder whose accounts are to be listed. Optional.",
            "name": "stakeholder_id",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The number of results to be listed. The 5.0 release will reduce the maximum page size to 100.\n\nRequired.\nMin value: 1.\nMax value: 1000.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "Token of the page the results are to be retrieved from. If empty, returns the first page of results. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "List of inclusive OR account status filters. Must be URL encoded. Optional.",
            "name": "account_statuses",
            "in": "query",
            "required": false,
            "x-enum-value-descriptions": {
              "ACCOUNT_STATUS_CANCELLED": "Account was requested but was never approved, it is now permanently closed.",
              "ACCOUNT_STATUS_CLOSED": "Account was previously open but is now permanently closed.",
              "ACCOUNT_STATUS_OPEN": "Account has been approved and transactions are allowed.",
              "ACCOUNT_STATUS_PENDING": "Account and contract record has been created, it is waiting for another call to be made open.",
              "ACCOUNT_STATUS_PENDING_CLOSURE": "Account was requested closure but contract and account closure are not finished.",
              "ACCOUNT_STATUS_UNKNOWN": "Default value."
            },
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "ACCOUNT_STATUS_UNKNOWN",
                  "ACCOUNT_STATUS_OPEN",
                  "ACCOUNT_STATUS_CLOSED",
                  "ACCOUNT_STATUS_CANCELLED",
                  "ACCOUNT_STATUS_PENDING_CLOSURE",
                  "ACCOUNT_STATUS_PENDING"
                ]
              }
            }
          },
          {
            "description": "List of inclusive OR product version ID filters. Must be URL encoded. Optional.",
            "name": "product_version_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "schema": {
              "type": "string"
            },
            "name": "opening_timestamp_range.from",
            "in": "query",
            "required": false,
            "description": "The timestamp range that the account's opening timestamp must belong to. This range is from opening_timestamp_range.from up to and not including opening_timestamp_range.to. Optional. This is an auto generated field to make the swagger compatible with the third party codegen tool.",
            "x-release-info": {
              "releaseVersion": {
                "major": 2,
                "minor": 1
              },
              "changeType": "ADD_FIELD",
              "featureFlag": "KERN_337_LIST_ACCOUNTS_TIMESTAMP_RANGE_FILTERS"
            }
          },
          {
            "schema": {
              "type": "string"
            },
            "name": "opening_timestamp_range.to",
            "in": "query",
            "required": false,
            "description": "The timestamp range that the account's opening timestamp must belong to. This range is from opening_timestamp_range.from up to and not including opening_timestamp_range.to. Optional. This is an auto generated field to make the swagger compatible with the third party codegen tool.",
            "x-release-info": {
              "releaseVersion": {
                "major": 2,
                "minor": 1
              },
              "changeType": "ADD_FIELD",
              "featureFlag": "KERN_337_LIST_ACCOUNTS_TIMESTAMP_RANGE_FILTERS"
            }
          },
          {
            "schema": {
              "type": "string"
            },
            "name": "closing_timestamp_range.from",
            "in": "query",
            "required": false,
            "description": "The timestamp range that the account's closing timestamp must belong to. This range is from closing_timestamp_range.from up to and not including closing_timestamp_range.to. Optional. This is an auto generated field to make the swagger compatible with the third party codegen tool.",
            "x-release-info": {
              "releaseVersion": {
                "major": 2,
                "minor": 1
              },
              "changeType": "ADD_FIELD",
              "featureFlag": "KERN_337_LIST_ACCOUNTS_TIMESTAMP_RANGE_FILTERS"
            }
          },
          {
            "schema": {
              "type": "string"
            },
            "name": "closing_timestamp_range.to",
            "in": "query",
            "required": false,
            "description": "The timestamp range that the account's closing timestamp must belong to. This range is from closing_timestamp_range.from up to and not including closing_timestamp_range.to. Optional. This is an auto generated field to make the swagger compatible with the third party codegen tool.",
            "x-release-info": {
              "releaseVersion": {
                "major": 2,
                "minor": 1
              },
              "changeType": "ADD_FIELD",
              "featureFlag": "KERN_337_LIST_ACCOUNTS_TIMESTAMP_RANGE_FILTERS"
            }
          }
        ],
        "tags": [
          "CoreAPIAccounts"
        ],
        "x-section": "Accounts",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.accounts:read"
        ]
      },
      "post": {
        "summary": "Creates an account for a customer. The account can be created with a status of OPEN or PENDING.",
        "operationId": "CreateAccount",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accountsAccount"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIAccounts"
        ],
        "x-section": "Accounts",
        "x-permission-scopes": [
          "core:write",
          "core.accounts:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/accountsCreateAccountRequest"
        }
      }
    },
    "/v1/accounts/{account.id}": {
      "put": {
        "summary": "Updates a customer's account.",
        "operationId": "UpdateAccount",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accountsAccount"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A unique ID for an account. Optional for create requests.",
            "name": "account.id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIAccounts"
        ],
        "x-section": "Accounts",
        "x-permission-scopes": [
          "core:write",
          "core.accounts:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/accountsUpdateAccountRequest"
        }
      }
    },
    "/v1/accounts/{account_id}:paramTimeseries": {
      "get": {
        "summary": "Lists the timeseries for the parameters on an account. This endpoint will change once we have a more generalised method for returning timeseries.",
        "operationId": "ListAccountParamTimeseries",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accountsListAccountParamTimeseriesResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The account ID a parameter timeseries is to be retrieved for.",
            "name": "account_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIAccounts"
        ],
        "x-section": "Accounts",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.accounts:read"
        ]
      }
    },
    "/v1/accounts/{account_id}:updateDetails": {
      "put": {
        "summary": "Updates the details of an account.",
        "operationId": "UpdateAccountDetails",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accountsAccount"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The account that is to be updated. Required.",
            "name": "account_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIAccounts"
        ],
        "x-section": "Accounts",
        "x-permission-scopes": [
          "core:write",
          "core.accounts:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/accountsUpdateAccountDetailsRequest"
        }
      }
    },
    "/v1/accounts/{id}": {
      "get": {
        "summary": "Retrieves a specified account of the customer.",
        "operationId": "GetAccount",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/accountsAccount"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The ID of the account to be retrieved. Required.",
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "A list of fields to display, which are omitted by default.",
            "name": "fields_to_include",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "INCLUDE_FIELD_DERIVED_INSTANCE_PARAM_VALS"
                ]
              }
            }
          },
          {
            "description": "The returned instance and derived parameter values will be calculated as of this timestamp.",
            "name": "instance_param_vals_effective_timestamp",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          }
        ],
        "tags": [
          "CoreAPIAccounts"
        ],
        "x-section": "Accounts",
        "x-permission-scopes": [
          "core:read",
          "core.accounts:read"
        ]
      }
    },
    "/v1/service-accounts": {
      "get": {
        "summary": "Lists service accounts with pagination. The request must include a page_size parameter. A list of statuses may be used as a filter. A page_token may be included to retrieve a specific page of results.",
        "operationId": "ListServiceAccounts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/authListServiceAccountsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A list of service account statuses that may be used as logical OR filters for results. Optional.",
            "name": "service_account_statuses",
            "in": "query",
            "required": false,
            "x-enum-value-descriptions": {
              "SERVICE_ACCOUNT_STATUS_ACTIVE": "The service account is active and can authenticate.",
              "SERVICE_ACCOUNT_STATUS_FROZEN": "The service account has been frozen and transactions are temporarily prohibited.",
              "SERVICE_ACCOUNT_STATUS_INACTIVE": "The service account has been deactivated and is no longer visible to users.",
              "SERVICE_ACCOUNT_STATUS_UNKNOWN": "The service account status is unknown."
            },
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "SERVICE_ACCOUNT_STATUS_UNKNOWN",
                  "SERVICE_ACCOUNT_STATUS_ACTIVE",
                  "SERVICE_ACCOUNT_STATUS_INACTIVE",
                  "SERVICE_ACCOUNT_STATUS_FROZEN"
                ]
              }
            }
          },
          {
            "description": "The number of results to be listed. Required; must have an integer value in the range 1-100.\n\nRequired.\nMin value: 1.\nMax value: 100.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "Token of the page the results are to be retrieved from. If empty, returns the first page of results. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIAuth"
        ],
        "x-section": "Auth",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.service_accounts:read"
        ]
      },
      "post": {
        "summary": "Creates and returns a service account with the access token populated. The name field of the service account is required for creation. For this endpoint retries work as normal but a new token is generated each time.",
        "operationId": "CreateServiceAccount",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/authServiceAccount"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIAuth"
        ],
        "x-section": "Auth",
        "x-permission-scopes": [
          "core:write",
          "core.service_accounts:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/authCreateServiceAccountRequest"
        }
      }
    },
    "/v1/service-accounts/{id}": {
      "get": {
        "summary": "Retrieves the service account for the service account ID provided.",
        "operationId": "GetServiceAccount",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/authServiceAccount"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The ID of the service account that is to be retrieved.",
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIAuth"
        ],
        "x-section": "Auth",
        "x-permission-scopes": [
          "core:read",
          "core.service_accounts:read"
        ]
      }
    },
    "/v1/service-accounts/{service_account.id}": {
      "put": {
        "summary": "Updates a service account. The service account token will only be returned when the token is refreshed or if an inactive service account is reactivated. If an inactive service account is reactivated, a new token is generated. A service account with active status can be updated to be frozen or inactive. A service account with frozen status can be updated to active or inactive. If a frozen account is reactivated, a new token is not required. A service account with inactive status can only be updated to active status. Freezing a service account will disable existing tokens until the service account is reactivated. Deactivating a service account will permanently invalidate all previous tokens and new tokens will be required.",
        "operationId": "UpdateServiceAccount",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/authServiceAccount"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A unique string ID for a service account. Output only.",
            "name": "service_account.id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIAuth"
        ],
        "x-section": "Auth",
        "x-permission-scopes": [
          "core:write",
          "core.service_accounts:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/authUpdateServiceAccountRequest"
        }
      }
    },
    "/v1/service-accounts/{service_account_id}:updatePermissions": {
      "put": {
        "summary": "Updates the permissions for a service account.",
        "operationId": "UpdateServiceAccountPermissions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/authServiceAccount"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The ID of the service account that is to be updated. Required.",
            "name": "service_account_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIAuth"
        ],
        "x-section": "Auth",
        "x-permission-scopes": [
          "core:write",
          "core.service_accounts:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/authUpdateServiceAccountPermissionsRequest"
        }
      }
    },
    "/v1/service-accounts:batchGet": {
      "get": {
        "summary": "Retrieves service accounts for the service account IDs provided.",
        "operationId": "BatchGetServiceAccounts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/authBatchGetServiceAccountsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A list of the IDs of service accounts that are to be retrieved. Required; must be non-empty.\n\nRequired.\nMin length: 1 characters.",
            "name": "ids",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIAuth"
        ],
        "x-section": "Auth",
        "x-permission-scopes": [
          "core:read",
          "core.service_accounts:read"
        ]
      }
    },
    "/v1/token:validate": {
      "get": {
        "summary": "Checks if a token is valid.",
        "operationId": "ValidateToken",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/authValidateTokenResponse"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIAuth"
        ],
        "x-section": "Auth"
      }
    },
    "/v1/balances/live": {
      "get": {
        "summary": "Retrieves the latest balances for the supplied account IDs ordered by decreasing `id`.",
        "operationId": "ListBalancesLive",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/balancesListBalancesLiveResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The IDs of the accounts the balances belong to. Required.",
            "name": "account_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "Filters results by account address. Optional.",
            "name": "account_addresses",
            "in": "query",
            "required": false,
            "x-example-override": "[\"DEFAULT\"]",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "The number of results to be retrieved. Required.\n\nRequired.\nMin value: 1.\nMax value: 10000.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "The token of the page the results are to be retrieved from. If empty, this is the first page of results. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "x-example-override": "nASlspO",
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIBalances"
        ],
        "x-section": "Balances",
        "x-list-consistency-level": "SNAPSHOT",
        "x-permission-scopes": [
          "core:read",
          "core.balances:read"
        ]
      }
    },
    "/v1/balances/timerange": {
      "get": {
        "summary": "Retrieves a time range of balances for the supplied account IDs ordered by decreasing `value_time`. If multiple entries have the same `value_time`, they will be grouped by balance definition, and within the groups the entries are ordered by decreasing logical time. This includes all balance events within the time range and the latest state of the balances as of the `from_time`, if provided, which could be prior to the time range.",
        "operationId": "ListBalancesTimeRange",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/balancesListBalancesTimeRangeResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The IDs of the accounts the balances belong to. Required.",
            "name": "account_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "Filters results by account address.",
            "name": "account_addresses",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "The earliest time in the time range of the returned balances. Optional. If included, will also return the latest balance event before the `from_time` for comparison. If omitted, the results will start from the first available balance event.",
            "name": "from_time",
            "in": "query",
            "required": false,
            "x-example-override": "2021-01-01T01:00:00.00Z",
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "description": "The latest time in the time range of the returned balances. Optional. If omitted, the results will end at the last available balance event.",
            "name": "to_time",
            "in": "query",
            "required": false,
            "x-example-override": "2021-01-01T12:00:00.00Z",
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "description": "The number of results to be retrieved. Required.\n\nRequired.\nMin value: 1.\nMax value: 10000.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "Token of the page the results are to be retrieved from. If empty, this is the first page of results. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIBalances"
        ],
        "x-section": "Balances",
        "x-list-consistency-level": "SNAPSHOT",
        "x-permission-scopes": [
          "core:read",
          "core.balances:read"
        ]
      }
    },
    "/v1/balances/{id}": {
      "get": {
        "summary": "Retrieves a specific balance.",
        "operationId": "GetBalance",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/balancesBalance"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The ID of the balance to be retrieved. Required.",
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIBalances"
        ],
        "x-section": "Balances",
        "x-permission-scopes": [
          "core:read",
          "core.balances:read"
        ]
      }
    },
    "/v1/calendar": {
      "post": {
        "summary": "CreateCalendar creates a Calendar.",
        "operationId": "CreateCalendar",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/calendarCalendar"
                }
              }
            }
          },
          "400": {
            "description": "The error response for 400",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarINVALID_ARGUMENT_0",
                  "description": "Returned on receipt of invalid input regardless of the state of the system",
                  "title": "INVALID_ARGUMENT"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "404": {
            "description": "The error response for 404",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarNOT_FOUND_1",
                  "description": "Returned on the resource being retrieved or mutated not being found",
                  "title": "NOT_FOUND"
                }
              }
            }
          },
          "409": {
            "description": "The error response for 409",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateCalendarALREADY_EXISTS_0",
                  "description": "Returned when a Calendar with the same `id` already exists",
                  "title": "ALREADY_EXISTS"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPICalendar"
        ],
        "x-section": "Calendar",
        "x-permission-scopes": [
          "core:write",
          "core.calendars:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/calendarCreateCalendarRequest"
        }
      }
    },
    "/v1/calendar-event": {
      "get": {
        "summary": "ListCalendarEvents retrieves a list of Calendar Events that occur within a specified time range.",
        "operationId": "ListCalendarEvents",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/calendarListCalendarEventsResponse"
                }
              }
            }
          },
          "400": {
            "description": "The error response for 400",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarINVALID_ARGUMENT_0",
                  "description": "Returned on receipt of invalid input regardless of the state of the system",
                  "title": "INVALID_ARGUMENT"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "Filters by Calendars IDs; if this is not set, all Calendars will be included.",
            "name": "calendar_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "Filters by Calendar Event names; if filter criteria are not given, all Calendar Event names will be listed.",
            "name": "calendar_event_names",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "The number of results to be listed. Must be non-zero.\n\nRequired.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "Token of the page the results are to be retrieved from. If set, all other filtering parameters are ignored.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "active_calendar_event",
            "in": "query",
            "required": false,
            "x-release-info": {
              "releaseVersion": {
                "major": 2,
                "minor": 4
              },
              "changeType": "ADD_FIELD",
              "description": "This field replaces: is_active."
            },
            "schema": {
              "type": "string",
              "enum": [
                "BOTH",
                "ONLY_TRUE",
                "ONLY_FALSE"
              ],
              "default": "BOTH"
            }
          },
          {
            "schema": {
              "type": "string"
            },
            "name": "calendar_timestamp_range.from",
            "in": "query",
            "required": false,
            "description": "The Timestamp range that the Calendar Event is valid for. This is an auto generated field to make the swagger compatible with the third party codegen tool."
          },
          {
            "schema": {
              "type": "string"
            },
            "name": "calendar_timestamp_range.to",
            "in": "query",
            "required": false,
            "description": "The Timestamp range that the Calendar Event is valid for. This is an auto generated field to make the swagger compatible with the third party codegen tool."
          }
        ],
        "tags": [
          "CoreAPICalendar"
        ],
        "x-section": "Calendar",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.calendar_events:read"
        ]
      },
      "post": {
        "summary": "CreateCalendarEvent creates a Calendar Event.",
        "operationId": "CreateCalendarEvent",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/calendarCalendarEvent"
                }
              }
            }
          },
          "400": {
            "description": "The error response for 400",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarINVALID_ARGUMENT_0",
                  "description": "Returned on receipt of invalid input regardless of the state of the system",
                  "title": "INVALID_ARGUMENT"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "404": {
            "description": "The error response for 404",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarNOT_FOUND_1",
                  "description": "Returned on the resource being retrieved or mutated not being found",
                  "title": "NOT_FOUND"
                }
              }
            }
          },
          "409": {
            "description": "The error response for 409",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateCalendarEventALREADY_EXISTS_0",
                  "description": "Returned when a Calendar Event with the same `id` already exists",
                  "title": "ALREADY_EXISTS"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPICalendar"
        ],
        "x-section": "Calendar",
        "x-permission-scopes": [
          "core:write",
          "core.calendar_events:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/calendarCreateCalendarEventRequest"
        }
      }
    },
    "/v1/calendar-event/{calendar_event_id}:updateDetails": {
      "put": {
        "summary": "UpdateCalendarEvent updates a Calendar Event based on a provided Calendar Event ID. From Vault **4.0.0** onwards, an inactive Calendar Event can only have the `is_active` field updated.",
        "operationId": "UpdateCalendarEvent",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/calendarCalendarEvent"
                }
              }
            }
          },
          "400": {
            "description": "The error response for 400",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarINVALID_ARGUMENT_0",
                  "description": "Returned on receipt of invalid input regardless of the state of the system",
                  "title": "INVALID_ARGUMENT"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "404": {
            "description": "The error response for 404",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarNOT_FOUND_1",
                  "description": "Returned on the resource being retrieved or mutated not being found",
                  "title": "NOT_FOUND"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The ID of the calendar event that is to be updated.",
            "name": "calendar_event_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPICalendar"
        ],
        "x-section": "Calendar",
        "x-release-info": {
          "releaseVersion": {
            "major": 2,
            "minor": 4
          },
          "changeType": "ADD_METHOD",
          "description": "This endpoint updates a calendar event with a given id"
        },
        "x-permission-scopes": [
          "core:write",
          "core.calendar_events:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/calendarUpdateCalendarEventRequest"
        }
      }
    },
    "/v1/calendar-event/{id}": {
      "get": {
        "summary": "GetCalendarEvent retrieves a Calendar Event using its ID.",
        "operationId": "GetCalendarEvent",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/calendarCalendarEvent"
                }
              }
            }
          },
          "400": {
            "description": "The error response for 400",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarINVALID_ARGUMENT_0",
                  "description": "Returned on receipt of invalid input regardless of the state of the system",
                  "title": "INVALID_ARGUMENT"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "404": {
            "description": "The error response for 404",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarNOT_FOUND_1",
                  "description": "Returned on the resource being retrieved or mutated not being found",
                  "title": "NOT_FOUND"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "Maps the ID to the requested CalendarEvent.",
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPICalendar"
        ],
        "x-section": "Calendar",
        "x-permission-scopes": [
          "core:read",
          "core.calendar_events:read"
        ]
      }
    },
    "/v1/calendar-event:batchGet": {
      "get": {
        "summary": "BatchGetCalendarEvents retrieves a list of Calendar Events using their IDs.",
        "operationId": "BatchGetCalendarEvents",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/calendarBatchGetCalendarEventsResponse"
                }
              }
            }
          },
          "400": {
            "description": "The error response for 400",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarINVALID_ARGUMENT_0",
                  "description": "Returned on receipt of invalid input regardless of the state of the system",
                  "title": "INVALID_ARGUMENT"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "404": {
            "description": "The error response for 404",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarNOT_FOUND_1",
                  "description": "Returned on the resource being retrieved or mutated not being found",
                  "title": "NOT_FOUND"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "Maps the Calendar ID to the requested Calendars.",
            "name": "ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPICalendar"
        ],
        "x-section": "Calendar",
        "x-permission-scopes": [
          "core:read",
          "core.calendar_events:read"
        ]
      }
    },
    "/v1/calendar-period-descriptor": {
      "post": {
        "summary": "CreateCalendarPeriodDescriptor creates a Calendar Period Descriptor.",
        "operationId": "CreateCalendarPeriodDescriptor",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/calendarCalendarPeriodDescriptor"
                }
              }
            }
          },
          "400": {
            "description": "The error response for 400",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarINVALID_ARGUMENT_0",
                  "description": "Returned on receipt of invalid input regardless of the state of the system",
                  "title": "INVALID_ARGUMENT"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "409": {
            "description": "The error response for 409",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateCalendarPeriodDescriptorALREADY_EXISTS_0",
                  "description": "Returned when a Calendar Period Descriptor with the same `id` already exists",
                  "title": "ALREADY_EXISTS"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPICalendar"
        ],
        "x-section": "Calendar",
        "x-release-info": {
          "releaseVersion": {
            "major": 2,
            "minor": 8
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:write",
          "core.calendar_period_descriptors:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/calendarCreateCalendarPeriodDescriptorRequest"
        }
      }
    },
    "/v1/calendar/bookkeeping-date/{id}": {
      "get": {
        "summary": "GetBookkeepingDate retrieves the Bookkeeping Date for the given ID.",
        "operationId": "GetBookkeepingDate",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/calendarBookkeepingDate"
                }
              }
            }
          },
          "400": {
            "description": "The error response for 400",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarINVALID_ARGUMENT_0",
                  "description": "Returned on receipt of invalid input regardless of the state of the system",
                  "title": "INVALID_ARGUMENT"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "404": {
            "description": "The error response for 404",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarNOT_FOUND_1",
                  "description": "Returned on the resource being retrieved or mutated not being found",
                  "title": "NOT_FOUND"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The associated Calendar to retrieve the next Bookkeeping Date for",
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPICalendar"
        ],
        "x-section": "Calendar",
        "x-release-info": {
          "releaseVersion": {
            "major": 3,
            "minor": 1
          },
          "changeType": "ADD_METHOD",
          "description": "This retrieves the Bookkeeping Date for the specified ID"
        },
        "x-permission-scopes": [
          "core:read",
          "core.bookkeeping_dates:read"
        ]
      },
      "put": {
        "summary": "UpdateBookkeepingDate updates a Bookkeeping Date by the provided id. This specifies what the next calendar period to be published should be annotated with.",
        "operationId": "UpdateBookkeepingDate",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/calendarBookkeepingDate"
                }
              }
            }
          },
          "400": {
            "description": "The error response for 400",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarINVALID_ARGUMENT_0",
                  "description": "Returned on receipt of invalid input regardless of the state of the system",
                  "title": "INVALID_ARGUMENT"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "404": {
            "description": "The error response for 404",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarNOT_FOUND_1",
                  "description": "Returned on the resource being retrieved or mutated not being found",
                  "title": "NOT_FOUND"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The ID, which is linked to the Calendar that will be affected",
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPICalendar"
        ],
        "x-section": "Calendar",
        "x-release-info": {
          "releaseVersion": {
            "major": 3,
            "minor": 1
          },
          "changeType": "ADD_METHOD",
          "description": "This updates the Bookkeeping Date for the given ID"
        },
        "x-permission-scopes": [
          "core:write",
          "core.bookkeeping_dates:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/calendarUpdateBookkeepingDateRequest"
        }
      }
    },
    "/v1/calendar/{calendar_id}/period/current:change": {
      "put": {
        "summary": "ChangeCurrentCalendarPeriod changes the duration of the current calendar period.",
        "operationId": "ChangeCurrentCalendarPeriod",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/calendarCalendarPeriod"
                }
              }
            }
          },
          "400": {
            "description": "The error response for 400",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarINVALID_ARGUMENT_0",
                  "description": "Returned on receipt of invalid input regardless of the state of the system",
                  "title": "INVALID_ARGUMENT"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "404": {
            "description": "The error response for 404",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarNOT_FOUND_1",
                  "description": "Returned on the resource being retrieved or mutated not being found",
                  "title": "NOT_FOUND"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "ID of the calendar.",
            "name": "calendar_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPICalendar"
        ],
        "x-section": "Calendar",
        "x-release-info": {
          "releaseVersion": {
            "major": 2,
            "minor": 8
          },
          "changeType": "ADD_METHOD",
          "description": "This endpoint changes the duration of the current calendar period"
        },
        "x-permission-scopes": [
          "core:write",
          "core.calendar_periods:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/calendarChangeCurrentCalendarPeriodRequest"
        }
      }
    },
    "/v1/calendar/{calendar_id}:calculatePeriod": {
      "get": {
        "summary": "CalculateCalendarPeriod calculates the number of period resolution units from the start epoch of the Calendar to the given time and returns the expected Calendar Period data. Already-emitted Calendar Periods will be returned as-is.",
        "operationId": "CalculateCalendarPeriod",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/calendarCalendarPeriod"
                }
              }
            }
          },
          "400": {
            "description": "The error response for 400",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarINVALID_ARGUMENT_0",
                  "description": "Returned on receipt of invalid input regardless of the state of the system",
                  "title": "INVALID_ARGUMENT"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "404": {
            "description": "The error response for 404",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarNOT_FOUND_1",
                  "description": "Returned on the resource being retrieved or mutated not being found",
                  "title": "NOT_FOUND"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The Calendar ID that will be used when calculating the number of period resolution units from the Calendar's start epoch.",
            "name": "calendar_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The latest time that the number of period resolution units is calculated up to. Defaults to the current time.",
            "name": "timestamp",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          }
        ],
        "tags": [
          "CoreAPICalendar"
        ],
        "x-section": "Calendar",
        "x-release-info": {
          "releaseVersion": {
            "major": 2,
            "minor": 8
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:read",
          "core.calendar_periods:read"
        ]
      }
    },
    "/v1/calendar/{calendar_id}:updateDetails": {
      "put": {
        "summary": "UpdateCalendar updates a Calendar based on a provided Calendar ID.",
        "operationId": "UpdateCalendar",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/calendarCalendar"
                }
              }
            }
          },
          "400": {
            "description": "The error response for 400",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarINVALID_ARGUMENT_0",
                  "description": "Returned on receipt of invalid input regardless of the state of the system",
                  "title": "INVALID_ARGUMENT"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "404": {
            "description": "The error response for 404",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarNOT_FOUND_1",
                  "description": "Returned on the resource being retrieved or mutated not being found",
                  "title": "NOT_FOUND"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The ID of the calendar that is to be updated.",
            "name": "calendar_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPICalendar"
        ],
        "x-section": "Calendar",
        "x-release-info": {
          "releaseVersion": {
            "major": 2,
            "minor": 7
          },
          "changeType": "ADD_METHOD",
          "description": "This endpoint updates a calendar event with a given id"
        },
        "x-permission-scopes": [
          "core:write",
          "core.calendars:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/calendarUpdateCalendarRequest"
        }
      }
    },
    "/v1/calendar/{id}": {
      "get": {
        "summary": "GetCalendar retrieves a Calendar using its ID.",
        "operationId": "GetCalendar",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/calendarCalendar"
                }
              }
            }
          },
          "400": {
            "description": "The error response for 400",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarINVALID_ARGUMENT_0",
                  "description": "Returned on receipt of invalid input regardless of the state of the system",
                  "title": "INVALID_ARGUMENT"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "404": {
            "description": "The error response for 404",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarNOT_FOUND_1",
                  "description": "Returned on the resource being retrieved or mutated not being found",
                  "title": "NOT_FOUND"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "Maps the ID to the requested Calendar.",
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPICalendar"
        ],
        "x-section": "Calendar",
        "x-permission-scopes": [
          "core:read",
          "core.calendars:read"
        ]
      }
    },
    "/v1/calendars": {
      "get": {
        "summary": "ListCalendars retrieves a list of Calendars.",
        "operationId": "ListCalendars",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/calendarListCalendarsResponse"
                }
              }
            }
          },
          "400": {
            "description": "The error response for 400",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPICalendarINVALID_ARGUMENT_0",
                  "description": "Returned on receipt of invalid input regardless of the state of the system",
                  "title": "INVALID_ARGUMENT"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "501": {
            "description": "The error response for 501",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ListCalendarsUNIMPLEMENTED_0",
                  "description": "Returned when an unsupported name pattern match type is specified",
                  "title": "UNIMPLEMENTED"
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The number of results to be listed. Must be non-zero.\n\nRequired.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "If a page token is supplied, the page size value must match the original value used to generate the token. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The ordering of the results. Optional.",
            "name": "order_by",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "ORDER_BY_CREATE_TIMESTAMP_ASC",
                  "ORDER_BY_CREATE_TIMESTAMP_DESC"
                ]
              }
            }
          },
          {
            "schema": {
              "$ref": "#/components/schemas/calendarNamePatternMatch",
              "description": "Pattern matching on the Group name. Optional.",
              "x-release-info": {
                "releaseVersion": {
                  "major": 2,
                  "minor": 6
                },
                "changeType": "ADD_FIELD",
                "description": "This field is used to search by a name pattern."
              }
            },
            "name": "name_pattern_match",
            "in": "query",
            "required": false
          }
        ],
        "tags": [
          "CoreAPICalendar"
        ],
        "x-section": "Calendar",
        "x-release-info": {
          "releaseVersion": {
            "major": 2,
            "minor": 4
          },
          "changeType": "ADD_METHOD",
          "description": "This endpoint lists calendars"
        },
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.calendars:read"
        ]
      }
    },
    "/v1/contract-module-versions": {
      "get": {
        "summary": "Lists Contract Module Versions.",
        "operationId": "ListContractModuleVersions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/contract_modulesListContractModuleVersionsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The Contract Module ID to retrieve values for.\n\nRequired.",
            "name": "contract_module_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The number of Contract Module Versions to be retrieved.\n\nRequired.\nMin value: 1.\nMax value: 20.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "The token of the page the results are to be retrieved from. If empty, this returns the first page of results.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIContractModules"
        ],
        "x-section": "Contract Modules",
        "x-release-info": {
          "releaseVersion": {
            "major": 2,
            "minor": 6
          },
          "changeType": "ADD_METHOD"
        },
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.contract_module_versions:read"
        ]
      },
      "post": {
        "summary": "Creates a Contract Module Version.",
        "operationId": "CreateContractModuleVersion",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/contract_modulesContractModuleVersion"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIContractModules"
        ],
        "x-section": "Contract Modules",
        "x-release-info": {
          "releaseVersion": {
            "major": 2,
            "minor": 6
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:write",
          "core.contract_module_versions:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/contract_modulesCreateContractModuleVersionRequest"
        }
      }
    },
    "/v1/contract-module-versions:batchGet": {
      "get": {
        "summary": "Retrieves one or more Contract Module Versions using the Contract Module Version ID.",
        "operationId": "BatchGetContractModuleVersions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/contract_modulesBatchGetContractModuleVersionsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "List of IDs of the Contract Module Versions to retrieve.",
            "name": "ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "Additional fields to return; optional. Some Contract Module Version fields are omitted by default as they are bulky or costly; if those fields are specified here, they will be populated in the response.",
            "name": "fields_to_include",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "INCLUDE_FIELD_CODE",
                  "INCLUDE_FIELD_DETAILS_API_VERSION",
                  "INCLUDE_FIELD_DETAILS_CALLABLE_DETAILS"
                ]
              }
            }
          }
        ],
        "tags": [
          "CoreAPIContractModules"
        ],
        "x-section": "Contract Modules",
        "x-release-info": {
          "releaseVersion": {
            "major": 2,
            "minor": 6
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:read",
          "core.contract_module_versions:read"
        ]
      }
    },
    "/v1/contract-modules": {
      "get": {
        "summary": "Lists Contract Modules.",
        "operationId": "ListContractModules",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/contract_modulesListContractModulesResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The number of Contract Modules to be retrieved.\n\nRequired.\nMin value: 1.\nMax value: 50.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "The token of the page the results are to be retrieved from. If empty, this returns the first page of results.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIContractModules"
        ],
        "x-section": "Contract Modules",
        "x-release-info": {
          "releaseVersion": {
            "major": 2,
            "minor": 6
          },
          "changeType": "ADD_METHOD"
        },
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.contract_modules:read"
        ]
      },
      "post": {
        "summary": "Creates a Contract Module.",
        "operationId": "CreateContractModule",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/contract_modulesContractModule"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIContractModules"
        ],
        "x-section": "Contract Modules",
        "x-release-info": {
          "releaseVersion": {
            "major": 2,
            "minor": 6
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:write",
          "core.contract_modules:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/contract_modulesCreateContractModuleRequest"
        }
      }
    },
    "/v1/contract-modules:batchGet": {
      "get": {
        "summary": "Retrieves one or more Contract Modules using the Contract Module ID.",
        "operationId": "BatchGetContractModules",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/contract_modulesBatchGetContractModulesResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "List of IDs of the Contract Modules to retrieve.",
            "name": "ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIContractModules"
        ],
        "x-section": "Contract Modules",
        "x-release-info": {
          "releaseVersion": {
            "major": 2,
            "minor": 6
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:read",
          "core.contract_modules:read"
        ]
      }
    },
    "/v1/smart-contract-module-versions-links": {
      "get": {
        "summary": "Lists Smart Contract Module Versions' Links.",
        "operationId": "ListSmartContractModuleVersionsLinks",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/contract_modulesListSmartContractModuleVersionsLinksResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The Smart Contract Version IDs to retrieve values for.",
            "name": "smart_contract_version_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "The Contract Module Version IDs to retrieve values for.",
            "name": "contract_module_version_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "The number of Contract Module Versions to be retrieved.\n\nRequired.\nMin value: 1.\nMax value: 50.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "The token of the page the results are to be retrieved from. If empty, this returns the first page of results.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIContractModules"
        ],
        "x-section": "Contract Modules",
        "x-release-info": {
          "releaseVersion": {
            "major": 2,
            "minor": 6
          },
          "changeType": "ADD_METHOD"
        },
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.smart_contract_module_versions_links:read"
        ]
      },
      "post": {
        "summary": "Creates a Smart Contract Module Versions Link.",
        "operationId": "CreateSmartContractModuleVersionsLink",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/contract_modulesSmartContractModuleVersionsLink"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIContractModules"
        ],
        "x-section": "Contract Modules",
        "x-release-info": {
          "releaseVersion": {
            "major": 2,
            "minor": 6
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:write",
          "core.smart_contract_module_versions_links:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/contract_modulesCreateSmartContractModuleVersionsLinkRequest"
        }
      }
    },
    "/v1/smart-contract-module-versions-links:batchGet": {
      "get": {
        "summary": "Retrieves one or more Smart Contract Module Versions Links using the Smart Contract Module Versions Link ID.",
        "operationId": "BatchGetSmartContractModuleVersionsLinks",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/contract_modulesBatchGetSmartContractModuleVersionsLinksResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "List of IDs of the Smart Contract Module Versions Links to retrieve.",
            "name": "ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIContractModules"
        ],
        "x-section": "Contract Modules",
        "x-release-info": {
          "releaseVersion": {
            "major": 2,
            "minor": 8
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:read",
          "core.smart_contract_module_versions_links:read"
        ]
      }
    },
    "/v1/contracts:simulate": {
      "post": {
        "summary": "Simulates Smart Contracts",
        "operationId": "SimulateContracts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "x-is-streaming": true,
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/contractsSimulateContractsResponse"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIContracts"
        ],
        "x-section": "Contracts",
        "x-permission-scopes": [
          "core:execute",
          "core.contracts:execute"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/contractsSimulateContractsRequest"
        }
      }
    },
    "/v1/customer-addresses": {
      "get": {
        "summary": "Retrieves a customer address. This could retrieve no addresses, a single address or multiple addresses.",
        "operationId": "ListCustomerAddresses",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/customersListCustomerAddressesResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The unique ID of the customer.\n\nRequired.",
            "name": "customer_id",
            "in": "query",
            "required": true,
            "x-example-override": "6499023882596562732",
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Includes previous addresses for the customer. A previous address has an end_timestamp which is in the past. Optional; defaults to false.",
            "name": "include_previous",
            "in": "query",
            "required": false,
            "x-example-override": "true",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "The number of addresses to be retrieved.\n\nRequired.\nMin value: 1.\nMax value: 1000.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "x-example-override": "10",
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "Token of the page the results are to be retrieved from. If empty, returns the first page of results. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "x-example-override": "MjAw",
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPICustomers"
        ],
        "x-section": "Customers",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.customer_addresses:read"
        ]
      },
      "post": {
        "summary": "Creates a customer address.",
        "operationId": "CreateCustomerAddress",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/customersCustomerAddress"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPICustomers"
        ],
        "x-section": "Customers",
        "x-permission-scopes": [
          "core:write",
          "core.customer_addresses:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/customersCreateCustomerAddressRequest"
        }
      }
    },
    "/v1/customer-addresses/{customer_address.id}": {
      "put": {
        "summary": "Updates a customer address.",
        "operationId": "UpdateCustomerAddress",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/customersCustomerAddress"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The address ID. Output only.",
            "name": "customer_address.id",
            "in": "path",
            "required": true,
            "x-example-override": "8c926ef4-f09c-4db0-9b58-57030e4547c0",
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPICustomers"
        ],
        "x-section": "Customers",
        "x-permission-scopes": [
          "core:write",
          "core.customer_addresses:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/customersUpdateCustomerAddressRequest"
        }
      }
    },
    "/v1/customers": {
      "get": {
        "summary": "Lists customers with pagination.",
        "operationId": "ListCustomers",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/customersListCustomersResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "List of inclusive OR customer status filters. Optional.",
            "name": "statuses",
            "in": "query",
            "required": false,
            "x-enum-value-descriptions": {
              "CUSTOMER_STATUS_ACTIVE": "The customer status is active. To open an account, the customer status must be active; accounts cannot be opened for a customer with any other customer status. The status of an active customer could change to either frozen or deceased but cannot change to prospect.",
              "CUSTOMER_STATUS_DECEASED": "The customer status is deceased. Accounts cannot be opened for the customer but may still be active. The status of a deceased customer could change to either active or frozen but cannot change to prospect.",
              "CUSTOMER_STATUS_FROZEN": "The customer status is frozen. Accounts cannot be opened for the customer. The status of a frozen customer could change to either active or deceased but cannot change to prospect.",
              "CUSTOMER_STATUS_PROSPECT": "The customer status is not yet active. Accounts cannot be opened. The status of a prospect customer can only change to active. Once the status has changed from prospect, it cannot be changed back to prospect.",
              "CUSTOMER_STATUS_UNKNOWN": "The customer status is unknown."
            },
            "x-example-override": "[\"CUSTOMER_STATUS_ACTIVE\", \"CUSTOMER_STATUS_PROSPECT\"]",
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "CUSTOMER_STATUS_UNKNOWN",
                  "CUSTOMER_STATUS_ACTIVE",
                  "CUSTOMER_STATUS_FROZEN",
                  "CUSTOMER_STATUS_DECEASED",
                  "CUSTOMER_STATUS_PROSPECT"
                ]
              }
            }
          },
          {
            "description": "List of inclusive OR email identifier filters. Must be URL encoded. Optional.",
            "name": "email_identifiers",
            "in": "query",
            "required": false,
            "x-example-override": "[\"api_user@domain.com\"]",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "List of inclusive OR phone number identifier filters. Must be URL encoded. Optional.",
            "name": "phone_identifiers",
            "in": "query",
            "required": false,
            "x-example-override": "[\"+447700900796\"]",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "List of inclusive OR username identifier filters. Must be URL encoded. Optional.",
            "name": "username_identifiers",
            "in": "query",
            "required": false,
            "x-release-info": {
              "releaseVersion": {
                "major": 1,
                "minor": 8
              },
              "changeType": "ADD_FIELD",
              "description": "Adds a username filter for list customers"
            },
            "x-example-override": "[\"api_user\", \"another_api_user\"]",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "Number of customers to be listed.\n\nRequired.\nMin value: 1.\nMax value: 200.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "x-example-override": "10",
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "Token of the page the results are to retrieved from. If empty, returns the first page of results. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "x-example-override": "MjI2NDEwMDM4OTg2MTU3NTI4OCFDNjQ5ODk4NDA1ODYwOTA3MDM4NQ",
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPICustomers"
        ],
        "x-section": "Customers",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.customers:read"
        ]
      },
      "post": {
        "summary": "Creates a new customer.",
        "operationId": "CreateCustomer",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/customersCustomer"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPICustomers"
        ],
        "x-section": "Customers",
        "x-permission-scopes": [
          "core:write",
          "core.customers:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/customersCreateCustomerRequest"
        }
      }
    },
    "/v1/customers/{customer.id}": {
      "put": {
        "summary": "Used to update a customer's status and identifiers.",
        "operationId": "UpdateCustomer",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/customersCustomer"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The unique ID of the customer. Defaults to a generated string ID if not provided.",
            "name": "customer.id",
            "in": "path",
            "required": true,
            "x-example-override": "86d86f07-7ba6-466e-9f41-f72c24e9b13b",
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPICustomers"
        ],
        "x-section": "Customers",
        "x-permission-scopes": [
          "core:write",
          "core.customers:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/customersUpdateCustomerRequest"
        }
      }
    },
    "/v1/customers/{customer_id}:updateAdditionalDetails": {
      "put": {
        "summary": "Updates additional details for a customer.",
        "operationId": "UpdateCustomerAdditionalDetails",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/customersCustomer"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The unique ID of the customer.",
            "name": "customer_id",
            "in": "path",
            "required": true,
            "x-example-override": "6499023882596562732",
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPICustomers"
        ],
        "x-section": "Customers",
        "x-permission-scopes": [
          "core:write",
          "core.customers:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/customersUpdateCustomerAdditionalDetailsRequest"
        }
      }
    },
    "/v1/customers/{id}": {
      "get": {
        "summary": "Retrieves a customer.",
        "operationId": "GetCustomer",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/customersCustomer"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The unique ID of the customer.",
            "name": "id",
            "in": "path",
            "required": true,
            "x-example-override": "6499023882596562732",
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPICustomers"
        ],
        "x-section": "Customers",
        "x-permission-scopes": [
          "core:read",
          "core.customers:read"
        ]
      }
    },
    "/v1/customers:batchGet": {
      "get": {
        "summary": "Retrieves customers for the customer IDs provided.",
        "operationId": "BatchGetCustomers",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/customersBatchGetCustomersResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A list of the IDs of customers that are to be retrieved.\n\nRequired.\nMin length: 1 characters.",
            "name": "ids",
            "in": "query",
            "required": true,
            "x-example-override": "[\"6499023882596562732\", \"496755199759406183\"]",
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPICustomers"
        ],
        "x-section": "Customers",
        "x-permission-scopes": [
          "core:read",
          "core.customers:read"
        ]
      }
    },
    "/v1/journal-events": {
      "get": {
        "summary": "Retrieves journal events",
        "operationId": "ListJournalEvents",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/eventsListJournalEventsResponse"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "501": {
            "description": "The error response for 501",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPIJournalEventsUNIMPLEMENTED_0",
                  "description": "The service is not implemented",
                  "title": "UNIMPLEMENTED"
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "schema": {
              "$ref": "#/components/schemas/eventsTimeWindow",
              "description": "Interval of time to query for."
            },
            "name": "time_window",
            "in": "query",
            "required": false
          },
          {
            "description": "The type of the Vault resource.",
            "name": "resource_type",
            "in": "query",
            "required": false,
            "x-enum-value-release-info": {
              "RESOURCE_TYPE_ACCOUNT_V2": {
                "releaseVersion": {
                  "major": 5
                },
                "changeType": "ADD_FIELD",
                "featureFlag": "CPP_1430_ACCOUNTS_V2"
              },
              "RESOURCE_TYPE_FLAG": {
                "releaseVersion": {
                  "major": 4,
                  "minor": 6
                },
                "changeType": "ADD_FIELD",
                "featureFlag": "TM_77174_FLAG_EVENT_RECONCILIATION"
              },
              "RESOURCE_TYPE_RESTRICTION_SET": {
                "releaseVersion": {
                  "major": 4,
                  "minor": 6
                },
                "changeType": "ADD_FIELD",
                "featureFlag": "TM_77183_RESTRICTION_SET_RECONCILIATION"
              }
            },
            "x-enum-value-descriptions": {
              "RESOURCE_TYPE_ACCOUNT": "Core API v1 Account.",
              "RESOURCE_TYPE_ACCOUNT_BALANCE": "Balance from Balances API.",
              "RESOURCE_TYPE_ACCOUNT_UPDATE": "Account Update from Account API.",
              "RESOURCE_TYPE_ACCOUNT_UPDATE_BATCH": "Account Update Batch from Account Processor (Accounts Service).",
              "RESOURCE_TYPE_ACCOUNT_V2": "Core API v2 Account.",
              "RESOURCE_TYPE_ENRICHED_POSTING_INSTRUCTION_BATCH": "Enriched Posting Instruction Batch from Postings API.",
              "RESOURCE_TYPE_POSTING_INSTRUCTION_BATCH": "Posting Instruction Batch from Postings API.",
              "RESOURCE_TYPE_RESTRICTION_SET": "Restriction Set from Restriction API.",
              "RESOURCE_TYPE_SCHEDULER_OPERATION": "Scheduler Operation from Scheduler API."
            },
            "schema": {
              "type": "string",
              "enum": [
                "RESOURCE_TYPE_UNKNOWN",
                "RESOURCE_TYPE_SCHEDULER_OPERATION",
                "RESOURCE_TYPE_ACCOUNT_BALANCE",
                "RESOURCE_TYPE_ENRICHED_POSTING_INSTRUCTION_BATCH",
                "RESOURCE_TYPE_POSTING_INSTRUCTION_BATCH",
                "RESOURCE_TYPE_ACCOUNT",
                "RESOURCE_TYPE_ACCOUNT_UPDATE",
                "RESOURCE_TYPE_ACCOUNT_UPDATE_BATCH",
                "RESOURCE_TYPE_ACCOUNT_V2",
                "RESOURCE_TYPE_RESTRICTION_SET",
                "RESOURCE_TYPE_FLAG"
              ],
              "default": "RESOURCE_TYPE_UNKNOWN"
            }
          },
          {
            "description": "Number of results to be retrieved. Required; must be non-zero.\n\nRequired.\nMin value: 1.\nMax value: 100.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "Token of the page the results are to be retrieved from. If empty, returns the first page of results. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIJournalEvents"
        ],
        "x-section": "Journal Events",
        "x-release-info": {
          "releaseVersion": {
            "major": 4,
            "minor": 2
          },
          "changeType": "ADD_METHOD",
          "featureFlag": "TM_69163_LIST_EVENTS"
        },
        "x-permission-scopes": [
          "core:read",
          "core.journal_events:read"
        ]
      }
    },
    "/v1/journal-events:checksum": {
      "get": {
        "summary": "Retrieves the journal events count and checksum for the specified window.",
        "operationId": "GetJournalEventsChecksum",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/eventsGetJournalEventsChecksumResponse"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "501": {
            "description": "The error response for 501",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPIJournalEventsUNIMPLEMENTED_0",
                  "description": "The service is not implemented",
                  "title": "UNIMPLEMENTED"
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "schema": {
              "$ref": "#/components/schemas/eventsTimeWindow",
              "description": "Interval of time to query for."
            },
            "name": "time_window",
            "in": "query",
            "required": false
          },
          {
            "description": "The type of the Vault resource.",
            "name": "resource_type",
            "in": "query",
            "required": false,
            "x-enum-value-release-info": {
              "RESOURCE_TYPE_ACCOUNT_V2": {
                "releaseVersion": {
                  "major": 5
                },
                "changeType": "ADD_FIELD",
                "featureFlag": "CPP_1430_ACCOUNTS_V2"
              },
              "RESOURCE_TYPE_FLAG": {
                "releaseVersion": {
                  "major": 4,
                  "minor": 6
                },
                "changeType": "ADD_FIELD",
                "featureFlag": "TM_77174_FLAG_EVENT_RECONCILIATION"
              },
              "RESOURCE_TYPE_RESTRICTION_SET": {
                "releaseVersion": {
                  "major": 4,
                  "minor": 6
                },
                "changeType": "ADD_FIELD",
                "featureFlag": "TM_77183_RESTRICTION_SET_RECONCILIATION"
              }
            },
            "x-enum-value-descriptions": {
              "RESOURCE_TYPE_ACCOUNT": "Core API v1 Account.",
              "RESOURCE_TYPE_ACCOUNT_BALANCE": "Balance from Balances API.",
              "RESOURCE_TYPE_ACCOUNT_UPDATE": "Account Update from Account API.",
              "RESOURCE_TYPE_ACCOUNT_UPDATE_BATCH": "Account Update Batch from Account Processor (Accounts Service).",
              "RESOURCE_TYPE_ACCOUNT_V2": "Core API v2 Account.",
              "RESOURCE_TYPE_ENRICHED_POSTING_INSTRUCTION_BATCH": "Enriched Posting Instruction Batch from Postings API.",
              "RESOURCE_TYPE_POSTING_INSTRUCTION_BATCH": "Posting Instruction Batch from Postings API.",
              "RESOURCE_TYPE_RESTRICTION_SET": "Restriction Set from Restriction API.",
              "RESOURCE_TYPE_SCHEDULER_OPERATION": "Scheduler Operation from Scheduler API."
            },
            "schema": {
              "type": "string",
              "enum": [
                "RESOURCE_TYPE_UNKNOWN",
                "RESOURCE_TYPE_SCHEDULER_OPERATION",
                "RESOURCE_TYPE_ACCOUNT_BALANCE",
                "RESOURCE_TYPE_ENRICHED_POSTING_INSTRUCTION_BATCH",
                "RESOURCE_TYPE_POSTING_INSTRUCTION_BATCH",
                "RESOURCE_TYPE_ACCOUNT",
                "RESOURCE_TYPE_ACCOUNT_UPDATE",
                "RESOURCE_TYPE_ACCOUNT_UPDATE_BATCH",
                "RESOURCE_TYPE_ACCOUNT_V2",
                "RESOURCE_TYPE_RESTRICTION_SET",
                "RESOURCE_TYPE_FLAG"
              ],
              "default": "RESOURCE_TYPE_UNKNOWN"
            }
          }
        ],
        "tags": [
          "CoreAPIJournalEvents"
        ],
        "x-section": "Journal Events",
        "x-release-info": {
          "releaseVersion": {
            "major": 4,
            "minor": 2
          },
          "changeType": "ADD_METHOD",
          "featureFlag": "TM_69163_LIST_EVENTS"
        },
        "x-permission-scopes": [
          "core:read",
          "core.journal_events:read"
        ]
      }
    },
    "/v1/journal-events:replay": {
      "post": {
        "summary": "Replays the events specified by id in the request (max batch size = 100)",
        "operationId": "ReplayJournalEvents",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/eventsReplayJournalEventsResponse"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "501": {
            "description": "The error response for 501",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPIJournalEventsUNIMPLEMENTED_0",
                  "description": "The service is not implemented",
                  "title": "UNIMPLEMENTED"
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIJournalEvents"
        ],
        "x-section": "Journal Events",
        "x-release-info": {
          "releaseVersion": {
            "major": 4,
            "minor": 2
          },
          "changeType": "ADD_METHOD",
          "featureFlag": "TM_69164_REPLAY_EVENTS"
        },
        "x-permission-scopes": [
          "core:execute",
          "core.journal_events:execute"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/eventsReplayJournalEventsRequest"
        }
      }
    },
    "/v1/flag-definitions": {
      "get": {
        "summary": "Retrieves flag definitions that correspond to the parameters supplied.",
        "operationId": "ListFlagDefinitions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/flagsListFlagDefinitionsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The flag visibility level that flag definitions are to be returned for. Set this to FLAG_VISIBILITY_OPERATOR to return flag definitions with flag visibility=FLAG_VISIBILITY_OPERATOR. Set this to FLAG_VISIBILITY_CONTRACT to return all flag definitions. Optional.",
            "name": "flag_visibility_level",
            "in": "query",
            "required": false,
            "x-enum-value-descriptions": {
              "FLAG_VISIBILITY_CONTRACT": "The flag is visible only to Smart Contracts.",
              "FLAG_VISIBILITY_OPERATOR": "The flag is visible to UI operators and Smart Contracts.",
              "FLAG_VISIBILITY_UNKNOWN": "Used where the flag visibility is unknown."
            },
            "schema": {
              "type": "string",
              "enum": [
                "FLAG_VISIBILITY_UNKNOWN",
                "FLAG_VISIBILITY_CONTRACT",
                "FLAG_VISIBILITY_OPERATOR"
              ],
              "default": "FLAG_VISIBILITY_UNKNOWN"
            }
          },
          {
            "description": "The flag levels in the flag definition. If unspecified, this is equivalent to all flag levels. Optional.",
            "name": "flag_levels",
            "in": "query",
            "required": false,
            "x-enum-value-descriptions": {
              "FLAG_LEVEL_ACCOUNT": "Makes a flag apply to the account ID.",
              "FLAG_LEVEL_CUSTOMER": "Makes a flag apply to the customer ID.",
              "FLAG_LEVEL_PAYMENT_DEVICE": "Makes a flag apply to the payment device ID.",
              "FLAG_LEVEL_UNKNOWN": "Used where the flag level is unknown."
            },
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "FLAG_LEVEL_UNKNOWN",
                  "FLAG_LEVEL_CUSTOMER",
                  "FLAG_LEVEL_ACCOUNT",
                  "FLAG_LEVEL_PAYMENT_DEVICE"
                ]
              }
            }
          },
          {
            "description": "Indicates whether inactive flag definitions are included. Optional.",
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "Number of results to be retrieved. Required; must be non-zero. The 5.0 release will reduce the maximum page size to 100.\n\nRequired.\nMin value: 1.\nMax value: 1000.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "Token of the page the results are to be retrieved from. If empty, returns the first page of results. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIFlags"
        ],
        "x-section": "Flags",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.flag_definitions:read"
        ]
      },
      "post": {
        "summary": "Creates a flag definition.",
        "operationId": "CreateFlagDefinition",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/flagsFlagDefinition"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIFlags"
        ],
        "x-section": "Flags",
        "x-permission-scopes": [
          "core:write",
          "core.flag_definitions:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/flagsCreateFlagDefinitionRequest"
        }
      }
    },
    "/v1/flag-definitions/{flag_definition.id}": {
      "put": {
        "summary": "Updates a flag definition.",
        "operationId": "UpdateFlagDefinition",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/flagsFlagDefinition"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The ID of the flag definition. Must equal the flag definition name when creating a flag definition. Required for create requests.",
            "name": "flag_definition.id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIFlags"
        ],
        "x-section": "Flags",
        "x-permission-scopes": [
          "core:write",
          "core.flag_definitions:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/flagsUpdateFlagDefinitionRequest"
        }
      }
    },
    "/v1/flag-definitions:batchGet": {
      "get": {
        "summary": "Retrieves flag definitions that correspond to the requested flag definition IDs.",
        "operationId": "BatchGetFlagDefinitions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/flagsBatchGetFlagDefinitionsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The flag definition IDs or names to be retrieved. The 5.0 release will enforce a maximum number of IDs of 50.",
            "name": "ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIFlags"
        ],
        "x-section": "Flags",
        "x-permission-scopes": [
          "core:read",
          "core.flag_definitions:read"
        ]
      }
    },
    "/v1/flags": {
      "get": {
        "summary": "Retrieves flags that correspond to the parameters supplied.",
        "operationId": "ListFlags",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/flagsListFlagsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The flag definition ID that returned flags should correspond to. Optional.",
            "name": "flag_definition_id",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The IDs of customers the applied flags should be included for. Optional.",
            "name": "customer_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "The IDs of accounts the applied flags should be included for. Optional.",
            "name": "account_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "The IDs of payment devices the applied flags should be included for. Optional.",
            "name": "payment_device_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "The flag visibility level that flags are to be returned for. Set this to FLAG_VISIBILITY_OPERATOR to return only flags belonging to a flag_definition with a flag_visibility=FLAG_VISIBILITY_OPERATOR. Set this to FLAG_VISIBILITY_CONTRACT to return all flags. Optional.",
            "name": "flag_visibility_level",
            "in": "query",
            "required": false,
            "x-enum-value-descriptions": {
              "FLAG_VISIBILITY_CONTRACT": "The flag is visible only to Smart Contracts.",
              "FLAG_VISIBILITY_OPERATOR": "The flag is visible to UI operators and Smart Contracts.",
              "FLAG_VISIBILITY_UNKNOWN": "Used where the flag visibility is unknown."
            },
            "schema": {
              "type": "string",
              "enum": [
                "FLAG_VISIBILITY_UNKNOWN",
                "FLAG_VISIBILITY_CONTRACT",
                "FLAG_VISIBILITY_OPERATOR"
              ],
              "default": "FLAG_VISIBILITY_UNKNOWN"
            }
          },
          {
            "description": "Timestamp after which the flag will be effective. Cannot be used in conjunction with effective_timestamp_range. Optional.",
            "name": "effective_timestamp",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "description": "Indicates whether inactive flag definitions are included. Optional.",
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "The number of results to be retrieved. Required; must be non-zero and less than 3000. The 5.0 release will reduce the maximum page size to 100.\n\nRequired.\nMin value: 1.\nMax value: 3000.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "Token of the page the results are to be retrieved from. If empty, returns the first page of results. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "schema": {
              "type": "string"
            },
            "name": "effective_timestamp_range.from",
            "in": "query",
            "required": false,
            "description": "The timestamp range that must overlap with the period of time when a flag becomes effective and expires if the flag is to be included; if the range and period of time do not overlap, the flag will not be included. This range is from effective_timestamp_range.from up to and not including effective_timestamp_range.to. Optional. This is an auto generated field to make the swagger compatible with the third party codegen tool."
          },
          {
            "schema": {
              "type": "string"
            },
            "name": "effective_timestamp_range.to",
            "in": "query",
            "required": false,
            "description": "The timestamp range that must overlap with the period of time when a flag becomes effective and expires if the flag is to be included; if the range and period of time do not overlap, the flag will not be included. This range is from effective_timestamp_range.from up to and not including effective_timestamp_range.to. Optional. This is an auto generated field to make the swagger compatible with the third party codegen tool."
          }
        ],
        "tags": [
          "CoreAPIFlags"
        ],
        "x-section": "Flags",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.flags:read"
        ]
      },
      "post": {
        "summary": "Creates a flag.",
        "operationId": "CreateFlag",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/flagsFlag"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIFlags"
        ],
        "x-section": "Flags",
        "x-permission-scopes": [
          "core:write",
          "core.flags:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/flagsCreateFlagRequest"
        }
      }
    },
    "/v1/flags/{flag.id}": {
      "put": {
        "summary": "Updates a flag.",
        "operationId": "UpdateFlag",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/flagsFlag"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The ID of the flag. Output only.",
            "name": "flag.id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIFlags"
        ],
        "x-section": "Flags",
        "x-permission-scopes": [
          "core:write",
          "core.flags:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/flagsUpdateFlagRequest"
        }
      }
    },
    "/v1/flags:batchGet": {
      "get": {
        "summary": "Retrieves flags that correspond to the requested flag IDs.",
        "operationId": "BatchGetFlags",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/flagsBatchGetFlagsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The flag definition IDs or names to be retrieved. The maximum number of IDs is 50.\n\nRequired.\nMax count: 50.",
            "name": "ids",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIFlags"
        ],
        "x-section": "Flags",
        "x-release-info": {
          "releaseVersion": {
            "major": 4,
            "minor": 4
          },
          "changeType": "ADD_METHOD",
          "featureFlag": "TM_72051_BATCH_GET_FLAGS"
        },
        "x-permission-scopes": [
          "core:read",
          "core.flags:read"
        ]
      }
    },
    "/v1/global-parameter-values": {
      "get": {
        "summary": "Lists `GlobalParameterValue`s for a given `GlobalParameter` ID and an optional time range with pagination.",
        "operationId": "ListGlobalParameterValues",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/global_parametersListGlobalParameterValuesResponse"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The `GlobalParameter` ID to retrieve values for.\n\nRequired.",
            "name": "global_parameter_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The number of `GlobalParametersValues` to be retrieved.\n\nRequired.\nMin value: 1.\nMax value: 100.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "The token of the page the results are to be retrieved from. If empty, this returns the first page of results.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "schema": {
              "type": "string"
            },
            "name": "effective_timestamp_range.from",
            "in": "query",
            "required": false,
            "description": "Optional time range. If provided, only `GlobalParameterValue`s that have the appropriate `effective_timestamp` will be retrieved. If the `effective_timestamp_range.from` attribute is not provided, it defaults to the minimum timestamp. If `effective_timestamp_range.to` is not provided, it defaults to the maximum timestamp. This is an auto generated field to make the swagger compatible with the third party codegen tool."
          },
          {
            "schema": {
              "type": "string"
            },
            "name": "effective_timestamp_range.to",
            "in": "query",
            "required": false,
            "description": "Optional time range. If provided, only `GlobalParameterValue`s that have the appropriate `effective_timestamp` will be retrieved. If the `effective_timestamp_range.from` attribute is not provided, it defaults to the minimum timestamp. If `effective_timestamp_range.to` is not provided, it defaults to the maximum timestamp. This is an auto generated field to make the swagger compatible with the third party codegen tool."
          }
        ],
        "tags": [
          "CoreAPIGlobalParameters"
        ],
        "x-section": "Global parameters",
        "x-release-info": {
          "releaseVersion": {
            "major": 1,
            "minor": 7
          },
          "changeType": "ADD_METHOD"
        },
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.global_parameter_values:read"
        ]
      },
      "post": {
        "summary": "Creates a new `GlobalParameterValue`.",
        "operationId": "CreateGlobalParameterValue",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/global_parametersGlobalParameterValue"
                }
              }
            }
          },
          "400": {
            "description": "The error response for 400",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CreateGlobalParameterValueFAILED_PRECONDITION_0",
                  "description": "Returned when attempting to create a GlobalParameterValue which overlaps with a ParameterValue with an explicitly set effective_timestamp range. This can only be rectified by unsetting the ParameterValue's effective_to_timestamp if possible.",
                  "title": "FAILED_PRECONDITION",
                  "x-release-info": {
                    "releaseVersion": {
                      "major": 5
                    },
                    "changeType": "ADD_ERROR",
                    "featureFlag": "CPP_1430_ACCOUNTS_V2"
                  }
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIGlobalParameters"
        ],
        "x-section": "Global parameters",
        "x-release-info": {
          "releaseVersion": {
            "major": 1,
            "minor": 7
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:write",
          "core.global_parameter_values:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/global_parametersCreateGlobalParameterValueRequest"
        }
      }
    },
    "/v1/global-parameters": {
      "get": {
        "summary": "Lists `GlobalParameters` with pagination.",
        "operationId": "ListGlobalParameters",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/global_parametersListGlobalParametersResponse"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The number of `GlobalParameter`s to be retrieved.\n\nRequired.\nMin value: 1.\nMax value: 100.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "The token of the page the results are to be retrieved from. If empty, this returns the first page of results.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIGlobalParameters"
        ],
        "x-section": "Global parameters",
        "x-release-info": {
          "releaseVersion": {
            "major": 1,
            "minor": 7
          },
          "changeType": "ADD_METHOD"
        },
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.global_parameters:read"
        ]
      },
      "post": {
        "summary": "Creates a new `GlobalParameter`. It also creates a new `GlobalParameterValue` which will have the value specified in the request, and the effective timestamp of the Unix epoch.",
        "operationId": "CreateGlobalParameter",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/global_parametersGlobalParameter"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIGlobalParameters"
        ],
        "x-section": "Global parameters",
        "x-release-info": {
          "releaseVersion": {
            "major": 1,
            "minor": 7
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:write",
          "core.global_parameters:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/global_parametersCreateGlobalParameterRequest"
        }
      }
    },
    "/v1/global-parameters/{id}": {
      "get": {
        "summary": "Retrieves a `GlobalParameter`.",
        "operationId": "GetGlobalParameter",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/global_parametersGlobalParameter"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The ID of the `GlobalParameter` to be retrieved.",
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIGlobalParameters"
        ],
        "x-section": "Global parameters",
        "x-release-info": {
          "releaseVersion": {
            "major": 1,
            "minor": 7
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:read",
          "core.global_parameters:read"
        ]
      }
    },
    "/v1/global-parameters:batchGet": {
      "get": {
        "summary": "Retrieves `GlobalParameter`s for the provided IDs.",
        "operationId": "BatchGetGlobalParameters",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/global_parametersBatchGetGlobalParametersResponse"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A list of IDs of `GlobalParameter`s to be retrieved.",
            "name": "ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIGlobalParameters"
        ],
        "x-section": "Global parameters",
        "x-release-info": {
          "releaseVersion": {
            "major": 1,
            "minor": 7
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:read",
          "core.global_parameters:read"
        ]
      }
    },
    "/v1/internal-accounts": {
      "get": {
        "summary": "Lists all internal accounts that match the criteria used.",
        "operationId": "ListInternalAccounts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/internal_accountsListInternalAccountsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The view of the data to return. Optional; default ACCOUNT_VIEW_BASIC.",
            "name": "view",
            "in": "query",
            "required": false,
            "x-enum-value-descriptions": {
              "ACCOUNT_VIEW_BASIC": "Returned Account(s) include no balances. Default."
            },
            "schema": {
              "type": "string",
              "enum": [
                "ACCOUNT_VIEW_BASIC"
              ],
              "default": "ACCOUNT_VIEW_BASIC"
            }
          },
          {
            "description": "The number of results to be listed. Required; must be non-zero and no greater than 1000. The 5.0 release will reduce the maximum page size to 100.\n\nRequired.\nMin value: 1.\nMax value: 1000.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "Token of the page the results are to be retrieved from. If empty, returns the first page of results. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIInternalAccounts"
        ],
        "x-section": "Internal accounts",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.internal_accounts:read"
        ]
      },
      "post": {
        "summary": "Creates an internal account.",
        "operationId": "CreateInternalAccount",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/internal_accountsInternalAccount"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIInternalAccounts"
        ],
        "x-section": "Internal accounts",
        "x-permission-scopes": [
          "core:write",
          "core.internal_accounts:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/internal_accountsCreateInternalAccountRequest"
        }
      }
    },
    "/v1/internal-accounts/{id}": {
      "get": {
        "summary": "Retrieves a specified internal account.",
        "operationId": "GetInternalAccount",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/internal_accountsInternalAccount"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The ID of the internal account that is to be retrieved. Required.",
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "View of the data to return. Optional; default ACCOUNT_VIEW_BASIC.",
            "name": "view",
            "in": "query",
            "required": false,
            "x-enum-value-descriptions": {
              "ACCOUNT_VIEW_BASIC": "Returned Account(s) include no balances. Default."
            },
            "schema": {
              "type": "string",
              "enum": [
                "ACCOUNT_VIEW_BASIC"
              ],
              "default": "ACCOUNT_VIEW_BASIC"
            }
          }
        ],
        "tags": [
          "CoreAPIInternalAccounts"
        ],
        "x-section": "Internal accounts",
        "x-permission-scopes": [
          "core:read",
          "core.internal_accounts:read"
        ]
      }
    },
    "/v1/internal-accounts:batchGet": {
      "get": {
        "summary": "Retrieves one or more internal accounts based on their IDs.",
        "operationId": "BatchGetInternalAccounts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/internal_accountsBatchGetInternalAccountsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A list of the IDs of internal accounts to be retrieved. Required; must be non-empty. The 5.0 release will enforce a maximum number of IDs of 50.\n\nRequired.\nMin count: 1.",
            "name": "ids",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "View of the data to return. Optional; default ACCOUNT_VIEW_BASIC.",
            "name": "view",
            "in": "query",
            "required": false,
            "x-enum-value-descriptions": {
              "ACCOUNT_VIEW_BASIC": "Returned Account(s) include no balances. Default."
            },
            "schema": {
              "type": "string",
              "enum": [
                "ACCOUNT_VIEW_BASIC"
              ],
              "default": "ACCOUNT_VIEW_BASIC"
            }
          }
        ],
        "tags": [
          "CoreAPIInternalAccounts"
        ],
        "x-section": "Internal accounts",
        "x-permission-scopes": [
          "core:read",
          "core.internal_accounts:read"
        ]
      }
    },
    "/v1/ledger-balances": {
      "get": {
        "summary": "Lists Ledger Balances for the supplied account IDs at a specified timestamp. The timestamp refers to the Postings Ledger insertion time, thus a Ledger Balance is the sum of all postings up to that Postings Ledger insertion timestamp.",
        "operationId": "ListLedgerBalances",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ledger_balancesListLedgerBalancesResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The IDs of the accounts that Ledger Balances are to be listed for. Required.",
            "name": "account_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "The Postings Ledger timestamp at which to retrieve Ledger Balances. Required.\n\nRequired.",
            "name": "ledger_timestamp",
            "in": "query",
            "required": true,
            "x-example-override": "2020-01-13T19:13:23.000Z",
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "description": "The number of results to be retrieved. Required. Validated in the ledger balance service.",
            "name": "page_size",
            "in": "query",
            "required": false,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "The token of the page the results are to be retrieved from. If empty, the first page of results will be returned. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPILedgerBalances"
        ],
        "x-section": "LedgerBalances",
        "x-list-consistency-level": "SNAPSHOT",
        "x-permission-scopes": [
          "core:read",
          "core.ledger_balances:read"
        ]
      }
    },
    "/v1/ledger-balances/{id}": {
      "get": {
        "summary": "Retrieves a Ledger Balance by ID.",
        "operationId": "GetLedgerBalance",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/ledger_balancesLedgerBalance"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The ID of the Ledger Balance to be retrieved. Required.",
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPILedgerBalances"
        ],
        "x-section": "LedgerBalances",
        "x-permission-scopes": [
          "core:read",
          "core.ledger_balances:read"
        ]
      }
    },
    "/v1/payment-device-links": {
      "get": {
        "summary": "Lists the payment device links that match the provided criteria. Must provide at least one token, payment device ID or account ID.",
        "operationId": "ListPaymentDeviceLinks",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/payment_devicesListPaymentDeviceLinksResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "List of payment device link tokens.",
            "name": "tokens",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "List of payment device IDs.",
            "name": "payment_device_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "List of account IDs.",
            "name": "account_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "Maximum start timestamp of listed links. Optional. Defaults to current time.\n",
            "name": "effective_timestamp",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "description": "Indicates whether to include inactive payment device links in the response.",
            "name": "include_inactive",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "tags": [
          "CoreAPIPaymentDevices"
        ],
        "x-section": "Payment devices",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.payment_device_links:read"
        ]
      },
      "post": {
        "summary": "Creates a payment-device-link linking a payment device to the account. The payment device that is being linked to must have a status of PAYMENT_DEVICE_STATUS_ACTIVE or PAYMENT_DEVICE_STATUS_PENDING for the request to succeed.",
        "operationId": "CreatePaymentDeviceLink",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/payment_devicesPaymentDeviceLink"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIPaymentDevices"
        ],
        "x-section": "Payment devices",
        "x-permission-scopes": [
          "core:write",
          "core.payment_device_links:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/payment_devicesCreatePaymentDeviceLinkRequest"
        }
      }
    },
    "/v1/payment-device-links/{payment_device_link.id}": {
      "put": {
        "summary": "Updates an existing payment device link.",
        "operationId": "UpdatePaymentDeviceLink",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/payment_devicesPaymentDeviceLink"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A caller-injected or Vault auto-generated unique ID for the payment device link. When auto-generated, this is a UUID in the canonical 8-4-4-4-12 form.",
            "name": "payment_device_link.id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIPaymentDevices"
        ],
        "x-section": "Payment devices",
        "x-permission-scopes": [
          "core:write",
          "core.payment_device_links:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/payment_devicesUpdatePaymentDeviceLinkRequest"
        }
      }
    },
    "/v1/payment-device-links:batchGet": {
      "get": {
        "summary": "Returns the payment device links for the provided IDs.",
        "operationId": "BatchGetPaymentDeviceLinks",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/payment_devicesBatchGetPaymentDeviceLinksResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "List of IDs of payment device links to fetch. Required; must be non-empty. The 5.0 release will enforce a maximum number of IDs of 50.",
            "name": "ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIPaymentDevices"
        ],
        "x-section": "Payment devices",
        "x-release-info": {
          "releaseVersion": {
            "major": 3
          },
          "changeType": "ADD_METHOD",
          "featureFlag": "TMV_E_286_ADD_BATCH_GET_PAYMENT_DEVICE_LINKS"
        },
        "x-permission-scopes": [
          "core:read",
          "core.payment_device_links:read"
        ]
      }
    },
    "/v1/payment-devices": {
      "post": {
        "summary": "Creates a new payment device.",
        "operationId": "CreatePaymentDevice",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/payment_devicesPaymentDevice"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIPaymentDevices"
        ],
        "x-section": "Payment devices",
        "x-permission-scopes": [
          "core:write",
          "core.payment_devices:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/payment_devicesCreatePaymentDeviceRequest"
        }
      }
    },
    "/v1/payment-devices/{payment_device.id}": {
      "put": {
        "summary": "Updates an existing payment device.",
        "operationId": "UpdatePaymentDevice",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/payment_devicesPaymentDevice"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "Caller injected or Vault auto-generated unique ID for payment device. Optional. When auto-generated, this is a UUID in the canonical 8-4-4-4-12 form.",
            "name": "payment_device.id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIPaymentDevices"
        ],
        "x-section": "Payment devices",
        "x-permission-scopes": [
          "core:write",
          "core.payment_devices:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/payment_devicesUpdatePaymentDeviceRequest"
        }
      }
    },
    "/v1/payment-devices:batchGet": {
      "get": {
        "summary": "Returns the payment devices for the provided IDs.",
        "operationId": "BatchGetPaymentDevices",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/payment_devicesBatchGetPaymentDevicesResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "List of IDs of payment devices to fetch. Required; must be non-empty. The 5.0 release will enforce a maximum number of IDs of 50.",
            "name": "ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIPaymentDevices"
        ],
        "x-section": "Payment devices",
        "x-permission-scopes": [
          "core:read",
          "core.payment_devices:read"
        ]
      }
    },
    "/v1/payment-orders": {
      "get": {
        "summary": "Lists and filters PaymentOrder objects. Results are returned ordered by descending create timestamp (most recent first).",
        "operationId": "ListPaymentOrders",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/payment_ordersListPaymentOrdersResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The PaymentOrderTypes to filter the PaymentOrder on. Optional.",
            "name": "types",
            "in": "query",
            "required": false,
            "x-enum-value-descriptions": {
              "PAYMENT_ORDER_TYPE_FUTURE_DATED": "Indicates a single payment executed in the future.",
              "PAYMENT_ORDER_TYPE_RECURRING": "Indicates a recurring payment.",
              "PAYMENT_ORDER_TYPE_UNKNOWN": "Default value."
            },
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "PAYMENT_ORDER_TYPE_UNKNOWN",
                  "PAYMENT_ORDER_TYPE_FUTURE_DATED",
                  "PAYMENT_ORDER_TYPE_RECURRING"
                ]
              }
            }
          },
          {
            "description": "The internal Vault accounts to filter the PaymentOrder on. Optional.",
            "name": "debtor_account_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "The number of results to be listed. Required; must be non-zero. Maximum value of 100.\n\nRequired.\nMin value: 1.\nMax value: 100.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "Token of the page the results are to be retrieved from. If empty, returns the first page of results. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIPaymentOrderScheduler"
        ],
        "x-section": "Payment orders",
        "x-release-info": {
          "releaseVersion": {
            "major": 1,
            "minor": 8
          },
          "changeType": "ADD_METHOD"
        },
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.payment_orders:read"
        ]
      },
      "post": {
        "summary": "Creates a new PaymentOrder. On successful validation, the PaymentOrder is sent to be scheduled or executed.",
        "operationId": "CreatePaymentOrder",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/payment_ordersPaymentOrder"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIPaymentOrderScheduler"
        ],
        "x-section": "Payment orders",
        "x-release-info": {
          "releaseVersion": {
            "major": 1,
            "minor": 8
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:write",
          "core.payment_orders:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/payment_ordersCreatePaymentOrderRequest"
        }
      }
    },
    "/v1/payment-orders/{id}": {
      "get": {
        "summary": "Retrieves one PaymentOrder object based on the PaymentOrder ID.",
        "operationId": "GetPaymentOrder",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/payment_ordersPaymentOrder"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The UUID of the PaymentOrder to get.",
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIPaymentOrderScheduler"
        ],
        "x-section": "Payment orders",
        "x-release-info": {
          "releaseVersion": {
            "major": 1,
            "minor": 8
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:read",
          "core.payment_orders:read"
        ]
      }
    },
    "/v1/payment-orders/{payment_order.id}": {
      "put": {
        "summary": "Updates an existing PaymentOrder object with a new reference, status, denomination, amount, schedule and/or calendar operation.",
        "operationId": "UpdatePaymentOrder",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/payment_ordersPaymentOrder"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The UUID of the PaymentOrder inside Vault. Optional on resource creation; if it is not set, a UUID will be generated. Required for update calls.",
            "name": "payment_order.id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIPaymentOrderScheduler"
        ],
        "x-section": "Payment orders",
        "x-release-info": {
          "releaseVersion": {
            "major": 1,
            "minor": 8
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:write",
          "core.payment_orders:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/payment_ordersUpdatePaymentOrderRequest"
        }
      }
    },
    "/v1/payment-orders:batchGet": {
      "get": {
        "summary": "Retrieves one or more PaymentOrder objects based on the PaymentOrder ID or list of payment order IDs.",
        "operationId": "BatchGetPaymentOrders",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/payment_ordersBatchGetPaymentOrdersResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A list of the PaymentOrder IDs to be retrieved. Required; must be non-empty.",
            "name": "ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIPaymentOrderScheduler"
        ],
        "x-section": "Payment orders",
        "x-release-info": {
          "releaseVersion": {
            "major": 1,
            "minor": 8
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:read",
          "core.payment_orders:read"
        ]
      }
    },
    "/v1/account-plan-assocs": {
      "get": {
        "summary": "Retrieves account plan associations using the provided filters.",
        "operationId": "ListAccountPlanAssocs",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/plansListAccountPlanAssocsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The IDs of accounts that account plan associations are to be listed for. Optional.",
            "name": "account_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "The IDs of plans that account plan associations are to be listed for. Optional.",
            "name": "plan_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "The number of results to be retrieved. Required.\n\nRequired.\nMin value: 1.\nMax value: 100.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "The token of the page the results are to be retrieved from. If empty, the first page of results will be returned. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "schema": {
              "type": "string"
            },
            "name": "start_timestamp_range.from",
            "in": "query",
            "required": false,
            "description": "The timestamp range that the start timestamp must belong to. This range is from start_timestamp_range.from up to and not including start_timestamp_range.to. Optional. This is an auto generated field to make the swagger compatible with the third party codegen tool."
          },
          {
            "schema": {
              "type": "string"
            },
            "name": "start_timestamp_range.to",
            "in": "query",
            "required": false,
            "description": "The timestamp range that the start timestamp must belong to. This range is from start_timestamp_range.from up to and not including start_timestamp_range.to. Optional. This is an auto generated field to make the swagger compatible with the third party codegen tool."
          },
          {
            "schema": {
              "type": "string"
            },
            "name": "end_timestamp_range.from",
            "in": "query",
            "required": false,
            "description": "The timestamp range that the end timestamp must belong to. This range is from end_timestamp_range.from up to and not including end_timestamp_range.to. Optional. This is an auto generated field to make the swagger compatible with the third party codegen tool."
          },
          {
            "schema": {
              "type": "string"
            },
            "name": "end_timestamp_range.to",
            "in": "query",
            "required": false,
            "description": "The timestamp range that the end timestamp must belong to. This range is from end_timestamp_range.from up to and not including end_timestamp_range.to. Optional. This is an auto generated field to make the swagger compatible with the third party codegen tool."
          }
        ],
        "tags": [
          "CoreAPIPlans"
        ],
        "x-section": "Plans",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.account_plan_assocs:read"
        ]
      }
    },
    "/v1/account-plan-assocs:batchGet": {
      "get": {
        "summary": "Retrieves one or more account plan associations using the account plan association ID.",
        "operationId": "BatchGetAccountPlanAssocs",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/plansBatchGetAccountPlanAssocsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A list of the IDs of the account plan associations that are to be retrieved. Required; must be non-empty. The 5.0 release will enforce a maximum number of IDs of 50.\n\nRequired.\nMin count: 1.",
            "name": "ids",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIPlans"
        ],
        "x-section": "Plans",
        "x-permission-scopes": [
          "core:read",
          "core.account_plan_assocs:read"
        ]
      }
    },
    "/v1/plan-migrations": {
      "get": {
        "summary": "Lists all plan migrations with optional filters.",
        "operationId": "ListPlanMigrations",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/plansListPlanMigrationsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "Statuses of plan migrations to filter on. Optional.",
            "name": "statuses",
            "in": "query",
            "required": false,
            "x-enum-value-descriptions": {
              "PLAN_MIGRATION_STATUS_COMPLETED": "Indicates the plan migration completed.",
              "PLAN_MIGRATION_STATUS_PENDING_EXECUTION": "The plan migration is in progress.",
              "PLAN_MIGRATION_STATUS_UNKNOWN": "Default value."
            },
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "PLAN_MIGRATION_STATUS_UNKNOWN",
                  "PLAN_MIGRATION_STATUS_PENDING_EXECUTION",
                  "PLAN_MIGRATION_STATUS_COMPLETED"
                ]
              }
            }
          },
          {
            "description": "Number of results to be retrieved. Must be non-zero.\n\nRequired.\nMin value: 1.\nMax value: 100.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "Token of the page from which to retrieve the results. If empty, the first page of results will be returned. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIPlans"
        ],
        "x-section": "Plans",
        "x-release-info": {
          "releaseVersion": {
            "major": 2,
            "minor": 3
          },
          "changeType": "ADD_METHOD"
        },
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.plan_migrations:read"
        ]
      },
      "post": {
        "summary": "Creates a plan migration.",
        "operationId": "CreatePlanMigration",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/plansPlanMigration"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIPlans"
        ],
        "x-section": "Plans",
        "x-release-info": {
          "releaseVersion": {
            "major": 2,
            "minor": 3
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:write",
          "core.plan_migrations:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/plansCreatePlanMigrationRequest"
        }
      }
    },
    "/v1/plan-migrations:batchGet": {
      "get": {
        "summary": "Retrieves one or more plan migrations using the plan migration ID.",
        "operationId": "BatchGetPlanMigrations",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/plansBatchGetPlanMigrationsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "IDs of the plan migrations to get. Mandatory. The 5.0 release will enforce a maximum number of IDs of 50.\n\nRequired.\nMin count: 1.",
            "name": "ids",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIPlans"
        ],
        "x-section": "Plans",
        "x-release-info": {
          "releaseVersion": {
            "major": 2,
            "minor": 3
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:read",
          "core.plan_migrations:read"
        ]
      }
    },
    "/v1/plan-schedules": {
      "get": {
        "summary": "Retrieves plan schedules using the provided filters.",
        "operationId": "ListPlanSchedules",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/plansListPlanSchedulesResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The plan ID that plan schedules are to be listed for. Required; must be non-empty.",
            "name": "plan_id",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The number of results to be retrieved. Required.\n\nRequired.\nMin value: 1.\nMax value: 20.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "The token of the page the results are to be retrieved from. If empty, the first page of results will be returned. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIPlans"
        ],
        "x-section": "Plans",
        "x-release-info": {
          "releaseVersion": {
            "major": 2,
            "minor": 1
          },
          "changeType": "ADD_METHOD",
          "featureFlag": "KERN_293_PLAN_SCHEDULES"
        },
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.plan_schedules:read"
        ]
      }
    },
    "/v1/plan-updates": {
      "get": {
        "summary": "Retrieves plan updates using the provided filters.",
        "operationId": "ListPlanUpdates",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/plansListPlanUpdatesResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The IDs of plans that plan updates are to be listed for. At least one of plan_ids and job_ids is required; must be non-empty.",
            "name": "plan_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "IDs of the jobs that plan updates are to be listed for. At least one of plan_ids and job_ids is required.",
            "name": "job_ids",
            "in": "query",
            "required": false,
            "x-release-info": {
              "releaseVersion": {
                "major": 2,
                "minor": 3
              },
              "changeType": "ADD_FIELD"
            },
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "The statuses of plan updates to filter on. Optional.",
            "name": "statuses",
            "in": "query",
            "required": false,
            "x-enum-value-descriptions": {
              "PLAN_UPDATE_STATUS_COMPLETED": "The plan update was successfully executed.",
              "PLAN_UPDATE_STATUS_ERRORED": "The plan update errored.",
              "PLAN_UPDATE_STATUS_PENDING_EXECUTION": "The plan update has not been picked up from the queue yet, or is in progress.",
              "PLAN_UPDATE_STATUS_REJECTED": "The plan update failed validation and has been rejected.",
              "PLAN_UPDATE_STATUS_UNKNOWN": "Default value."
            },
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "PLAN_UPDATE_STATUS_UNKNOWN",
                  "PLAN_UPDATE_STATUS_PENDING_EXECUTION",
                  "PLAN_UPDATE_STATUS_COMPLETED",
                  "PLAN_UPDATE_STATUS_REJECTED",
                  "PLAN_UPDATE_STATUS_ERRORED"
                ]
              }
            }
          },
          {
            "description": "The number of results to be retrieved. Required.\n\nRequired.\nMin value: 1.\nMax value: 100.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "The token of the page the results are to be retrieved from. If empty, the first page of results will be returned. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIPlans"
        ],
        "x-section": "Plans",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.plan_updates:read"
        ]
      },
      "post": {
        "summary": "Creates a plan update.",
        "operationId": "CreatePlanUpdate",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/plansPlanUpdate"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIPlans"
        ],
        "x-section": "Plans",
        "x-permission-scopes": [
          "core:write",
          "core.plan_updates:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/plansCreatePlanUpdateRequest"
        }
      }
    },
    "/v1/plan-updates:batchGet": {
      "get": {
        "summary": "Retrieves one or more plan updates using the plan update ID.",
        "operationId": "BatchGetPlanUpdates",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/plansBatchGetPlanUpdatesResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A list of the IDs of the plan updates that are to be retrieved. Required; must be non-empty. The 5.0 release will enforce a maximum number of IDs of 50.\n\nRequired.\nMin count: 1.",
            "name": "ids",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIPlans"
        ],
        "x-section": "Plans",
        "x-permission-scopes": [
          "core:read",
          "core.plan_updates:read"
        ]
      }
    },
    "/v1/plans": {
      "post": {
        "summary": "Creates a plan.",
        "operationId": "CreatePlan",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/plansPlan"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIPlans"
        ],
        "x-section": "Plans",
        "x-permission-scopes": [
          "core:write",
          "core.plans:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/plansCreatePlanRequest"
        }
      }
    },
    "/v1/plans:batchGet": {
      "get": {
        "summary": "Retrieves one or more plans using the plan ID.",
        "operationId": "BatchGetPlans",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/plansBatchGetPlansResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A list of the IDs of the plans that are to be retrieved. Required; must be non-empty. The 5.0 release will enforce a maximum number of IDs of 50.\n\nRequired.\nMin count: 1.",
            "name": "ids",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIPlans"
        ],
        "x-section": "Plans",
        "x-permission-scopes": [
          "core:read",
          "core.plans:read"
        ]
      }
    },
    "/v1/policies": {
      "get": {
        "summary": "Lists and filters Policy objects.",
        "operationId": "ListPolicies",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/policy_managementListPoliciesResponse"
                }
              }
            }
          },
          "400": {
            "description": "The error response for 400",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPIPolicyManagementINVALID_ARGUMENT_0",
                  "description": "Returned on receipt of invalid input regardless of the state of the system",
                  "title": "INVALID_ARGUMENT"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The policy schema ID or IDs to filter results by. Optional.",
            "name": "policy_schema_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "Fields to include in the response that are omitted by default. Optional.",
            "name": "fields_to_include",
            "in": "query",
            "required": false,
            "x-enum-value-descriptions": {
              "INCLUDE_FIELD_REGO_SOURCE": "Includes the rego_source field."
            },
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "INCLUDE_FIELD_REGO_SOURCE"
                ]
              }
            }
          },
          {
            "description": "The number of results to be listed. Required; must be non-zero. Maximum value of 100.\n\nRequired.\nMin value: 1.\nMax value: 100.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "The token of the page the results are to be retrieved from. If empty, the first page of results will be returned. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIPolicyManagement"
        ],
        "x-section": "Policy Management",
        "x-permission-scopes": [
          "core:read",
          "core.policies:read"
        ]
      },
      "post": {
        "summary": "Creates a new Policy.",
        "operationId": "CreatePolicy",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/policy_managementPolicy"
                }
              }
            }
          },
          "400": {
            "description": "The error response for 400",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPIPolicyManagementINVALID_ARGUMENT_0",
                  "description": "Returned on receipt of invalid input regardless of the state of the system",
                  "title": "INVALID_ARGUMENT"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIPolicyManagement"
        ],
        "x-section": "Policy Management",
        "x-permission-scopes": [
          "core:write",
          "core.policies:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/policy_managementCreatePolicyRequest"
        }
      }
    },
    "/v1/policies/{id}": {
      "get": {
        "summary": "Retrieves a Policy based on a Policy ID.",
        "operationId": "GetPolicy",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/policy_managementPolicy"
                }
              }
            }
          },
          "400": {
            "description": "The error response for 400",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPIPolicyManagementINVALID_ARGUMENT_0",
                  "description": "Returned on receipt of invalid input regardless of the state of the system",
                  "title": "INVALID_ARGUMENT"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "404": {
            "description": "The error response for 404",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GetPolicyNOT_FOUND_0",
                  "description": "Returned on the resource being retrieved not being found",
                  "title": "NOT_FOUND"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The ID of the Policy that is to be retrieved. Required.",
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIPolicyManagement"
        ],
        "x-section": "Policy Management",
        "x-permission-scopes": [
          "core:read",
          "core.policies:read"
        ]
      }
    },
    "/v1/policies/{policy.id}": {
      "put": {
        "summary": "Updates an existing Policy.",
        "operationId": "UpdatePolicy",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/policy_managementPolicy"
                }
              }
            }
          },
          "400": {
            "description": "The error response for 400",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPIPolicyManagementINVALID_ARGUMENT_0",
                  "description": "Returned on receipt of invalid input regardless of the state of the system",
                  "title": "INVALID_ARGUMENT"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "404": {
            "description": "The error response for 404",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/UpdatePolicyNOT_FOUND_0",
                  "description": "Returned on the resource being mutated not being found",
                  "title": "NOT_FOUND"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The unique identifier for the Policy. Required.",
            "name": "policy.id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIPolicyManagement"
        ],
        "x-section": "Policy Management",
        "x-permission-scopes": [
          "core:write",
          "core.policies:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/policy_managementUpdatePolicyRequest"
        }
      }
    },
    "/v1/policies:batchGet": {
      "get": {
        "summary": "Retrieves one or more Policies based on a list of IDs.",
        "operationId": "BatchGetPolicies",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/policy_managementBatchGetPoliciesResponse"
                }
              }
            }
          },
          "400": {
            "description": "The error response for 400",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPIPolicyManagementINVALID_ARGUMENT_0",
                  "description": "Returned on receipt of invalid input regardless of the state of the system",
                  "title": "INVALID_ARGUMENT"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "404": {
            "description": "The error response for 404",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchGetPoliciesNOT_FOUND_0",
                  "description": "Returned on the resource being retrieved not being found",
                  "title": "NOT_FOUND"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The IDs of the Policies to be retrieved.\n\nRequired.",
            "name": "ids",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "Fields to include in the response that are omitted by default. Optional.",
            "name": "fields_to_include",
            "in": "query",
            "required": false,
            "x-enum-value-descriptions": {
              "INCLUDE_FIELD_REGO_SOURCE": "Includes the rego_source field."
            },
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "INCLUDE_FIELD_REGO_SOURCE"
                ]
              }
            }
          }
        ],
        "tags": [
          "CoreAPIPolicyManagement"
        ],
        "x-section": "Policy Management",
        "x-permission-scopes": [
          "core:read",
          "core.policies:read"
        ]
      }
    },
    "/v1/post-posting-failures": {
      "get": {
        "summary": "Lists and filters Post Posting Failures that are currently stored.",
        "operationId": "ListPostPostingFailures",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/post_posting_republisherListPostPostingFailuresResponse"
                }
              }
            }
          },
          "400": {
            "description": "The error response for 400",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPIPostPostingRepublisherINVALID_ARGUMENT_0",
                  "description": "Returned on receipt of invalid input regardless of the state of the system",
                  "title": "INVALID_ARGUMENT"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "Filters Post Posting Failures by the Account IDs of their associated failures.",
            "name": "account_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "Filters Post Posting Failures by the posting instruction batch IDs of their associated failures.",
            "name": "posting_instruction_batch_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "The number of Post Posting Failures to be retrieved.\n\nRequired.\nMin value: 1.\nMax value: 50.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "The token of the page the results are to be retrieved from. If empty, this returns the first page of results.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIPostPostingRepublisher"
        ],
        "x-section": "Post Posting Republisher",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.post_posting_failures:read"
        ]
      }
    },
    "/v1/post-posting-failures/{id}": {
      "delete": {
        "summary": "DeletePostPostingFailure deletes the Post Posting Failure. It will reject requests to delete a Post Posting Failure that is not the earliest for an account.",
        "operationId": "DeletePostPostingFailure",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/post_posting_republisherDeletePostPostingFailureResponse"
                }
              }
            }
          },
          "400": {
            "description": "The potential error responses for 400",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/DeletePostPostingFailureFAILED_PRECONDITION_0",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/CoreAPIPostPostingRepublisherINVALID_ARGUMENT_0",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The ID of the Post Posting Failure to delete. If the ID is not the earliest for the associated account, the request will be rejected.",
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIPostPostingRepublisher"
        ],
        "x-section": "Post Posting Republisher",
        "x-permission-scopes": [
          "core:write",
          "core.post_posting_failures:write"
        ]
      }
    },
    "/v1/post-posting-failures:batchGet": {
      "get": {
        "summary": "Gets one or more Post Posting Failures based on their ID.",
        "operationId": "BatchGetPostPostingFailures",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/post_posting_republisherBatchGetPostPostingFailuresResponse"
                }
              }
            }
          },
          "400": {
            "description": "The error response for 400",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPIPostPostingRepublisherINVALID_ARGUMENT_0",
                  "description": "Returned on receipt of invalid input regardless of the state of the system",
                  "title": "INVALID_ARGUMENT"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "404": {
            "description": "The error response for 404",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/BatchGetPostPostingFailuresNOT_FOUND_0",
                  "description": "Returned when one or more of the resource IDs provided do not exist",
                  "title": "NOT_FOUND"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A list of IDs of Post Posting Failures to be retrieved.\n\nRequired.\nMin count: 1.\nMax count: 50.",
            "name": "ids",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIPostPostingRepublisher"
        ],
        "x-section": "Post Posting Republisher",
        "x-permission-scopes": [
          "core:read",
          "core.post_posting_failures:read"
        ]
      }
    },
    "/v1/post-posting-failures:republish": {
      "post": {
        "summary": "RepublishPostPostingFailure republishes the earliest Post Posting Failure for an account. It can also republish all blocked failures for the account at the same time.",
        "operationId": "RepublishPostPostingFailure",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/post_posting_republisherPostPostingFailure"
                }
              }
            }
          },
          "400": {
            "description": "The error response for 400",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/CoreAPIPostPostingRepublisherINVALID_ARGUMENT_0",
                  "description": "Returned on receipt of invalid input regardless of the state of the system",
                  "title": "INVALID_ARGUMENT"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIPostPostingRepublisher"
        ],
        "x-section": "Post Posting Republisher",
        "x-permission-scopes": [
          "core:write",
          "core.post_posting_failures:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/post_posting_republisherRepublishPostPostingFailureRequest"
        }
      }
    },
    "/v1/create-posting-instruction-batch:validate": {
      "post": {
        "summary": "Validates that a CreatePostingInstructionBatchRequest message is well-formed.",
        "operationId": "ValidateCreatePostingInstructionBatchRequest",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/posting_instruction_batchesValidateCreatePostingInstructionBatchRequestResponse"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIPostingInstructionBatch"
        ],
        "x-section": "Posting instruction batches",
        "x-permission-scopes": [
          "core:execute",
          "core.create_posting_instruction_batch:execute"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/posting_instruction_batchesValidateCreatePostingInstructionBatchRequestRequest"
        }
      }
    },
    "/v1/posting-instruction-batches": {
      "get": {
        "summary": "Lists and filters posting instruction batches. Multiple filter parameters are joined by a logical AND operator.",
        "operationId": "ListPostingInstructionBatches",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/posting_instruction_batchesListPostingInstructionBatchesResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "Filters posting instruction batches by the `account_ids` of their associated posting instructions. Optional.",
            "name": "account_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "Filters posting instruction batches by their `client_batch_ids`. Optional.",
            "name": "client_batch_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "payment_device_tokens",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "Filters posting instruction batches by the `client_transaction_ids` of their associated posting instructions. Optional.",
            "name": "client_transaction_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "The number of results to retrieve. Required; non-zero.\n\nRequired.\nMin value: 1.\nMax value: 100.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "The token of the page to retrieve results from. If left empty, the first page of results will be returned. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The direction to order results in, by `value_timestamp`. Optional.",
            "name": "order_by_direction",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "enum": [
                "ORDER_BY_DESC",
                "ORDER_BY_ASC"
              ],
              "default": "ORDER_BY_DESC"
            }
          },
          {
            "description": "Filters posting instruction batches by `value_timestamp`. The earliest posting instruction batch returned in the list will have been created after or at `start_time`. Optional.",
            "name": "start_time",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "description": "Filters posting instruction batches by `value_timestamp`. The latest posting instruction batch returned in the list will have been created before `end_time`. Optional.",
            "name": "end_time",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          }
        ],
        "tags": [
          "CoreAPIPostingInstructionBatch"
        ],
        "x-section": "Posting instruction batches",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.posting_instruction_batches:read"
        ]
      }
    },
    "/v1/posting-instruction-batches/async-operations:batchGet": {
      "get": {
        "summary": "Retrieves multiple AsyncOperations. The IDs provided must belong to AsyncOperations returned by /v1/posting-instruction-batches:asyncCreate.",
        "operationId": "BatchGetAsyncOperations",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/async_operationsBatchGetAsyncOperationsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The IDs of the AsyncOperations to retrieve.",
            "name": "ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIPostingInstructionBatch"
        ],
        "x-section": "Posting instruction batches",
        "x-permission-scopes": [
          "core:read",
          "core.posting_instruction_batches:read"
        ]
      }
    },
    "/v1/posting-instruction-batches/{id}": {
      "get": {
        "summary": "Retrieves a posting instruction batch by ID.",
        "operationId": "GetPostingInstructionBatch",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/v1PostingInstructionBatch"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The ID of the posting instruction batch to retrieve.",
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIPostingInstructionBatch"
        ],
        "x-section": "Posting instruction batches",
        "x-permission-scopes": [
          "core:read",
          "core.posting_instruction_batches:read"
        ]
      }
    },
    "/v1/posting-instruction-batches:asyncCreate": {
      "post": {
        "summary": "Creates and returns an AsyncOperation to submit a PostingInstructionBatchRequest to the Postings API. The status of the posting instruction batch request can be checked by calling BatchGetAsyncOperations on the AsyncOperation ID.",
        "description": "The Postings API is idempotent to duplicate PostingInstructionBatchRequest, and will respond idempotently to PostingInstructionBatchRequest messages with the same <client_id-request_id>. The CreatePostingInstructionBatchAsync endpoint is not idempotent and will create multiple AsyncOperation resources on duplicate calls.",
        "operationId": "CreatePostingInstructionBatchAsync",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/async_operationsAsyncOperation"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIPostingInstructionBatch"
        ],
        "x-section": "Posting instruction batches",
        "x-permission-scopes": [
          "core:write",
          "core.posting_instruction_batches:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/v1posting_instruction_batchesCreatePostingInstructionBatchRequest"
        }
      }
    },
    "/v1/posting-instruction-batches:batchGet": {
      "get": {
        "summary": "Retrieves one or more posting instruction batches by ID.",
        "operationId": "BatchGetPostingInstructionBatches",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/posting_instruction_batchesBatchGetPostingInstructionBatchesResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A list of IDs of posting instruction batches to retrieve. Required; must be non-empty.\nThis field must contain a valid UUID in the canonical 8-4-4-4-12 form.\nRequired.",
            "name": "ids",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIPostingInstructionBatch"
        ],
        "x-section": "Posting instruction batches",
        "x-permission-scopes": [
          "core:read",
          "core.posting_instruction_batches:read"
        ]
      }
    },
    "/v1/postings-api-clients": {
      "get": {
        "summary": "Gets a list of all `PostingsAPIClient`s.",
        "operationId": "ListPostingsAPIClients",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/postings_api_clientsListPostingsAPIClientsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The number of results to retrieve. Required; must be non-zero.",
            "name": "page_size",
            "in": "query",
            "required": false,
            "x-example-override": "2",
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "Token of the page the results are to be retrieved from. If empty, the first page of results will be returned. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIPostingsAPIClient"
        ],
        "x-section": "Postings API clients",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.postings_api_clients:read"
        ]
      },
      "post": {
        "summary": "Creates and returns a specified `PostingsAPIClient`. The response topic will be created if it does not exist and must contain the prefix 'integration.'. For compatibility, existing topics that are not prefixed with 'integration.' are allowed. NOTE: You cannot update the response topic after the client has been created. You can disable Vault-side Kafka topic management by setting the `kafka.topics.disable_vault_topic_management` option in the `values.yaml` file to `true`. When topic management is disabled, the response topics you have provided will not be created in the Kafka cluster, only the required `integrations.*` prefix of the topic names will be validated. You must ensure that the topics exist in the Kafka cluster before using the PostingsAPIClient.",
        "operationId": "CreatePostingsAPIClient",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/postings_api_clientsPostingsAPIClient"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIPostingsAPIClient"
        ],
        "x-section": "Postings API clients",
        "x-permission-scopes": [
          "core:write",
          "core.postings_api_clients:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/postings_api_clientsCreatePostingsAPIClientRequest"
        }
      }
    },
    "/v1/postings-api-clients/{id}": {
      "get": {
        "summary": "Gets a `PostingsAPIClient` for the given `id`.",
        "operationId": "GetPostingsAPIClient",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/postings_api_clientsPostingsAPIClient"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A unique ID that identifies a `PostingsAPIClient` to the Postings API. Required.",
            "name": "id",
            "in": "path",
            "required": true,
            "x-example-override": "ExamplePaymentProcessorClientID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIPostingsAPIClient"
        ],
        "x-section": "Postings API clients",
        "x-permission-scopes": [
          "core:read",
          "core.postings_api_clients:read"
        ]
      }
    },
    "/v1/postings-api-clients/{postings_api_client.id}": {
      "put": {
        "summary": "Updates an existing `PostingsAPIClient` with a new `response_topic_low_priority`, which must differ from `response_topic`. The response topic will be created if it does not exist and must contain the prefix 'integration.'. For compatibility, existing topics that are not prefixed with 'integration.' are allowed. It may take up to five minutes for responses to be streamed on the updated response topics. You can disable Vault-side Kafka topic management by setting the `kafka.topics.disable_vault_topic_management` option in the `values.yaml` file to `true`. When topic management is disabled, the `response_topic_low_priority` topic you have provided will not be created in the Kafka cluster, only the required `integrations.*` prefix of the topic name will be validated. You must ensure that the topic exists in the Kafka cluster before using the PostingsAPIClient.",
        "operationId": "UpdatePostingsAPIClient",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/postings_api_clientsPostingsAPIClient"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A unique ID that identifies a `PostingsAPIClient` to the Postings API.",
            "name": "postings_api_client.id",
            "in": "path",
            "required": true,
            "x-example-override": "ExamplePaymentProcessorClientID",
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIPostingsAPIClient"
        ],
        "x-section": "Postings API clients",
        "x-release-info": {
          "releaseVersion": {
            "major": 1,
            "minor": 9
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:write",
          "core.postings_api_clients:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/postings_api_clientsUpdatePostingsAPIClientRequest"
        }
      }
    },
    "/v1/postings-api-clients:batchGet": {
      "get": {
        "summary": "Gets a map of `id` to `PostingsAPIClient` for a given set of `id`s.",
        "operationId": "BatchGetPostingsAPIClients",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/postings_api_clientsBatchGetPostingsAPIClientsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A list of unique IDs that identify `PostingsAPIClient`s to the Postings API. Required.",
            "name": "ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIPostingsAPIClient"
        ],
        "x-section": "Postings API clients",
        "x-permission-scopes": [
          "core:read",
          "core.postings_api_clients:read"
        ]
      }
    },
    "/v1/product-versions": {
      "get": {
        "summary": "Lists the versions of a product with pagination.",
        "operationId": "ListProductVersions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/productsListProductVersionsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The product ID that product versions are to be listed for. Required.",
            "name": "product_id",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Indicates which fields should be included in the product versions. Optional.",
            "name": "view",
            "in": "query",
            "required": false,
            "x-enum-value-descriptions": {
              "PRODUCT_VERSION_VIEW_BASIC": "Default. Includes basic information about the product version.",
              "PRODUCT_VERSION_VIEW_INCLUDE_CODE": "Includes contract parameters and source code associated with the product.",
              "PRODUCT_VERSION_VIEW_INCLUDE_PARAMETERS": "Includes basic product version information and contract parameters associated with the product.",
              "PRODUCT_VERSION_VIEW_INCLUDE_TAGS": "Includes basic product version information and tags associated with the product."
            },
            "schema": {
              "type": "string",
              "enum": [
                "PRODUCT_VERSION_VIEW_BASIC",
                "PRODUCT_VERSION_VIEW_INCLUDE_TAGS",
                "PRODUCT_VERSION_VIEW_INCLUDE_PARAMETERS",
                "PRODUCT_VERSION_VIEW_INCLUDE_CODE"
              ],
              "default": "PRODUCT_VERSION_VIEW_BASIC"
            }
          },
          {
            "description": "\n\nRequired.\nMin value: 1.\nMax value: 30.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "Token of the page the results are to be retrieved from. If empty, returns the first page of results. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIProducts"
        ],
        "x-section": "Products",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.product_versions:read"
        ]
      },
      "post": {
        "summary": "Creates a product version and product.",
        "operationId": "CreateProductVersion",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/productsProductVersion"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIProducts"
        ],
        "x-section": "Products",
        "x-permission-scopes": [
          "core:write",
          "core.product_versions:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/productsCreateProductVersionRequest"
        }
      }
    },
    "/v1/product-versions/{product_version_id}:paramTimeseries": {
      "get": {
        "summary": "Lists the timeseries for the parameters of a product version.",
        "operationId": "ListProductVersionParametersTimeseries",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/productsListProductVersionParametersTimeseriesResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The product version ID the parameter timeseries is to be retrieved for.",
            "name": "product_version_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIProducts"
        ],
        "x-section": "Products",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read"
        ]
      }
    },
    "/v1/product-versions/{product_version_id}:updateParams": {
      "put": {
        "summary": "Updates the value of one or more parameters for a product version.",
        "description": "To add one or more parameter values at a new effective timestamp, each parameter in the `items_to_add` field must have its `name` and `value` populated. The `effective_timestamp` is optional and will default to current time. The new parameter(s) will be added to the product version parameter timeseries. An error will be raised if the `items_to_add` field is populated with a parameter with an existing `name` and `effective_timestamp`.\n\nTo remove one or more parameter values at existing effective timestamps, each parameter in the `items_to_remove` field must have its `name` and `effective_timestamp` populated. The `value` of the parameter will be ignored. The specified parameter(s) will be deleted from the product version parameter timeseries. An error will be raised if the `items_to_remove` field is populated with parameters `name` and `effective_timestamp` that do not already exist in the product version parameter timeseries.\n\nTo edit the `value` of one or more parameters with an effective_timestamp set to a time in the future, the request must be sent with the `items_to_remove` and `items_to_add` fields populated. The `items_to_remove` field requires a list of existing parameters with the `name` and `effective_timestamp` fields populated. The `items_to_add field` requires a list of parameters with the `name` and `effective_timestamp` fields populated. The `value` field of the parameter(s) must be populated with the desired end value. The name and effective_timestamp of a parameter in the items_to_add field must exactly match the corresponding parameter in the items_to_remove field if the parameter's `value` is to be updated.",
        "operationId": "UpdateProductVersionParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/productsProductVersion"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The ID of the product version to be updated.",
            "name": "product_version_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIProducts"
        ],
        "x-section": "Products",
        "x-permission-scopes": [
          "core:write",
          "core.product_versions:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/productsUpdateProductVersionParamsRequest"
        }
      }
    },
    "/v1/product-versions:batchGet": {
      "get": {
        "summary": "Retrieves one or more product versions using the product version IDs specified.",
        "operationId": "BatchGetProductVersions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/productsBatchGetProductVersionsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A list of the IDs of the product versions to be retrieved. Required; must be non-empty.",
            "name": "ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "Indicates which fields should be included for the product versions. Optional; default is basic view.",
            "name": "view",
            "in": "query",
            "required": false,
            "x-enum-value-descriptions": {
              "PRODUCT_VERSION_VIEW_BASIC": "Default. Includes basic information about the product version.",
              "PRODUCT_VERSION_VIEW_INCLUDE_CODE": "Includes contract parameters and source code associated with the product.",
              "PRODUCT_VERSION_VIEW_INCLUDE_PARAMETERS": "Includes basic product version information and contract parameters associated with the product.",
              "PRODUCT_VERSION_VIEW_INCLUDE_TAGS": "Includes basic product version information and tags associated with the product."
            },
            "schema": {
              "type": "string",
              "enum": [
                "PRODUCT_VERSION_VIEW_BASIC",
                "PRODUCT_VERSION_VIEW_INCLUDE_TAGS",
                "PRODUCT_VERSION_VIEW_INCLUDE_PARAMETERS",
                "PRODUCT_VERSION_VIEW_INCLUDE_CODE"
              ],
              "default": "PRODUCT_VERSION_VIEW_BASIC"
            }
          }
        ],
        "tags": [
          "CoreAPIProducts"
        ],
        "x-section": "Products",
        "x-permission-scopes": [
          "core:read",
          "core.product_versions:read"
        ]
      }
    },
    "/v1/products": {
      "get": {
        "summary": "Lists products with pagination.",
        "operationId": "ListProducts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/productsListProductsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "name": "include_internality",
            "in": "query",
            "required": false,
            "x-enum-value-descriptions": {
              "INTERNALITY_REFINER_ANY_INTERNALITY": "Default. Lists both internal and external products.",
              "INTERNALITY_REFINER_EXTERNAL": "Lists external products only.",
              "INTERNALITY_REFINER_INTERNAL": "Lists internal products only."
            },
            "schema": {
              "type": "string",
              "enum": [
                "INTERNALITY_REFINER_ANY_INTERNALITY",
                "INTERNALITY_REFINER_INTERNAL",
                "INTERNALITY_REFINER_EXTERNAL"
              ],
              "default": "INTERNALITY_REFINER_ANY_INTERNALITY"
            }
          },
          {
            "description": "\n\nRequired.\nMin value: 1.\nMax value: 30.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "Token of the page the results are to be retrieved from. If empty, returns the first page of results. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIProducts"
        ],
        "x-section": "Products",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.products:read"
        ]
      }
    },
    "/v1/products:batchGet": {
      "get": {
        "summary": "Retrieves one or more products using the product IDs specified.",
        "operationId": "BatchGetProducts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/productsBatchGetProductsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The list of product IDs for the products that are to be retrieved. Required; must be non-empty.",
            "name": "ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIProducts"
        ],
        "x-section": "Products",
        "x-permission-scopes": [
          "core:read",
          "core.products:read"
        ]
      }
    },
    "/v1/restriction-set-definition-versions": {
      "get": {
        "summary": "Lists all the restriction set definition versions sorted by name. This list method does not support pagination, as we believe it will never reach a point where pagination is required, even after many years of use. The restriction set definition versions are sorted by creation time from earliest to latest.",
        "operationId": "ListRestrictionSetDefinitionVersions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/restrictionsListRestrictionSetDefinitionVersionsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "Indicates if previous versions should be excluded. Optional; default false.",
            "name": "exclude_previous_versions",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          },
          {
            "description": "The restriction set definition ID that the restriction set definition versions must belong to. If empty, all restriction set definitions are returned. Optional for GRPC requests.",
            "name": "restriction_set_definition_id",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIRestrictions"
        ],
        "x-section": "Restrictions",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.restriction_set_definition_versions:read"
        ]
      },
      "post": {
        "summary": "Creates a restriction set definition version. This creates the restriction set definition if it does not exist.",
        "operationId": "CreateRestrictionSetDefinitionVersion",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/restrictionsRestrictionSetDefinitionVersion"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIRestrictions"
        ],
        "x-section": "Restrictions",
        "x-permission-scopes": [
          "core:write",
          "core.restriction_set_definition_versions:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/restrictionsCreateRestrictionSetDefinitionVersionRequest"
        }
      }
    },
    "/v1/restriction-set-definition-versions:batchGet": {
      "get": {
        "summary": "Retrieves one or more restriction set definition versions using the restriction set definition version IDs.",
        "operationId": "BatchGetRestrictionSetDefinitionVersions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/restrictionsBatchGetRestrictionSetDefinitionVersionsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A list of the IDs of restriction set definition versions that are to be retrieved. Required; must be non-empty. The 5.0 release will enforce a maximum number of IDs of 50.\n\nRequired.\nMin count: 1.",
            "name": "ids",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIRestrictions"
        ],
        "x-section": "Restrictions",
        "x-release-info": {
          "releaseVersion": {
            "major": 1,
            "minor": 10
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:read",
          "core.restriction_set_definition_versions:read"
        ]
      }
    },
    "/v1/restriction-set-definition/{restriction_set_definition_id}/versions": {
      "get": {
        "summary": "Lists all the restriction set definition versions sorted by name. This list method does not support pagination, as we believe it will never reach a point where pagination is required, even after many years of use. The restriction set definition versions are sorted by creation time from earliest to latest.",
        "operationId": "ListRestrictionSetDefinitionVersions2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/restrictionsListRestrictionSetDefinitionVersionsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The restriction set definition ID that the restriction set definition versions must belong to. If empty, all restriction set definitions are returned. Optional for GRPC requests.",
            "name": "restriction_set_definition_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Indicates if previous versions should be excluded. Optional; default false.",
            "name": "exclude_previous_versions",
            "in": "query",
            "required": false,
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "tags": [
          "CoreAPIRestrictions"
        ],
        "x-section": "Restrictions",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.restriction_set_definition_versions:read"
        ]
      }
    },
    "/v1/restriction-set-definition/{restriction_set_definition_version.restriction_set_definition_id}/versions": {
      "post": {
        "summary": "Creates a restriction set definition version. This creates the restriction set definition if it does not exist.",
        "operationId": "CreateRestrictionSetDefinitionVersion2",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/restrictionsRestrictionSetDefinitionVersion"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The ID or name of the restriction set definition this version belongs to. Required for create requests.",
            "name": "restriction_set_definition_version.restriction_set_definition_id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIRestrictions"
        ],
        "x-section": "Restrictions",
        "x-permission-scopes": [
          "core:write",
          "core.restriction_set_definition_versions:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/restrictionsCreateRestrictionSetDefinitionVersionRequest"
        }
      }
    },
    "/v1/restriction-set-definitions": {
      "get": {
        "summary": "Lists all the restriction set definitions.",
        "operationId": "ListRestrictionSetDefinitions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/restrictionsListRestrictionSetDefinitionsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The number of results to be retrieved. Required; non-zero; maximum 500.\n\nRequired.\nMin value: 1.\nMax value: 500.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "The token of the page the results are to be retrieved from. If empty, the first page of results will be returned. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIRestrictions"
        ],
        "x-section": "Restrictions",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.restriction_set_definitions:read"
        ]
      }
    },
    "/v1/restriction-sets": {
      "get": {
        "summary": "Returns all the restriction sets for the provided parameters. This does not require pagination, as we only expect this to return a small number of restriction sets. You must provide at least one ID in the request.",
        "operationId": "ListRestrictionSets",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/restrictionsListRestrictionSetsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The time at which restriction sets apply. Any restriction sets that are not yet active or have already expired at this time will be excluded. Optional; default is current time.",
            "name": "effective_timestamp",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "description": "The IDs of customers that restriction sets are applied to. Optional; Boolean OR interaction with other fields.",
            "name": "customer_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "The IDs of accounts that restriction sets are applied to. Optional; Boolean OR interaction with other fields.",
            "name": "account_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "The IDs of payment devices that restriction sets are applied to. Optional; Boolean OR interaction with other fields.",
            "name": "payment_device_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIRestrictions"
        ],
        "x-section": "Restrictions",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.restriction_sets:read"
        ]
      },
      "post": {
        "summary": "Creates a restriction set for the provided parameters.",
        "operationId": "CreateRestrictionSet",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/restrictionsRestrictionSet"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIRestrictions"
        ],
        "x-section": "Restrictions",
        "x-permission-scopes": [
          "core:write",
          "core.restriction_sets:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/restrictionsCreateRestrictionSetRequest"
        }
      }
    },
    "/v1/restriction-sets/{restriction_set.id}": {
      "put": {
        "summary": "Updates a restriction set.",
        "operationId": "UpdateRestrictionSet",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/restrictionsRestrictionSet"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The unique identifier for this restriction set. Output only.",
            "name": "restriction_set.id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIRestrictions"
        ],
        "x-section": "Restrictions",
        "x-permission-scopes": [
          "core:write",
          "core.restriction_sets:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/restrictionsUpdateRestrictionSetRequest"
        }
      }
    },
    "/v1/restriction-sets:batchGet": {
      "get": {
        "summary": "Retrieves one or more restriction sets using the restriction set IDs.",
        "operationId": "BatchGetRestrictionSets",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/restrictionsBatchGetRestrictionSetsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "A list of the IDs of restriction sets that are to be retrieved. Required; must be non-empty. The 5.0 release will enforce a maximum number of IDs of 50.\n\nRequired.\nMin count: 1.",
            "name": "ids",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIRestrictions"
        ],
        "x-section": "Restrictions",
        "x-release-info": {
          "releaseVersion": {
            "major": 1,
            "minor": 10
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:read",
          "core.restriction_sets:read"
        ]
      }
    },
    "/v1/restrictions": {
      "get": {
        "summary": "Lists all the restrictions for the provided parameters. This does not require pagination, as we only expect this to return a small number of restrictions. You must provide at least one ID in the request.",
        "operationId": "ListRestrictions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/restrictionsListRestrictionsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The time at which restrictions apply. Any restrictions that are not yet active or have already expired at this time will be excluded. Optional; default is current time.",
            "name": "effective_timestamp",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "description": "The IDs of customers that restrictions are applied to. Optional; Boolean OR interaction with other fields.",
            "name": "customer_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "The IDs of accounts that restrictions are applied to. Optional; Boolean OR interaction with other fields.",
            "name": "account_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "The IDs of payment devices that restrictions are applied to. Optional; Boolean OR interaction with other fields.",
            "name": "payment_device_ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIRestrictions"
        ],
        "x-section": "Restrictions",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.restrictions:read"
        ]
      }
    },
    "/v1/jobs": {
      "get": {
        "summary": "Returns a list of Jobs based on Schedule ID.",
        "operationId": "ListJobs",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/schedulerListJobsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The ID that is used to list all Jobs with a specified Schedule ID.\n\nRequired.",
            "name": "schedule_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "The number of results to be listed. Required; must be non-zero.\n\nRequired.\nMin value: 1.\nMax value: 500.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "Token of the page the results are to be retrieved from. If empty, returns the results based on the other parameters. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIScheduler"
        ],
        "x-section": "Scheduler",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.jobs:read"
        ]
      }
    },
    "/v1/jobs/{id}:republish": {
      "post": {
        "summary": "Republishes a Job.",
        "operationId": "RepublishJob",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/schedulerRepublishJobResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The ID of the Job to be republished.",
            "name": "id",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIScheduler"
        ],
        "x-section": "Scheduler",
        "x-permission-scopes": [
          "core:execute",
          "core.jobs:execute"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/schedulerRepublishJobRequest"
        }
      }
    },
    "/v1/jobs:batchGet": {
      "get": {
        "summary": "Returns one or more Jobs.",
        "operationId": "BatchGetJobs",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/schedulerBatchGetJobsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The Job or Jobs to be retrieved using their Job IDs.\n\nRequired.\nMin count: 1.",
            "name": "ids",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIScheduler"
        ],
        "x-section": "Scheduler",
        "x-permission-scopes": [
          "core:read",
          "core.jobs:read"
        ]
      }
    },
    "/v1/schedule-tags": {
      "post": {
        "summary": "Creates a ScheduleTag.",
        "operationId": "CreateScheduleTag",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/schedulerScheduleTag"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIScheduler"
        ],
        "x-section": "Scheduler",
        "x-release-info": {
          "noticeVersion": {
            "major": 4,
            "minor": 6
          },
          "releaseVersion": {
            "major": 6
          },
          "changeType": "REMOVE_METHOD",
          "description": "The Schedule Tags API is deprecated"
        },
        "x-permission-scopes": [
          "core:write",
          "core.schedule_tags:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/schedulerCreateScheduleTagRequest"
        }
      }
    },
    "/v1/schedules": {
      "get": {
        "summary": "Lists and filters Schedules.",
        "operationId": "ListSchedules",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/schedulerListSchedulesResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The number of results to be listed. Required; must be non-zero.\n\nRequired.\nMin value: 1.\nMax value: 500.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "When selected, a filter is applied to ScheduleStatus. Default is unselected.",
            "name": "status",
            "in": "query",
            "required": false,
            "x-enum-value-release-info": {
              "SCHEDULE_STATUS_DELAYED": {
                "releaseVersion": {
                  "major": 2
                },
                "changeType": "ADD_ENUM_VALUE",
                "description": "Adds a new status value: Delayed"
              },
              "SCHEDULE_STATUS_SKIPPED": {
                "noticeVersion": {
                  "major": 3,
                  "minor": 1
                },
                "releaseVersion": {
                  "major": 5
                },
                "changeType": "REMOVE_ENUM_VALUE",
                "description": "This field's functionality is to be replaced by skip_start_timestamp/skip_end_timestamp"
              }
            },
            "x-enum-value-descriptions": {
              "SCHEDULE_STATUS_COMPLETED": "The Schedule has completed and is inactive.",
              "SCHEDULE_STATUS_DELAYED": "A Schedule is in a DELAYED State.",
              "SCHEDULE_STATUS_DISABLED": "The Schedule is disabled and inactive.",
              "SCHEDULE_STATUS_ENABLED": "The Schedule is enabled and active.",
              "SCHEDULE_STATUS_FAILED": "The Schedule has failed and is inactive.",
              "SCHEDULE_STATUS_PENDING": "The Schedule is in a PENDING State.",
              "SCHEDULE_STATUS_SKIPPED": "A Schedule is in a SKIPPED State.",
              "SCHEDULE_STATUS_UNKNOWN": "When selected, a filter is applied to ScheduleStatus. Default is unselected."
            },
            "schema": {
              "type": "string",
              "enum": [
                "SCHEDULE_STATUS_UNKNOWN",
                "SCHEDULE_STATUS_ENABLED",
                "SCHEDULE_STATUS_DISABLED",
                "SCHEDULE_STATUS_COMPLETED",
                "SCHEDULE_STATUS_FAILED",
                "SCHEDULE_STATUS_PENDING",
                "SCHEDULE_STATUS_DELAYED",
                "SCHEDULE_STATUS_SKIPPED"
              ],
              "default": "SCHEDULE_STATUS_UNKNOWN"
            }
          },
          {
            "description": "Token of the page the results are to be retrieved from. If empty, returns the results based on the other parameters. Optional.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Filter schedules by name. Optional.",
            "name": "name_filter",
            "in": "query",
            "required": false,
            "x-release-info": {
              "releaseVersion": {
                "major": 1,
                "minor": 12
              },
              "changeType": "ADD_FIELD",
              "description": "ListSchedules accepts a name filter"
            },
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPIScheduler"
        ],
        "x-section": "Scheduler",
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.schedules:read"
        ]
      }
    },
    "/v1/schedules:batchGet": {
      "get": {
        "summary": "Retrieves one or more Schedules.",
        "operationId": "BatchGetSchedules",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/schedulerBatchGetSchedulesResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "Maps the Schedule ID to the requested Schedules.\n\nRequired.\nMin count: 1.",
            "name": "ids",
            "in": "query",
            "required": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPIScheduler"
        ],
        "x-section": "Scheduler",
        "x-permission-scopes": [
          "core:read",
          "core.schedules:read"
        ]
      }
    },
    "/v1/smart-contracts:simulateExistingAccount": {
      "post": {
        "summary": "Simulates an existing account. It is similar to simulating a Smart Contract, but before the simulation starts the given account's state is replicated up to the simulation start timestamp. This means that the balance amounts available in the simulation will be the same as the real account at the given time. All timeseries (parameters, flags, balances) and postings data will be populated as per the real account up to the simulation start time. Any covering postings after the start of the simulation will not be included, meaning that if you start a simulation after an authorisation posting but before the corresponding settlement then the settlement will not be included in the simulation.",
        "operationId": "SimulateExistingAccount",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/smart_contractsSimulateSmartContractResponse"
                }
              }
            }
          },
          "401": {
            "description": "The error response for 401",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsUNAUTHENTICATED_1",
                  "description": "Returned when the request could not be authenticated",
                  "title": "UNAUTHENTICATED"
                }
              }
            }
          },
          "403": {
            "description": "The error response for 403",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/PublicAPIErrorsPERMISSION_DENIED_0",
                  "description": "Returned when the client does not have permission to perform the request",
                  "title": "PERMISSION_DENIED"
                }
              }
            }
          },
          "429": {
            "description": "The error response for 429",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsRESOURCE_EXHAUSTED_2",
                  "description": "Returned when too many requests are sent within a time period",
                  "title": "RESOURCE_EXHAUSTED"
                }
              }
            }
          },
          "500": {
            "description": "The potential error responses for 500",
            "content": {
              "application/json": {
                "schema": {
                  "oneOf": [
                    {
                      "$ref": "#/components/schemas/GlobalErrorsINTERNAL_1",
                      "required": false
                    },
                    {
                      "$ref": "#/components/schemas/GlobalErrorsUNKNOWN_4",
                      "required": false
                    }
                  ]
                }
              }
            }
          },
          "503": {
            "description": "The error response for 503",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsUNAVAILABLE_3",
                  "description": "Returned when the service is currently unavailable. Can be safely retried",
                  "title": "UNAVAILABLE"
                }
              }
            }
          },
          "504": {
            "description": "The error response for 504",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/GlobalErrorsDEADLINE_EXCEEDED_0",
                  "description": "Returned when a complete request was not received within the allowed time. Can be safely retried. May be returned even if the operation has completed successfully",
                  "title": "DEADLINE_EXCEEDED"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPISmartContracts"
        ],
        "x-section": "Smart contracts",
        "x-release-info": {
          "noticeVersion": {
            "major": 1,
            "minor": 12
          },
          "releaseVersion": {
            "major": 5
          },
          "changeType": "REMOVE_METHOD",
          "description": "This method is deprecated in favour of /v1/contracts:simulate"
        },
        "x-permission-scopes": [
          "core:execute",
          "core.smart_contracts:execute"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/smart_contractsSimulateExistingAccountRequest"
        }
      }
    },
    "/v1/supervisor-contract-versions": {
      "get": {
        "summary": "Lists Supervisor Contract Versions.",
        "operationId": "ListSupervisorContractVersions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/supervisor_contractsListSupervisorContractVersionsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The Supervisor Contract ID to retrieve values for.\n\nRequired.",
            "name": "supervisor_contract_id",
            "in": "query",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "description": "Additional fields to return; optional. Some Supervisor Contract Version fields are omitted by default as they are bulky or costly; if those fields are specified here, they will be populated in the response.",
            "name": "fields_to_include",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "INCLUDE_FIELD_DETAILS_API_VERSION",
                  "INCLUDE_FIELD_DETAILS_NOTIFICATION_TYPES"
                ]
              }
            }
          },
          {
            "description": "The number of Supervisor Contract Versions to be retrieved.\n\nRequired.\nMin value: 1.\nMax value: 50.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "The token of the page the results are to be retrieved from. If empty, this returns the first page of results.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPISupervisorContracts"
        ],
        "x-section": "Supervisor Contracts",
        "x-release-info": {
          "releaseVersion": {
            "major": 2
          },
          "changeType": "ADD_METHOD"
        },
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.supervisor_contract_versions:read"
        ]
      },
      "post": {
        "summary": "Creates a Supervisor Contract Version.",
        "operationId": "CreateSupervisorContractVersion",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/supervisor_contractsSupervisorContractVersion"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPISupervisorContracts"
        ],
        "x-section": "Supervisor Contracts",
        "x-release-info": {
          "releaseVersion": {
            "major": 1,
            "minor": 9
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:write",
          "core.supervisor_contract_versions:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/supervisor_contractsCreateSupervisorContractVersionRequest"
        }
      }
    },
    "/v1/supervisor-contract-versions:batchGet": {
      "get": {
        "summary": "Retrieves one or more Supervisor Contract Versions using the Supervisor Contract Version ID.",
        "operationId": "BatchGetSupervisorContractVersions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/supervisor_contractsBatchGetSupervisorContractVersionsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "List of IDs of the Supervisor Contract Versions to retrieve.",
            "name": "ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "description": "Additional fields to return; optional. Some Supervisor Contract Version fields are omitted by default as they are bulky or costly; if those fields are specified here, they will be populated in the response.",
            "name": "fields_to_include",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "enum": [
                  "INCLUDE_FIELD_CODE",
                  "INCLUDE_FIELD_DETAILS_API_VERSION",
                  "INCLUDE_FIELD_DETAILS_NOTIFICATION_TYPES"
                ]
              }
            }
          }
        ],
        "tags": [
          "CoreAPISupervisorContracts"
        ],
        "x-section": "Supervisor Contracts",
        "x-release-info": {
          "releaseVersion": {
            "major": 1,
            "minor": 9
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:read",
          "core.supervisor_contract_versions:read"
        ]
      }
    },
    "/v1/supervisor-contracts": {
      "get": {
        "summary": "Lists Supervisor Contracts.",
        "operationId": "ListSupervisorContracts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/supervisor_contractsListSupervisorContractsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "The number of Supervisor Contracts to be retrieved.\n\nRequired.\nMin value: 1.\nMax value: 50.",
            "name": "page_size",
            "in": "query",
            "required": true,
            "schema": {
              "type": "integer",
              "format": "int64"
            }
          },
          {
            "description": "The token of the page the results are to be retrieved from. If empty, this returns the first page of results.",
            "name": "page_token",
            "in": "query",
            "required": false,
            "schema": {
              "type": "string"
            }
          }
        ],
        "tags": [
          "CoreAPISupervisorContracts"
        ],
        "x-section": "Supervisor Contracts",
        "x-release-info": {
          "releaseVersion": {
            "major": 2
          },
          "changeType": "ADD_METHOD"
        },
        "x-list-consistency-level": "BEST_EFFORT",
        "x-permission-scopes": [
          "core:read",
          "core.supervisor_contracts:read"
        ]
      },
      "post": {
        "summary": "Creates a Supervisor Contract.",
        "operationId": "CreateSupervisorContract",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/supervisor_contractsSupervisorContract"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPISupervisorContracts"
        ],
        "x-section": "Supervisor Contracts",
        "x-release-info": {
          "releaseVersion": {
            "major": 1,
            "minor": 9
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:write",
          "core.supervisor_contracts:write"
        ],
        "requestBody": {
          "$ref": "#/components/requestBodies/supervisor_contractsCreateSupervisorContractRequest"
        }
      }
    },
    "/v1/supervisor-contracts:batchGet": {
      "get": {
        "summary": "Retrieves one or more Supervisor Contracts using the Supervisor Contract ID.",
        "operationId": "BatchGetSupervisorContracts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/supervisor_contractsBatchGetSupervisorContractsResponse"
                }
              }
            }
          }
        },
        "parameters": [
          {
            "description": "List of IDs of the Supervisor Contracts to retrieve.",
            "name": "ids",
            "in": "query",
            "required": false,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          }
        ],
        "tags": [
          "CoreAPISupervisorContracts"
        ],
        "x-section": "Supervisor Contracts",
        "x-release-info": {
          "releaseVersion": {
            "major": 1,
            "minor": 9
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:read",
          "core.supervisor_contracts:read"
        ]
      }
    },
    "/v1/vault-version": {
      "get": {
        "summary": "Get Vault Version",
        "operationId": "GetVaultVersion",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "application/json": {
                "schema": {
                  "$ref": "#/components/schemas/vaultversionVaultVersion"
                }
              }
            }
          }
        },
        "tags": [
          "CoreAPIVaultVersion"
        ],
        "x-section": "Vault Version",
        "x-release-info": {
          "releaseVersion": {
            "major": 3
          },
          "changeType": "ADD_METHOD"
        },
        "x-permission-scopes": [
          "core:read",
          "core.vault_versions:read"
        ]
      }
    }
  },
  "x-sections": {
    "Account schedule tags": {
      "releaseNotes": {
        "changeType": "ADD_SERVICE",
        "featureFlag": "KERN_399_ACCOUNT_SCHEDULE_TAGS_API"
      }
    },
    "Accounts": {},
    "Auth": {},
    "Balances": {},
    "Calendar": {},
    "Contract Modules": {
      "releaseNotes": {
        "changeType": "ADD_SERVICE"
      }
    },
    "Contracts": {
      "releaseNotes": {
        "releaseVersion": {
          "major": 1,
          "minor": 12
        },
        "changeType": "ADD_SERVICE"
      }
    },
    "Customers": {},
    "Journal Events": {
      "releaseNotes": {
        "releaseVersion": {
          "major": 4,
          "minor": 2
        },
        "changeType": "ADD_SERVICE",
        "featureFlag": "TM_69164_REPLAY_EVENTS"
      }
    },
    "Flags": {},
    "Global parameters": {},
    "Internal accounts": {},
    "LedgerBalances": {},
    "Payment devices": {},
    "Payment orders": {},
    "Plans": {},
    "Policy Management": {
      "releaseNotes": {
        "releaseVersion": {
          "major": 4,
          "minor": 3
        },
        "changeType": "ADD_SERVICE",
        "featureFlag": "TM_67736_AUTH_2_0_AUTHENTICATION"
      }
    },
    "Post Posting Republisher": {
      "releaseNotes": {
        "releaseVersion": {
          "major": 4,
          "minor": 2
        },
        "changeType": "ADD_SERVICE",
        "featureFlag": "TM_69579_POST_POSTING_RETRYABILITY"
      }
    },
    "Posting instruction batches": {},
    "Postings API clients": {},
    "Products": {},
    "Restrictions": {},
    "Scheduler": {},
    "Smart contracts": {
      "releaseNotes": {
        "noticeVersion": {
          "major": 1,
          "minor": 12
        },
        "releaseVersion": {
          "major": 5
        },
        "changeType": "REMOVE_SERVICE",
        "description": "These endpoints will be replaced by a new Simulation feature."
      }
    },
    "Supervisor Contracts": {
      "releaseNotes": {
        "releaseVersion": {
          "major": 1,
          "minor": 9
        },
        "changeType": "ADD_SERVICE"
      }
    },
    "Vault Version": {
      "releaseNotes": {
        "releaseVersion": {
          "major": 3
        },
        "changeType": "ADD_SERVICE"
      }
    }
  },
  "openapi": "3.0.1",
  "components": {
    "schemas": {
      "BadRequestFieldViolation": {
        "type": "object",
        "properties": {
          "field": {
            "type": "string",
            "description": "A path leading to a field in the request body. The value will be a sequence of dot-separated identifiers that identify a protocol buffer field. E.g., \"resource.field\" would identify this field."
          },
          "violation_type": {
            "$ref": "#/components/schemas/BadRequestViolationType",
            "description": "Type of violation."
          },
          "description": {
            "type": "string",
            "description": "A description of why the request element is improper."
          }
        },
        "description": "A message type used to describe a single bad request field."
      },
      "BadRequestViolationType": {
        "type": "string",
        "enum": [
          "UNKNOWN",
          "INVALID_FORMAT",
          "INVALID_VALUE",
          "ABOVE_MAX_VALUE",
          "BELOW_MIN_VALUE",
          "ABOVE_MAX_LENGTH",
          "BELOW_MIN_LENGTH",
          "PATTERN_MISMATCH",
          "PREFIX_MISMATCH",
          "SUFFIX_MISMATCH",
          "REQUIRED_FIELD",
          "DUPLICATE_VALUE"
        ],
        "default": "UNKNOWN",
        "title": "A global list of field violation types",
        "x-enum-value-descriptions": {
          "ABOVE_MAX_LENGTH": "Length is larger than a maximum specified size.",
          "ABOVE_MAX_VALUE": "Field exceeds a maximum specified value.",
          "BELOW_MIN_LENGTH": "Length is smaller than a minimum specified size.",
          "BELOW_MIN_VALUE": "Field is smaller than a minimum specified value.",
          "DUPLICATE_VALUE": "All elements in this field must be unique but a duplicate value has been provided. Applies to repeated scalar fields.",
          "INVALID_FORMAT": "Field is not a valid format e.g. email address, UUID, IP Address, URI etc.",
          "INVALID_VALUE": "Indicates that a provided field is not equal to one of the specified values.",
          "PATTERN_MISMATCH": "Field value does not match the specified regex pattern.",
          "PREFIX_MISMATCH": "Field value does not match the specified prefix.",
          "REQUIRED_FIELD": "Field value was not populated but is required to be.",
          "SUFFIX_MISMATCH": "Field value does not match the specified suffix.",
          "UNKNOWN": "Default value."
        }
      },
      "BatchGetAccountConfigEntitiesNOT_FOUND_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "NOT_FOUND"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsResourceInfo",
                  "title": "ResourceInfo"
                }
              ]
            }
          }
        }
      },
      "BatchGetAccountConfigGroupsNOT_FOUND_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "NOT_FOUND"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsResourceInfo",
                  "title": "ResourceInfo"
                }
              ]
            }
          }
        }
      },
      "CoreAPIAccountConfigHierarchyINVALID_ARGUMENT_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "INVALID_ARGUMENT"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsBadRequest",
                  "title": "BadRequest"
                }
              ]
            }
          }
        }
      },
      "CreateAccountConfigEntityALREADY_EXISTS_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "ALREADY_EXISTS"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsResourceInfo",
                  "title": "ResourceInfo"
                }
              ]
            }
          }
        }
      },
      "CreateAccountConfigEntityFAILED_PRECONDITION_1": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "FAILED_PRECONDITION"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsPreconditionFailureCreateAccountConfigEntityFAILED_PRECONDITION_1",
                  "title": "PreconditionFailure"
                }
              ]
            }
          }
        }
      },
      "CreateAccountConfigGroupALREADY_EXISTS_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "ALREADY_EXISTS"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsResourceInfo",
                  "title": "ResourceInfo"
                }
              ]
            }
          }
        }
      },
      "CreateAccountConfigGroupFAILED_PRECONDITION_1": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "FAILED_PRECONDITION"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsPreconditionFailureCreateAccountConfigGroupFAILED_PRECONDITION_1",
                  "title": "PreconditionFailure"
                }
              ]
            }
          }
        }
      },
      "GlobalErrorsDEADLINE_EXCEEDED_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "DEADLINE_EXCEEDED"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          }
        }
      },
      "GlobalErrorsINTERNAL_1": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "INTERNAL"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          }
        }
      },
      "GlobalErrorsRESOURCE_EXHAUSTED_2": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "RESOURCE_EXHAUSTED"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          }
        }
      },
      "GlobalErrorsUNAVAILABLE_3": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "UNAVAILABLE"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          }
        }
      },
      "GlobalErrorsUNKNOWN_4": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "UNKNOWN"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          }
        }
      },
      "PreconditionFailureViolation": {
        "type": "object",
        "properties": {
          "violation_type": {
            "type": "string",
            "title": "A set of canonical violation types that can be used by API client to programmatically handle the error. A resource or API specific enum type must be defined for the supported precondition violation subjects. e.g. enum DirectDebitPreconditionFailureTypes {     UNKNOWN               = 0; // string representation: \"UNKNOWN\"     BANK_ACCOUNT_DISABLED = 1; // string representation: \"BANK_ACCOUNT_DISABLED\"     MANDATE_INACTIVE      = 2; // string representation: \"MANDATE_INACTIVE\" }"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional structured details about this error.\n\nKeys should match /[a-zA-Z0-9-_]/ and be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than {\"instance_limit\": \"100/request\"}, should be returned as, {\"instance_limit_per_request\": \"100\"}, if the client exceeds the number of instances that can be created in a single (batch) request."
          }
        },
        "description": "A message type used to describe a single precondition failure."
      },
      "PreconditionFailureViolationCreateAccountConfigEntityFAILED_PRECONDITION_1": {
        "type": "object",
        "properties": {
          "violation_type": {
            "type": "string",
            "title": "A set of canonical violation types that can be used by API client to programmatically handle the error. A resource or API specific enum type must be defined for the supported precondition violation subjects. e.g. enum DirectDebitPreconditionFailureTypes {     UNKNOWN               = 0; // string representation: \"UNKNOWN\"     BANK_ACCOUNT_DISABLED = 1; // string representation: \"BANK_ACCOUNT_DISABLED\"     MANDATE_INACTIVE      = 2; // string representation: \"MANDATE_INACTIVE\" }",
            "x-example-override": "PARENT_GROUP_NOT_FOUND"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional structured details about this error.\n\nKeys should match /[a-zA-Z0-9-_]/ and be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than {\"instance_limit\": \"100/request\"}, should be returned as, {\"instance_limit_per_request\": \"100\"}, if the client exceeds the number of instances that can be created in a single (batch) request.",
            "x-example-override": "{}"
          }
        },
        "description": "A message type used to describe a single precondition failure."
      },
      "PreconditionFailureViolationCreateAccountConfigGroupFAILED_PRECONDITION_1": {
        "type": "object",
        "properties": {
          "violation_type": {
            "type": "string",
            "title": "A set of canonical violation types that can be used by API client to programmatically handle the error. A resource or API specific enum type must be defined for the supported precondition violation subjects. e.g. enum DirectDebitPreconditionFailureTypes {     UNKNOWN               = 0; // string representation: \"UNKNOWN\"     BANK_ACCOUNT_DISABLED = 1; // string representation: \"BANK_ACCOUNT_DISABLED\"     MANDATE_INACTIVE      = 2; // string representation: \"MANDATE_INACTIVE\" }",
            "x-example-override": "PARENT_GROUP_NOT_FOUND"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional structured details about this error.\n\nKeys should match /[a-zA-Z0-9-_]/ and be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than {\"instance_limit\": \"100/request\"}, should be returned as, {\"instance_limit_per_request\": \"100\"}, if the client exceeds the number of instances that can be created in a single (batch) request.",
            "x-example-override": "{}"
          }
        },
        "description": "A message type used to describe a single precondition failure."
      },
      "PreconditionFailureViolationUpdateAccountConfigEntityFAILED_PRECONDITION_1": {
        "type": "object",
        "properties": {
          "violation_type": {
            "type": "string",
            "title": "A set of canonical violation types that can be used by API client to programmatically handle the error. A resource or API specific enum type must be defined for the supported precondition violation subjects. e.g. enum DirectDebitPreconditionFailureTypes {     UNKNOWN               = 0; // string representation: \"UNKNOWN\"     BANK_ACCOUNT_DISABLED = 1; // string representation: \"BANK_ACCOUNT_DISABLED\"     MANDATE_INACTIVE      = 2; // string representation: \"MANDATE_INACTIVE\" }",
            "x-example-override": "PARENT_GROUP_NOT_FOUND"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional structured details about this error.\n\nKeys should match /[a-zA-Z0-9-_]/ and be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than {\"instance_limit\": \"100/request\"}, should be returned as, {\"instance_limit_per_request\": \"100\"}, if the client exceeds the number of instances that can be created in a single (batch) request.",
            "x-example-override": "{}"
          }
        },
        "description": "A message type used to describe a single precondition failure."
      },
      "PreconditionFailureViolationUpdateAccountConfigGroupFAILED_PRECONDITION_1": {
        "type": "object",
        "properties": {
          "violation_type": {
            "type": "string",
            "title": "A set of canonical violation types that can be used by API client to programmatically handle the error. A resource or API specific enum type must be defined for the supported precondition violation subjects. e.g. enum DirectDebitPreconditionFailureTypes {     UNKNOWN               = 0; // string representation: \"UNKNOWN\"     BANK_ACCOUNT_DISABLED = 1; // string representation: \"BANK_ACCOUNT_DISABLED\"     MANDATE_INACTIVE      = 2; // string representation: \"MANDATE_INACTIVE\" }",
            "x-example-override": "PARENT_GROUP_NOT_FOUND"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional structured details about this error.\n\nKeys should match /[a-zA-Z0-9-_]/ and be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than {\"instance_limit\": \"100/request\"}, should be returned as, {\"instance_limit_per_request\": \"100\"}, if the client exceeds the number of instances that can be created in a single (batch) request.",
            "x-example-override": "{}"
          }
        },
        "description": "A message type used to describe a single precondition failure."
      },
      "PreconditionFailureViolationUpdateAccountConfigGroupFAILED_PRECONDITION_2": {
        "type": "object",
        "properties": {
          "violation_type": {
            "type": "string",
            "title": "A set of canonical violation types that can be used by API client to programmatically handle the error. A resource or API specific enum type must be defined for the supported precondition violation subjects. e.g. enum DirectDebitPreconditionFailureTypes {     UNKNOWN               = 0; // string representation: \"UNKNOWN\"     BANK_ACCOUNT_DISABLED = 1; // string representation: \"BANK_ACCOUNT_DISABLED\"     MANDATE_INACTIVE      = 2; // string representation: \"MANDATE_INACTIVE\" }",
            "x-example-override": "HIERARCHY_CYCLE"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional structured details about this error.\n\nKeys should match /[a-zA-Z0-9-_]/ and be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than {\"instance_limit\": \"100/request\"}, should be returned as, {\"instance_limit_per_request\": \"100\"}, if the client exceeds the number of instances that can be created in a single (batch) request.",
            "x-example-override": "{}"
          }
        },
        "description": "A message type used to describe a single precondition failure."
      },
      "PublicAPIErrorsPERMISSION_DENIED_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "PERMISSION_DENIED"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          }
        }
      },
      "PublicAPIErrorsUNAUTHENTICATED_1": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "UNAUTHENTICATED"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          }
        }
      },
      "UpdateAccountConfigEntityFAILED_PRECONDITION_1": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "FAILED_PRECONDITION"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsPreconditionFailureUpdateAccountConfigEntityFAILED_PRECONDITION_1",
                  "title": "PreconditionFailure"
                }
              ]
            }
          }
        }
      },
      "UpdateAccountConfigEntityNOT_FOUND_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "NOT_FOUND"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsResourceInfo",
                  "title": "ResourceInfo"
                }
              ]
            }
          }
        }
      },
      "UpdateAccountConfigGroupFAILED_PRECONDITION_1": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "FAILED_PRECONDITION"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsPreconditionFailureUpdateAccountConfigGroupFAILED_PRECONDITION_1",
                  "title": "PreconditionFailure"
                }
              ]
            }
          }
        }
      },
      "UpdateAccountConfigGroupFAILED_PRECONDITION_2": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "FAILED_PRECONDITION"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsPreconditionFailureUpdateAccountConfigGroupFAILED_PRECONDITION_2",
                  "title": "PreconditionFailure"
                }
              ]
            }
          }
        }
      },
      "UpdateAccountConfigGroupNOT_FOUND_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "NOT_FOUND"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsResourceInfo",
                  "title": "ResourceInfo"
                }
              ]
            }
          }
        }
      },
      "boolean_filterNullableBooleanFilter": {
        "type": "string",
        "enum": [
          "BOTH",
          "ONLY_TRUE",
          "ONLY_FALSE"
        ],
        "default": "BOTH"
      },
      "errorsBadRequest": {
        "type": "object",
        "properties": {
          "@type": {
            "type": "string",
            "description": "A type name to identify this detail.",
            "x-example-override": "http://type.googleapis.com/errors.BadRequest"
          },
          "field_violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/BadRequestFieldViolation"
            },
            "description": "Describes all violations in a client request."
          }
        },
        "description": "Describes violations in a client request. This error type focuses on the syntactic aspects of the request."
      },
      "errorsPreconditionFailure": {
        "type": "object",
        "properties": {
          "@type": {
            "type": "string",
            "description": "A type name to identify this detail.",
            "x-example-override": "http://type.googleapis.com/errors.PreconditionFailure"
          },
          "violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PreconditionFailureViolation"
            },
            "description": "Describes all precondition violations."
          }
        },
        "description": "Describes what preconditions have failed.\n\nFor example, if creating a direct debit failed because bank account validation failed, it could list the account violation in the PreconditionFailure message."
      },
      "errorsPreconditionFailureCreateAccountConfigEntityFAILED_PRECONDITION_1": {
        "type": "object",
        "properties": {
          "@type": {
            "type": "string",
            "description": "A type name to identify this detail.",
            "x-example-override": "http://type.googleapis.com/errors.PreconditionFailure"
          },
          "violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PreconditionFailureViolationCreateAccountConfigEntityFAILED_PRECONDITION_1"
            },
            "description": "Describes all precondition violations."
          }
        },
        "description": "Describes what preconditions have failed.\n\nFor example, if creating a direct debit failed because bank account validation failed, it could list the account violation in the PreconditionFailure message."
      },
      "errorsPreconditionFailureCreateAccountConfigGroupFAILED_PRECONDITION_1": {
        "type": "object",
        "properties": {
          "@type": {
            "type": "string",
            "description": "A type name to identify this detail.",
            "x-example-override": "http://type.googleapis.com/errors.PreconditionFailure"
          },
          "violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PreconditionFailureViolationCreateAccountConfigGroupFAILED_PRECONDITION_1"
            },
            "description": "Describes all precondition violations."
          }
        },
        "description": "Describes what preconditions have failed.\n\nFor example, if creating a direct debit failed because bank account validation failed, it could list the account violation in the PreconditionFailure message."
      },
      "errorsPreconditionFailureUpdateAccountConfigEntityFAILED_PRECONDITION_1": {
        "type": "object",
        "properties": {
          "@type": {
            "type": "string",
            "description": "A type name to identify this detail.",
            "x-example-override": "http://type.googleapis.com/errors.PreconditionFailure"
          },
          "violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PreconditionFailureViolationUpdateAccountConfigEntityFAILED_PRECONDITION_1"
            },
            "description": "Describes all precondition violations."
          }
        },
        "description": "Describes what preconditions have failed.\n\nFor example, if creating a direct debit failed because bank account validation failed, it could list the account violation in the PreconditionFailure message."
      },
      "errorsPreconditionFailureUpdateAccountConfigGroupFAILED_PRECONDITION_1": {
        "type": "object",
        "properties": {
          "@type": {
            "type": "string",
            "description": "A type name to identify this detail.",
            "x-example-override": "http://type.googleapis.com/errors.PreconditionFailure"
          },
          "violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PreconditionFailureViolationUpdateAccountConfigGroupFAILED_PRECONDITION_1"
            },
            "description": "Describes all precondition violations."
          }
        },
        "description": "Describes what preconditions have failed.\n\nFor example, if creating a direct debit failed because bank account validation failed, it could list the account violation in the PreconditionFailure message."
      },
      "errorsPreconditionFailureUpdateAccountConfigGroupFAILED_PRECONDITION_2": {
        "type": "object",
        "properties": {
          "@type": {
            "type": "string",
            "description": "A type name to identify this detail.",
            "x-example-override": "http://type.googleapis.com/errors.PreconditionFailure"
          },
          "violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PreconditionFailureViolationUpdateAccountConfigGroupFAILED_PRECONDITION_2"
            },
            "description": "Describes all precondition violations."
          }
        },
        "description": "Describes what preconditions have failed.\n\nFor example, if creating a direct debit failed because bank account validation failed, it could list the account violation in the PreconditionFailure message."
      },
      "errorsResourceInfo": {
        "type": "object",
        "properties": {
          "@type": {
            "type": "string",
            "description": "A type name to identify this detail.",
            "x-example-override": "http://type.googleapis.com/errors.ResourceInfo"
          },
          "resource_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The identifier of the resources being accessed."
          }
        },
        "description": "Describes the resources being accessed."
      },
      "protobufFieldMask": {
        "type": "object",
        "properties": {
          "paths": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The set of field mask paths."
          }
        },
        "description": "\"paths\": [\"f.a\", \"f.b.d\"]\n\nHere `f` represents a field in some root message, `a` and `b` fields in the message found in `f`, and `d` a field found in the message in `f.b`.\n\nFields are represented by their JSON field names.\n\n   \"paths\": [\"f.field1\", \"f.field_on_f.some_field_name\"]\n\nField masks are used to specify a subset of fields that should be, or have been, modified by an update operation.\n\nField masks are JSON encoding as a string array.",
        "title": "FieldMask represents a set of symbolic field paths, for example:"
      },
      "BatchGetParameterValuesNOT_FOUND_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "NOT_FOUND"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsResourceInfo",
                  "title": "ResourceInfo"
                }
              ]
            }
          }
        }
      },
      "BatchGetParametersNOT_FOUND_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "NOT_FOUND"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsResourceInfo",
                  "title": "ResourceInfo"
                }
              ]
            }
          }
        }
      },
      "CoreAPIParametersINVALID_ARGUMENT_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "INVALID_ARGUMENT"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsBadRequest",
                  "title": "BadRequest"
                }
              ]
            }
          }
        }
      },
      "CreateParameterALREADY_EXISTS_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "ALREADY_EXISTS"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsResourceInfo",
                  "title": "ResourceInfo"
                }
              ]
            }
          }
        }
      },
      "CreateParameterValueFAILED_PRECONDITION_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "FAILED_PRECONDITION"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsPreconditionFailureCreateParameterValueFAILED_PRECONDITION_0",
                  "title": "PreconditionFailure"
                }
              ]
            }
          }
        }
      },
      "CreateParameterValueFAILED_PRECONDITION_1": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "FAILED_PRECONDITION"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsPreconditionFailureCreateParameterValueFAILED_PRECONDITION_1",
                  "title": "PreconditionFailure"
                }
              ]
            }
          }
        }
      },
      "CreateParameterValueFAILED_PRECONDITION_2": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "FAILED_PRECONDITION"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsPreconditionFailureCreateParameterValueFAILED_PRECONDITION_2",
                  "title": "PreconditionFailure"
                }
              ]
            }
          }
        }
      },
      "CreateParameterValueFAILED_PRECONDITION_3": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "FAILED_PRECONDITION"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsPreconditionFailureCreateParameterValueFAILED_PRECONDITION_3",
                  "title": "PreconditionFailure"
                }
              ]
            }
          }
        }
      },
      "DateOffsetConstraintMinMax": {
        "type": "object",
        "properties": {
          "min": {
            "type": "integer",
            "format": "int32",
            "description": "Minimum valid offset. Defaults to zero."
          },
          "max": {
            "type": "integer",
            "format": "int32",
            "description": "Maximum valid offset. Defaults to zero."
          }
        }
      },
      "DateTimeConstraintPrecision": {
        "type": "string",
        "enum": [
          "MINUTE",
          "DAY"
        ],
        "default": "MINUTE",
        "x-enum-value-descriptions": {
          "DAY": "Up to YYYY-MM-DD can be specified.",
          "MINUTE": "Up to YYYY-MM-DD HH:mm can be specified. Default."
        }
      },
      "PreconditionFailureViolationCreateParameterValueFAILED_PRECONDITION_0": {
        "type": "object",
        "properties": {
          "violation_type": {
            "type": "string",
            "title": "A set of canonical violation types that can be used by API client to programmatically handle the error. A resource or API specific enum type must be defined for the supported precondition violation subjects. e.g. enum DirectDebitPreconditionFailureTypes {     UNKNOWN               = 0; // string representation: \"UNKNOWN\"     BANK_ACCOUNT_DISABLED = 1; // string representation: \"BANK_ACCOUNT_DISABLED\"     MANDATE_INACTIVE      = 2; // string representation: \"MANDATE_INACTIVE\" }",
            "x-example-override": "COINCIDENT_PARAMETER_VALUE"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional structured details about this error.\n\nKeys should match /[a-zA-Z0-9-_]/ and be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than {\"instance_limit\": \"100/request\"}, should be returned as, {\"instance_limit_per_request\": \"100\"}, if the client exceeds the number of instances that can be created in a single (batch) request.",
            "x-example-override": "{\"parameter_value.id\":\"value\"}",
            "x-metadata-release-info": [
              {
                "key": "parameter_value.id",
                "description": "The id of the ParameterValue that was coincident with the Parameter Value being created."
              }
            ]
          }
        },
        "description": "A message type used to describe a single precondition failure."
      },
      "PreconditionFailureViolationCreateParameterValueFAILED_PRECONDITION_1": {
        "type": "object",
        "properties": {
          "violation_type": {
            "type": "string",
            "title": "A set of canonical violation types that can be used by API client to programmatically handle the error. A resource or API specific enum type must be defined for the supported precondition violation subjects. e.g. enum DirectDebitPreconditionFailureTypes {     UNKNOWN               = 0; // string representation: \"UNKNOWN\"     BANK_ACCOUNT_DISABLED = 1; // string representation: \"BANK_ACCOUNT_DISABLED\"     MANDATE_INACTIVE      = 2; // string representation: \"MANDATE_INACTIVE\" }",
            "x-example-override": "OVERLAPS_EXPLICIT_PARAMETER_VALUE_EFFECTIVE_TIMESTAMP_RANGE"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional structured details about this error.\n\nKeys should match /[a-zA-Z0-9-_]/ and be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than {\"instance_limit\": \"100/request\"}, should be returned as, {\"instance_limit_per_request\": \"100\"}, if the client exceeds the number of instances that can be created in a single (batch) request.",
            "x-example-override": "{\"parameter_value.effective_from_timestamp\":\"value\",\"parameter_value.effective_to_timestamp\":\"value\",\"parameter_value.id\":\"value\"}",
            "x-metadata-release-info": [
              {
                "key": "parameter_value.id",
                "description": "The id of the ParameterValue that overlaps."
              },
              {
                "key": "parameter_value.effective_from_timestamp",
                "description": "The effective_from_timestamp of the ParameterValue that overlaps."
              },
              {
                "key": "parameter_value.effective_to_timestamp",
                "description": "The effective_to_timestamp of the ParameterValue that overlaps."
              }
            ]
          }
        },
        "description": "A message type used to describe a single precondition failure."
      },
      "PreconditionFailureViolationCreateParameterValueFAILED_PRECONDITION_2": {
        "type": "object",
        "properties": {
          "violation_type": {
            "type": "string",
            "title": "A set of canonical violation types that can be used by API client to programmatically handle the error. A resource or API specific enum type must be defined for the supported precondition violation subjects. e.g. enum DirectDebitPreconditionFailureTypes {     UNKNOWN               = 0; // string representation: \"UNKNOWN\"     BANK_ACCOUNT_DISABLED = 1; // string representation: \"BANK_ACCOUNT_DISABLED\"     MANDATE_INACTIVE      = 2; // string representation: \"MANDATE_INACTIVE\" }",
            "x-example-override": "MISSING_OWNER"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional structured details about this error.\n\nKeys should match /[a-zA-Z0-9-_]/ and be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than {\"instance_limit\": \"100/request\"}, should be returned as, {\"instance_limit_per_request\": \"100\"}, if the client exceeds the number of instances that can be created in a single (batch) request.",
            "x-example-override": "{}"
          }
        },
        "description": "A message type used to describe a single precondition failure."
      },
      "PreconditionFailureViolationCreateParameterValueFAILED_PRECONDITION_3": {
        "type": "object",
        "properties": {
          "violation_type": {
            "type": "string",
            "title": "A set of canonical violation types that can be used by API client to programmatically handle the error. A resource or API specific enum type must be defined for the supported precondition violation subjects. e.g. enum DirectDebitPreconditionFailureTypes {     UNKNOWN               = 0; // string representation: \"UNKNOWN\"     BANK_ACCOUNT_DISABLED = 1; // string representation: \"BANK_ACCOUNT_DISABLED\"     MANDATE_INACTIVE      = 2; // string representation: \"MANDATE_INACTIVE\" }",
            "x-example-override": "MISSING_PARAMETER"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional structured details about this error.\n\nKeys should match /[a-zA-Z0-9-_]/ and be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than {\"instance_limit\": \"100/request\"}, should be returned as, {\"instance_limit_per_request\": \"100\"}, if the client exceeds the number of instances that can be created in a single (batch) request.",
            "x-example-override": "{}"
          }
        },
        "description": "A message type used to describe a single precondition failure."
      },
      "PreconditionFailureViolationUpdateParameterValueFAILED_PRECONDITION_1": {
        "type": "object",
        "properties": {
          "violation_type": {
            "type": "string",
            "title": "A set of canonical violation types that can be used by API client to programmatically handle the error. A resource or API specific enum type must be defined for the supported precondition violation subjects. e.g. enum DirectDebitPreconditionFailureTypes {     UNKNOWN               = 0; // string representation: \"UNKNOWN\"     BANK_ACCOUNT_DISABLED = 1; // string representation: \"BANK_ACCOUNT_DISABLED\"     MANDATE_INACTIVE      = 2; // string representation: \"MANDATE_INACTIVE\" }",
            "x-example-override": "ALREADY_EFFECTIVE_PARAMETER_VALUE"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional structured details about this error.\n\nKeys should match /[a-zA-Z0-9-_]/ and be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than {\"instance_limit\": \"100/request\"}, should be returned as, {\"instance_limit_per_request\": \"100\"}, if the client exceeds the number of instances that can be created in a single (batch) request.",
            "x-example-override": "{\"parameter_value.effective_from_timestamp\":\"value\"}",
            "x-metadata-release-info": [
              {
                "key": "parameter_value.effective_from_timestamp",
                "description": "The effective_from_timestamp of the ParameterValue."
              }
            ]
          }
        },
        "description": "A message type used to describe a single precondition failure."
      },
      "PreconditionFailureViolationUpdateParameterValueFAILED_PRECONDITION_2": {
        "type": "object",
        "properties": {
          "violation_type": {
            "type": "string",
            "title": "A set of canonical violation types that can be used by API client to programmatically handle the error. A resource or API specific enum type must be defined for the supported precondition violation subjects. e.g. enum DirectDebitPreconditionFailureTypes {     UNKNOWN               = 0; // string representation: \"UNKNOWN\"     BANK_ACCOUNT_DISABLED = 1; // string representation: \"BANK_ACCOUNT_DISABLED\"     MANDATE_INACTIVE      = 2; // string representation: \"MANDATE_INACTIVE\" }",
            "x-example-override": "CANCELLED_PARAMETER_VALUE"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional structured details about this error.\n\nKeys should match /[a-zA-Z0-9-_]/ and be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than {\"instance_limit\": \"100/request\"}, should be returned as, {\"instance_limit_per_request\": \"100\"}, if the client exceeds the number of instances that can be created in a single (batch) request.",
            "x-example-override": "{\"cancelled_timestamp\":\"value\"}",
            "x-metadata-release-info": [
              {
                "key": "cancelled_timestamp",
                "description": "The time that the ParameterValue was cancelled."
              }
            ]
          }
        },
        "description": "A message type used to describe a single precondition failure."
      },
      "PreconditionFailureViolationUpdateParameterValueFAILED_PRECONDITION_3": {
        "type": "object",
        "properties": {
          "violation_type": {
            "type": "string",
            "title": "A set of canonical violation types that can be used by API client to programmatically handle the error. A resource or API specific enum type must be defined for the supported precondition violation subjects. e.g. enum DirectDebitPreconditionFailureTypes {     UNKNOWN               = 0; // string representation: \"UNKNOWN\"     BANK_ACCOUNT_DISABLED = 1; // string representation: \"BANK_ACCOUNT_DISABLED\"     MANDATE_INACTIVE      = 2; // string representation: \"MANDATE_INACTIVE\" }",
            "x-example-override": "NEW_EFFECTIVE_TO_TIMESTAMP_IN_PAST"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional structured details about this error.\n\nKeys should match /[a-zA-Z0-9-_]/ and be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than {\"instance_limit\": \"100/request\"}, should be returned as, {\"instance_limit_per_request\": \"100\"}, if the client exceeds the number of instances that can be created in a single (batch) request.",
            "x-example-override": "{}"
          }
        },
        "description": "A message type used to describe a single precondition failure."
      },
      "PreconditionFailureViolationUpdateParameterValueFAILED_PRECONDITION_4": {
        "type": "object",
        "properties": {
          "violation_type": {
            "type": "string",
            "title": "A set of canonical violation types that can be used by API client to programmatically handle the error. A resource or API specific enum type must be defined for the supported precondition violation subjects. e.g. enum DirectDebitPreconditionFailureTypes {     UNKNOWN               = 0; // string representation: \"UNKNOWN\"     BANK_ACCOUNT_DISABLED = 1; // string representation: \"BANK_ACCOUNT_DISABLED\"     MANDATE_INACTIVE      = 2; // string representation: \"MANDATE_INACTIVE\" }",
            "x-example-override": "EXPIRED_PARAMETER_VALUE"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional structured details about this error.\n\nKeys should match /[a-zA-Z0-9-_]/ and be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than {\"instance_limit\": \"100/request\"}, should be returned as, {\"instance_limit_per_request\": \"100\"}, if the client exceeds the number of instances that can be created in a single (batch) request.",
            "x-example-override": "{\"parameter_value.effective_to_timestamp\":\"value\"}",
            "x-metadata-release-info": [
              {
                "key": "parameter_value.effective_to_timestamp",
                "description": "The time that the ParameterValue expired."
              }
            ]
          }
        },
        "description": "A message type used to describe a single precondition failure."
      },
      "PreconditionFailureViolationUpdateParameterValueFAILED_PRECONDITION_5": {
        "type": "object",
        "properties": {
          "violation_type": {
            "type": "string",
            "title": "A set of canonical violation types that can be used by API client to programmatically handle the error. A resource or API specific enum type must be defined for the supported precondition violation subjects. e.g. enum DirectDebitPreconditionFailureTypes {     UNKNOWN               = 0; // string representation: \"UNKNOWN\"     BANK_ACCOUNT_DISABLED = 1; // string representation: \"BANK_ACCOUNT_DISABLED\"     MANDATE_INACTIVE      = 2; // string representation: \"MANDATE_INACTIVE\" }",
            "x-example-override": "NEW_EFFECTIVE_TO_TIMESTAMP_NOT_AFTER_EFFECTIVE_FROM_TIMESTAMP"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional structured details about this error.\n\nKeys should match /[a-zA-Z0-9-_]/ and be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than {\"instance_limit\": \"100/request\"}, should be returned as, {\"instance_limit_per_request\": \"100\"}, if the client exceeds the number of instances that can be created in a single (batch) request.",
            "x-example-override": "{\"parameter_value.effective_from_timestamp\":\"value\"}",
            "x-metadata-release-info": [
              {
                "key": "parameter_value.effective_from_timestamp",
                "description": "The effective_from_timestamp of the ParameterValue."
              }
            ]
          }
        },
        "description": "A message type used to describe a single precondition failure."
      },
      "PreconditionFailureViolationUpdateParameterValueFAILED_PRECONDITION_6": {
        "type": "object",
        "properties": {
          "violation_type": {
            "type": "string",
            "title": "A set of canonical violation types that can be used by API client to programmatically handle the error. A resource or API specific enum type must be defined for the supported precondition violation subjects. e.g. enum DirectDebitPreconditionFailureTypes {     UNKNOWN               = 0; // string representation: \"UNKNOWN\"     BANK_ACCOUNT_DISABLED = 1; // string representation: \"BANK_ACCOUNT_DISABLED\"     MANDATE_INACTIVE      = 2; // string representation: \"MANDATE_INACTIVE\" }",
            "x-example-override": "NEW_EFFECTIVE_TIMESTAMP_RANGE_OVERLAPS_EXISTING_PARAMETER_VALUE"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional structured details about this error.\n\nKeys should match /[a-zA-Z0-9-_]/ and be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than {\"instance_limit\": \"100/request\"}, should be returned as, {\"instance_limit_per_request\": \"100\"}, if the client exceeds the number of instances that can be created in a single (batch) request.",
            "x-example-override": "{\"parameter_value.effective_from_timestamp\":\"value\",\"parameter_value.id\":\"value\"}",
            "x-metadata-release-info": [
              {
                "key": "parameter_value.id",
                "description": "The id of the subsequent ParameterValue."
              },
              {
                "key": "parameter_value.effective_from_timestamp",
                "description": "The effective_from_timestamp of the subsequent ParameterValue."
              }
            ]
          }
        },
        "description": "A message type used to describe a single precondition failure."
      },
      "UpdateParameterValueFAILED_PRECONDITION_1": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "FAILED_PRECONDITION"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsPreconditionFailureUpdateParameterValueFAILED_PRECONDITION_1",
                  "title": "PreconditionFailure"
                }
              ]
            }
          }
        }
      },
      "UpdateParameterValueFAILED_PRECONDITION_2": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "FAILED_PRECONDITION"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsPreconditionFailureUpdateParameterValueFAILED_PRECONDITION_2",
                  "title": "PreconditionFailure"
                }
              ]
            }
          }
        }
      },
      "UpdateParameterValueFAILED_PRECONDITION_3": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "FAILED_PRECONDITION"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsPreconditionFailureUpdateParameterValueFAILED_PRECONDITION_3",
                  "title": "PreconditionFailure"
                }
              ]
            }
          }
        }
      },
      "UpdateParameterValueFAILED_PRECONDITION_4": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "FAILED_PRECONDITION"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsPreconditionFailureUpdateParameterValueFAILED_PRECONDITION_4",
                  "title": "PreconditionFailure"
                }
              ]
            }
          }
        }
      },
      "UpdateParameterValueFAILED_PRECONDITION_5": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "FAILED_PRECONDITION"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsPreconditionFailureUpdateParameterValueFAILED_PRECONDITION_5",
                  "title": "PreconditionFailure"
                }
              ]
            }
          }
        }
      },
      "UpdateParameterValueFAILED_PRECONDITION_6": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "FAILED_PRECONDITION"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsPreconditionFailureUpdateParameterValueFAILED_PRECONDITION_6",
                  "title": "PreconditionFailure"
                }
              ]
            }
          }
        }
      },
      "UpdateParameterValueNOT_FOUND_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "NOT_FOUND"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsResourceInfo",
                  "title": "ResourceInfo"
                }
              ]
            }
          }
        }
      },
      "errorsPreconditionFailureCreateParameterValueFAILED_PRECONDITION_0": {
        "type": "object",
        "properties": {
          "@type": {
            "type": "string",
            "description": "A type name to identify this detail.",
            "x-example-override": "http://type.googleapis.com/errors.PreconditionFailure"
          },
          "violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PreconditionFailureViolationCreateParameterValueFAILED_PRECONDITION_0"
            },
            "description": "Describes all precondition violations."
          }
        },
        "description": "Describes what preconditions have failed.\n\nFor example, if creating a direct debit failed because bank account validation failed, it could list the account violation in the PreconditionFailure message."
      },
      "errorsPreconditionFailureCreateParameterValueFAILED_PRECONDITION_1": {
        "type": "object",
        "properties": {
          "@type": {
            "type": "string",
            "description": "A type name to identify this detail.",
            "x-example-override": "http://type.googleapis.com/errors.PreconditionFailure"
          },
          "violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PreconditionFailureViolationCreateParameterValueFAILED_PRECONDITION_1"
            },
            "description": "Describes all precondition violations."
          }
        },
        "description": "Describes what preconditions have failed.\n\nFor example, if creating a direct debit failed because bank account validation failed, it could list the account violation in the PreconditionFailure message."
      },
      "errorsPreconditionFailureCreateParameterValueFAILED_PRECONDITION_2": {
        "type": "object",
        "properties": {
          "@type": {
            "type": "string",
            "description": "A type name to identify this detail.",
            "x-example-override": "http://type.googleapis.com/errors.PreconditionFailure"
          },
          "violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PreconditionFailureViolationCreateParameterValueFAILED_PRECONDITION_2"
            },
            "description": "Describes all precondition violations."
          }
        },
        "description": "Describes what preconditions have failed.\n\nFor example, if creating a direct debit failed because bank account validation failed, it could list the account violation in the PreconditionFailure message."
      },
      "errorsPreconditionFailureCreateParameterValueFAILED_PRECONDITION_3": {
        "type": "object",
        "properties": {
          "@type": {
            "type": "string",
            "description": "A type name to identify this detail.",
            "x-example-override": "http://type.googleapis.com/errors.PreconditionFailure"
          },
          "violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PreconditionFailureViolationCreateParameterValueFAILED_PRECONDITION_3"
            },
            "description": "Describes all precondition violations."
          }
        },
        "description": "Describes what preconditions have failed.\n\nFor example, if creating a direct debit failed because bank account validation failed, it could list the account violation in the PreconditionFailure message."
      },
      "errorsPreconditionFailureUpdateParameterValueFAILED_PRECONDITION_1": {
        "type": "object",
        "properties": {
          "@type": {
            "type": "string",
            "description": "A type name to identify this detail.",
            "x-example-override": "http://type.googleapis.com/errors.PreconditionFailure"
          },
          "violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PreconditionFailureViolationUpdateParameterValueFAILED_PRECONDITION_1"
            },
            "description": "Describes all precondition violations."
          }
        },
        "description": "Describes what preconditions have failed.\n\nFor example, if creating a direct debit failed because bank account validation failed, it could list the account violation in the PreconditionFailure message."
      },
      "errorsPreconditionFailureUpdateParameterValueFAILED_PRECONDITION_2": {
        "type": "object",
        "properties": {
          "@type": {
            "type": "string",
            "description": "A type name to identify this detail.",
            "x-example-override": "http://type.googleapis.com/errors.PreconditionFailure"
          },
          "violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PreconditionFailureViolationUpdateParameterValueFAILED_PRECONDITION_2"
            },
            "description": "Describes all precondition violations."
          }
        },
        "description": "Describes what preconditions have failed.\n\nFor example, if creating a direct debit failed because bank account validation failed, it could list the account violation in the PreconditionFailure message."
      },
      "errorsPreconditionFailureUpdateParameterValueFAILED_PRECONDITION_3": {
        "type": "object",
        "properties": {
          "@type": {
            "type": "string",
            "description": "A type name to identify this detail.",
            "x-example-override": "http://type.googleapis.com/errors.PreconditionFailure"
          },
          "violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PreconditionFailureViolationUpdateParameterValueFAILED_PRECONDITION_3"
            },
            "description": "Describes all precondition violations."
          }
        },
        "description": "Describes what preconditions have failed.\n\nFor example, if creating a direct debit failed because bank account validation failed, it could list the account violation in the PreconditionFailure message."
      },
      "errorsPreconditionFailureUpdateParameterValueFAILED_PRECONDITION_4": {
        "type": "object",
        "properties": {
          "@type": {
            "type": "string",
            "description": "A type name to identify this detail.",
            "x-example-override": "http://type.googleapis.com/errors.PreconditionFailure"
          },
          "violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PreconditionFailureViolationUpdateParameterValueFAILED_PRECONDITION_4"
            },
            "description": "Describes all precondition violations."
          }
        },
        "description": "Describes what preconditions have failed.\n\nFor example, if creating a direct debit failed because bank account validation failed, it could list the account violation in the PreconditionFailure message."
      },
      "errorsPreconditionFailureUpdateParameterValueFAILED_PRECONDITION_5": {
        "type": "object",
        "properties": {
          "@type": {
            "type": "string",
            "description": "A type name to identify this detail.",
            "x-example-override": "http://type.googleapis.com/errors.PreconditionFailure"
          },
          "violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PreconditionFailureViolationUpdateParameterValueFAILED_PRECONDITION_5"
            },
            "description": "Describes all precondition violations."
          }
        },
        "description": "Describes what preconditions have failed.\n\nFor example, if creating a direct debit failed because bank account validation failed, it could list the account violation in the PreconditionFailure message."
      },
      "errorsPreconditionFailureUpdateParameterValueFAILED_PRECONDITION_6": {
        "type": "object",
        "properties": {
          "@type": {
            "type": "string",
            "description": "A type name to identify this detail.",
            "x-example-override": "http://type.googleapis.com/errors.PreconditionFailure"
          },
          "violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PreconditionFailureViolationUpdateParameterValueFAILED_PRECONDITION_6"
            },
            "description": "Describes all precondition violations."
          }
        },
        "description": "Describes what preconditions have failed.\n\nFor example, if creating a direct debit failed because bank account validation failed, it could list the account violation in the PreconditionFailure message."
      },
      "rangesTimestampRange": {
        "type": "object",
        "properties": {
          "from": {
            "type": "string",
            "format": "date-time",
            "description": "Values in this range must be greater than or equal to the value of from."
          },
          "to": {
            "type": "string",
            "format": "date-time",
            "description": "Values in this range must be less than the value of to."
          }
        },
        "description": "Describes a range of timestamps."
      },
      "account_schedule_tagsAccountScheduleTag": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The ID of the AccountScheduleTag; it is used to tag schedules in a Smart Contract or Supervisor Contract.\n\nRequired.\nMax length: 256 characters."
          },
          "description": {
            "type": "string",
            "description": "The description of the AccountScheduleTag.\n"
          },
          "sends_scheduled_operation_reports": {
            "type": "boolean",
            "description": "Indicates if the AccountScheduleTag is set to produce execution notifications."
          },
          "schedule_status_override": {
            "$ref": "#/components/schemas/account_schedule_tagsAccountScheduleTagScheduleStatusOverride",
            "description": "The status applied to schedules tagged with this AccountScheduleTag."
          },
          "schedule_status_override_start_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "A timestamp indicating when to start overriding the status on account/plan schedules with this tag."
          },
          "schedule_status_override_end_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "A timestamp indicating when to stop overriding the status on account/plan schedules with this tag."
          },
          "test_pause_at_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "A timestamp indicating when an account/plan schedule with this tag will pause; the pause will occur when `next_run_timestamp` is equal to or greater than `test_pause_at_timestamp`. Only for testing purposes.",
            "x-release-info": {
              "releaseVersion": {
                "major": 2,
                "minor": 2
              },
              "changeType": "ADD_FIELD"
            }
          }
        },
        "required": [
          "id"
        ]
      },
      "account_schedule_tagsAccountScheduleTagScheduleStatusOverride": {
        "type": "string",
        "enum": [
          "ACCOUNT_SCHEDULE_TAG_SCHEDULE_STATUS_OVERRIDE_UNKNOWN",
          "ACCOUNT_SCHEDULE_TAG_SCHEDULE_STATUS_OVERRIDE_NO_OVERRIDE",
          "ACCOUNT_SCHEDULE_TAG_SCHEDULE_STATUS_OVERRIDE_TO_ENABLED",
          "ACCOUNT_SCHEDULE_TAG_SCHEDULE_STATUS_OVERRIDE_TO_FAST_FORWARDED",
          "ACCOUNT_SCHEDULE_TAG_SCHEDULE_STATUS_OVERRIDE_TO_SKIPPED"
        ],
        "default": "ACCOUNT_SCHEDULE_TAG_SCHEDULE_STATUS_OVERRIDE_UNKNOWN",
        "x-enum-value-descriptions": {
          "ACCOUNT_SCHEDULE_TAG_SCHEDULE_STATUS_OVERRIDE_NO_OVERRIDE": "Indicates that the AccountScheduleTag is inactive; it will not apply any status effects on its tagged account/plan schedules. `schedule_status_override_start_timestamp` and `schedule_status_override_end_timestamp` must not be provided for this status override.",
          "ACCOUNT_SCHEDULE_TAG_SCHEDULE_STATUS_OVERRIDE_TO_ENABLED": "An AccountScheduleTag with this status override will temporarily override the status of all tagged schedules to `SCHEDULE_STATUS_ENABLED`. The change will be effective between `schedule_status_override_start_timestamp` and `schedule_status_override_end_timestamp`. Both `schedule_status_override_start_timestamp` and `schedule_status_override_end_timestamp` are required for this status override.",
          "ACCOUNT_SCHEDULE_TAG_SCHEDULE_STATUS_OVERRIDE_TO_FAST_FORWARDED": "An AccountScheduleTag with this status override will temporarily fast-forward tagged account/plan schedules. All jobs associated with tagged schedules that have a `schedule_timestamp` between the current time and `schedule_status_override_end_timestamp` are triggered immediately. All jobs with `schedule_timestamp` after `schedule_status_override_end_timestamp` are unaffected and are triggered at their `schedule_timestamp`. `schedule_status_override_start_timestamp` must not be provided for this status override. `schedule_status_override_end_timestamp` is required for this status override.",
          "ACCOUNT_SCHEDULE_TAG_SCHEDULE_STATUS_OVERRIDE_TO_SKIPPED": "An AccountScheduleTag with this status override will temporarily override the status of all tagged schedules to `SCHEDULE_STATUS_SKIPPED`. The change will be effective between `schedule_status_override_start_timestamp` and `schedule_status_override_end_timestamp`. `schedule_status_override_start_timestamp` is optional for this status override and defaults to the current time if it is not provided. `schedule_status_override_end_timestamp` is required for this status override.",
          "ACCOUNT_SCHEDULE_TAG_SCHEDULE_STATUS_OVERRIDE_UNKNOWN": "Default value."
        }
      },
      "account_schedule_tagsBatchGetAccountScheduleTagsResponse": {
        "type": "object",
        "properties": {
          "account_schedule_tags": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/account_schedule_tagsAccountScheduleTag"
            },
            "description": "A map of the AccountScheduleTag ID to the AccountScheduleTag."
          }
        }
      },
      "account_schedule_tagsCreateAccountScheduleTagRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent.\n\nRequired.\nMax length: 256 characters."
          },
          "account_schedule_tag": {
            "$ref": "#/components/schemas/account_schedule_tagsAccountScheduleTag",
            "description": "The AccountScheduleTag that is to be created. Required."
          }
        },
        "required": [
          "request_id"
        ]
      },
      "account_schedule_tagsListAccountScheduleTagsResponse": {
        "type": "object",
        "properties": {
          "account_schedule_tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/account_schedule_tagsAccountScheduleTag"
            },
            "description": "A list of matching AccountScheduleTags, ordered by ascending ID."
          },
          "previous_page_token": {
            "type": "string",
            "description": "Token used to retrieve the previous page. If empty, returns the first page of results."
          },
          "next_page_token": {
            "type": "string",
            "description": "Token used to retrieve the next page. If empty, returns the last page of results."
          }
        }
      },
      "account_schedule_tagsUpdateAccountScheduleTagRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent.\n\nRequired.\nMax length: 256 characters."
          },
          "account_schedule_tag": {
            "$ref": "#/components/schemas/account_schedule_tagsAccountScheduleTag",
            "description": "The AccountScheduleTag that is to be updated. Required.",
            "x-excluded-fields": [
              "description",
              "sends_scheduled_operation_reports"
            ]
          },
          "update_mask": {
            "$ref": "#/components/schemas/protobufFieldMask",
            "title": "Field mask used to indicate which fields of the resource are to be updated. Required. Valid update mask paths are: - `schedule_status_override` which will update the `schedule_status_override` of an AccountScheduleTag - `schedule_status_override_status_start_timestamp` which will update the `schedule_status_override_status_start_timestamp` of an AccountScheduleTag. A `schedule_status_override` is required when updating this field - `schedule_status_override_status_end_timestamp` which will update the `schedule_status_override_status_end_timestamp` of an AccountScheduleTag. A `schedule_status_override` is required when updating this field - `test_pause_at_timestamp` which will update the `test_pause_at_timestamp` value of an AccountScheduleTag"
          }
        },
        "required": [
          "request_id"
        ]
      },
      "GetAccountRequestIncludeField": {
        "type": "string",
        "enum": [
          "INCLUDE_FIELD_DERIVED_INSTANCE_PARAM_VALS"
        ],
        "default": "INCLUDE_FIELD_DERIVED_INSTANCE_PARAM_VALS"
      },
      "accountingTside": {
        "type": "string",
        "enum": [
          "TSIDE_UNKNOWN",
          "TSIDE_ASSET",
          "TSIDE_LIABILITY"
        ],
        "default": "TSIDE_UNKNOWN",
        "description": "The side of the balance sheet where an account balance is counted. Determines the sign with which a credit/debit posting affects a balance.",
        "x-enum-value-descriptions": {
          "TSIDE_ASSET": "Debit postings increase balances for asset accounts.",
          "TSIDE_LIABILITY": "Credit postings increase balances for liability accounts.",
          "TSIDE_UNKNOWN": "Default Value, invalid."
        }
      },
      "accountsAccount": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "A unique ID for an account. Optional for create requests.\n\nMax length: 36 characters."
          },
          "name": {
            "type": "string",
            "description": "The account name."
          },
          "product_id": {
            "type": "string",
            "description": "The ID of the product the account is associated with. Can be obtained using the /v1/products endpoint. Required for create requests if `product_version_id` is not provided."
          },
          "product_version_id": {
            "type": "string",
            "description": "The ID of the product version matching the product ID. Required for create requests if `product_id` is not provided."
          },
          "permitted_denominations": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A set of denominations accessible from within the Smart Contract:<br><br> - If the Product Version specifies supported denominations, then this set must be a subset of those (if none are specified here then the field will be set to the Product Version's supported denominations).<br> - If the Product Version does not specify denominations, then it will be set to the permitted_denominations entry of values.yaml<br><br> Incoming postings are not required to specify a denomination contained in this list; if this functionality is required then it must be implemented in the Smart Contract."
          },
          "status": {
            "$ref": "#/components/schemas/accounts_commonAccountStatus",
            "description": "The status of the account. Optional for creation. Valid updates are from ACCOUNT_STATUS_PENDING to ACCOUNT_STATUS_OPEN or ACCOUNT_STATUS_CANCELLED, ACCOUNT_STATUS_OPEN to ACCOUNT_STATUS_PENDING_CLOSURE or ACCOUNT_STATUS_CLOSED, ACCOUNT_STATUS_PENDING_CLOSURE to ACCOUNT_STATUS_CLOSED. Updating the status to ACCOUNT_STATUS_OPEN will trigger the creation of an account update with an `activation_update` field and run the contract activation code. Updating the status to ACCOUNT_STATUS_PENDING_CLOSURE will trigger the creation of an account update with a closure_update field and run the contract close code. Accounts with the status ACCOUNT_STATUS_PENDING_CLOSURE can only be updated to ACCOUNT_STATUS_CLOSED. Accounts can only be updated to ACCOUNT_STATUS_CLOSED once the `closure_update` account update had the status ACCOUNT_UPDATE_STATUS_COMPLETED and the account has a zero balance. The account status can be updated directly to CLOSED from OPEN if the closing timestamp is provided and is also updated in the same call."
          },
          "opening_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time when the account was opened. Optional for create. If supplied during account creation, the account must be created with status ACCOUNT_STATUS_OPEN and the opening_timestamp value must not be a time in the future."
          },
          "closing_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time when the account was closed. Can be updated to a time in the past directly if the account status is updated to CLOSED in the same call. The account status must be OPEN or PENDING_CLOSURE to update the closing timestamp."
          },
          "stakeholder_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The customer IDs that can access the account. Required for create requests."
          },
          "instance_param_vals": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "The instance-level parameters for the associated product; a map of the parameter name to value. The instance-level parameters provided (which must be non-derived instance-level parameters when provided in create requests) that have been defined in the account's Smart Contract code; a map of the parameter name to value. Optional for create requests. When the account GetAccount request `fields_to_include` field is set to INCLUDE_FIELD_DERIVED_INSTANCE_PARAM_VALS, derived instance-level parameters will be displayed in the`derived_instance_param_vals` field of the account. Non-derived instance parameters will only ever appear in the account`instance_param_vals` field."
          },
          "derived_instance_param_vals": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "The derived instance-level parameters for the associated product that have been defined in the account's Smart Contract code; a map of the parameter name to value.",
            "x-output-only": true
          },
          "details": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "A map of unstructured fields that hold instance-specific account details, for example, the source of funds. Optional for create requests.<br> <br>The details must not include:<br> - Any image data, including any KYC collateral such as passport, licence or other images. These must be stored in a separate repository outside of Vault.<br> - Any data that is classified as PII data.<br> The details cannot be utilised by Smart Contracts to drive any type of product behaviour.<br><br> Max size: 1MB (but it is strongly recommended to keep below this size)."
          },
          "accounting": {
            "$ref": "#/components/schemas/accounts_commonAccounting",
            "description": "The accounting data that Vault supports as first-class fields."
          }
        }
      },
      "accountsAccountMigration": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "A unique identifier for the account migration. Optional."
          },
          "status": {
            "$ref": "#/components/schemas/accountsAccountMigrationStatus",
            "description": "The status of account migration."
          },
          "create_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "A timestamp indicating when the account migration was created."
          },
          "last_status_update_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "A timestamp indicating when the last update was performed."
          },
          "product_version_migration": {
            "$ref": "#/components/schemas/accountsProductVersionMigration",
            "required": true
          }
        },
        "description": "Representation of an account migration object. Account migrations are used for the bulk migration of accounts from specified product version IDs to one final specified product version ID."
      },
      "accountsAccountMigrationStatus": {
        "type": "string",
        "enum": [
          "ACCOUNT_MIGRATION_STATUS_UNKNOWN",
          "ACCOUNT_MIGRATION_STATUS_PENDING_EXECUTION",
          "ACCOUNT_MIGRATION_STATUS_PAUSED",
          "ACCOUNT_MIGRATION_STATUS_COMPLETED"
        ],
        "default": "ACCOUNT_MIGRATION_STATUS_UNKNOWN",
        "description": "The status of the account migration.",
        "x-enum-value-descriptions": {
          "ACCOUNT_MIGRATION_STATUS_COMPLETED": "Indicates that the account migration has been completed.",
          "ACCOUNT_MIGRATION_STATUS_PAUSED": "Indicates that the account migration has been paused.",
          "ACCOUNT_MIGRATION_STATUS_PENDING_EXECUTION": "Indicates that the account migration is in progress.",
          "ACCOUNT_MIGRATION_STATUS_UNKNOWN": "Default value."
        }
      },
      "accountsAccountScheduleAssoc": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "A unique identifier for the Account Schedule association."
          },
          "account_id": {
            "type": "string",
            "description": "The ID of the account."
          },
          "schedule_id": {
            "type": "string",
            "description": "The Schedule ID associated with the account."
          },
          "create_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "A timestamp indicating when the Schedule was created."
          }
        }
      },
      "accountsAccountUpdate": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "A unique identifier for the account update. Optional."
          },
          "account_id": {
            "type": "string",
            "description": "The Account ID this update applies to. Required for create requests."
          },
          "status": {
            "$ref": "#/components/schemas/accountsAccountUpdateStatus",
            "description": "The status of the account update. This can be used to track the progress of the update.",
            "x-output-only": true
          },
          "create_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "A timestamp indicating when the account update was created."
          },
          "last_status_update_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "A timestamp indicating when the last update was performed."
          },
          "account_update_batch_id": {
            "type": "string",
            "description": "The ID of the AccountUpdateBatch if the AccountUpdate was created as part of a batch."
          },
          "failure_reason": {
            "type": "string",
            "description": "The reason an account update was not completed successfully. This will only be populated if the account update status is either ACCOUNT_UPDATE_STATUS_REJECTED or ACCOUNT_UPDATE_STATUS_ERRORED.",
            "x-output-only": true
          },
          "instance_param_vals_update": {
            "$ref": "#/components/schemas/accountsInstanceParamValsUpdate",
            "required": false
          },
          "product_version_update": {
            "$ref": "#/components/schemas/accountsProductVersionUpdate",
            "required": false
          },
          "activation_update": {
            "$ref": "#/components/schemas/v1accountsActivationUpdate",
            "required": false
          },
          "closure_update": {
            "$ref": "#/components/schemas/v1accountsClosureUpdate",
            "required": false
          }
        },
        "description": "Representation of an account update object. Account updates are used to facilitate various account mutations. Each account update is linked to one account ID and can be created to update the instance parameter values or the product version of an account. Updating an account status from ACCOUNT_STATUS_PENDING to ACCOUNT_STATUS_OPEN, or from ACCOUNT_STATUS_OPEN to ACCOUNT_STATUS_CLOSED will implicitly create account updates. Account Updates are executed serially in order of creation. The status of an account update indicates whether the asynchronous execution of the account update was successful or not."
      },
      "accountsAccountUpdateBatch": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "A unique identifier for the account update batch. Optional."
          },
          "account_updates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/accountsAccountUpdate"
            },
            "description": "The AccountUpdates that will be created as part of this batch."
          },
          "status": {
            "$ref": "#/components/schemas/accountsAccountUpdateBatchStatus",
            "description": "The status of AccountUpdateBatch. This is inferred from the status of AccountUpdates."
          },
          "account_migration_id": {
            "type": "string",
            "description": "The ID of the AccountMigration if the AccountUpdateBatch was created as part of a migration."
          },
          "create_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The timestamp when this AccountUpdateBatch was created."
          }
        }
      },
      "accountsAccountUpdateBatchCreateOptions": {
        "type": "object",
        "properties": {
          "invalid_account_update_handling_type": {
            "$ref": "#/components/schemas/accountsInvalidAccountUpdateHandlingType",
            "description": "Determines how invalid updates in the batch are handled."
          }
        }
      },
      "accountsAccountUpdateBatchStatus": {
        "type": "string",
        "enum": [
          "ACCOUNT_UPDATE_BATCH_STATUS_UNKNOWN",
          "ACCOUNT_UPDATE_BATCH_STATUS_PENDING_EXECUTION",
          "ACCOUNT_UPDATE_BATCH_STATUS_COMPLETED"
        ],
        "default": "ACCOUNT_UPDATE_BATCH_STATUS_UNKNOWN",
        "description": "The status of the account update batch.",
        "x-enum-value-descriptions": {
          "ACCOUNT_UPDATE_BATCH_STATUS_COMPLETED": "Indicates that none of the  AccountUpdates in the AccountUpdateBatch are still pending execution i.e all of account updates in the account update batch have the status ACCOUNT_UPDATE_STATUS_COMPLETED, ACCOUNT_UPDATE_STATUS_REJECTED or ACCOUNT_UPDATE_STATUS_ERRORED.",
          "ACCOUNT_UPDATE_BATCH_STATUS_PENDING_EXECUTION": "The AccountUpdateBatch is in progress.",
          "ACCOUNT_UPDATE_BATCH_STATUS_UNKNOWN": "The default value."
        }
      },
      "accountsAccountUpdateStatus": {
        "type": "string",
        "enum": [
          "ACCOUNT_UPDATE_STATUS_UNKNOWN",
          "ACCOUNT_UPDATE_STATUS_PENDING_EXECUTION",
          "ACCOUNT_UPDATE_STATUS_COMPLETED",
          "ACCOUNT_UPDATE_STATUS_REJECTED",
          "ACCOUNT_UPDATE_STATUS_ERRORED"
        ],
        "default": "ACCOUNT_UPDATE_STATUS_UNKNOWN",
        "description": "The status of the account update.",
        "x-enum-value-descriptions": {
          "ACCOUNT_UPDATE_STATUS_COMPLETED": "The AccountUpdate was successfully executed.",
          "ACCOUNT_UPDATE_STATUS_ERRORED": "The AccountUpdate errored.",
          "ACCOUNT_UPDATE_STATUS_PENDING_EXECUTION": "The AccountUpdate hasn't been picked up from the queue or is in progress.",
          "ACCOUNT_UPDATE_STATUS_REJECTED": "The AccountUpdate failed validation of a constraint in the async pipeline.",
          "ACCOUNT_UPDATE_STATUS_UNKNOWN": "Default value."
        }
      },
      "accountsActivationUpdate": {
        "type": "object",
        "description": "An ActivationUpdate is automatically queued when updating an account status from `ACCOUNT_STATUS_PENDING` to `ACCOUNT_STATUS_OPEN`. An ActivationUpdate can also be retried if the account status is `ACCOUNT_STATUS_OPEN` and the Account has no other ActivationUpdates with status `ACCOUNT_UPDATE_STATUS_PENDING_EXECUTION` or `ACCOUNT_UPDATE_STATUS_COMPLETED`. This account update triggers the product activation code and sets up custom schedules."
      },
      "accountsBatchGetAccountMigrationsResponse": {
        "type": "object",
        "properties": {
          "account_migrations": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/accountsAccountMigration"
            },
            "description": "Map of account migration IDs to their value."
          }
        }
      },
      "accountsBatchGetAccountUpdateBatchesResponse": {
        "type": "object",
        "properties": {
          "account_update_batches": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/accountsAccountUpdateBatch"
            },
            "description": "A map of the account update batch ID to the account update batch."
          }
        }
      },
      "accountsBatchGetAccountUpdatesResponse": {
        "type": "object",
        "properties": {
          "account_updates": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/accountsAccountUpdate"
            },
            "description": "A map of the account update ID to the account update."
          }
        }
      },
      "accountsClosureUpdate": {
        "type": "object",
        "description": "A ClosureUpdate is automatically queued when updating an account status from ACCOUNT_STATUS_OPEN to ACCOUNT_STATUS_PENDING_CLOSURE. A ClosureUpdate can also be retried if the account status is ACCOUNT_STATUS_PENDING_CLOSURE. This account update triggers the product close code, but it does not disable schedules."
      },
      "accountsCreateAccountMigrationRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent.\n\nRequired.\nMax length: 512 characters."
          },
          "account_migration": {
            "$ref": "#/components/schemas/accountsAccountMigration",
            "description": "The account migration to be created. Required.",
            "x-excluded-fields": [
              "status",
              "create_timestamp",
              "last_status_update_timestamp"
            ]
          }
        },
        "required": [
          "request_id"
        ]
      },
      "accountsCreateAccountRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent.\n\nRequired.\nMax length: 512 characters."
          },
          "account": {
            "$ref": "#/components/schemas/accountsAccount",
            "description": "The account object to be created. Required. If a product version is provided that makes use of contract modules, each named contract module must have a corresponding smart contract module versions link.",
            "x-excluded-fields": [
              "name",
              "closing_timestamp",
              "derived_instance_param_vals",
              "accounting"
            ]
          }
        },
        "required": [
          "request_id"
        ]
      },
      "accountsCreateAccountUpdateBatchRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent. Required.\n\nRequired.\nMax length: 512 characters."
          },
          "account_update_batch": {
            "$ref": "#/components/schemas/accountsAccountUpdateBatch",
            "description": "The account update batch to create. Required.",
            "x-excluded-fields": [
              "status",
              "account_migration_id",
              "create_timestamp"
            ]
          },
          "create_options": {
            "$ref": "#/components/schemas/accountsAccountUpdateBatchCreateOptions",
            "description": "Options for the creation of the account update batch.",
            "x-release-info": {
              "releaseVersion": {
                "major": 2,
                "minor": 2
              },
              "changeType": "ADD_FIELD",
              "description": "Allows creation options for account update batches."
            }
          }
        },
        "required": [
          "request_id"
        ]
      },
      "accountsCreateAccountUpdateRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent. Required.\n\nRequired.\nMax length: 512 characters."
          },
          "account_update": {
            "$ref": "#/components/schemas/accountsAccountUpdate",
            "description": "The account update to create. Required.",
            "x-excluded-fields": [
              "status",
              "create_timestamp",
              "last_status_update_timestamp",
              "account_update_batch_id",
              "failure_reason"
            ]
          }
        },
        "required": [
          "request_id"
        ]
      },
      "accountsInstanceParamValsUpdate": {
        "type": "object",
        "properties": {
          "instance_param_vals": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "The new instance parameter values that are to be applied to the account. The parameters must be non-derived instance-level parameters that have been defined in the account's Smart Contract code."
          }
        }
      },
      "accountsInvalidAccountUpdateHandlingType": {
        "type": "string",
        "enum": [
          "INVALID_ACCOUNT_UPDATE_HANDLING_TYPE_FAIL_BATCH",
          "INVALID_ACCOUNT_UPDATE_HANDLING_TYPE_FAIL_INVALID_UPDATES_ONLY",
          "INVALID_ACCOUNT_UPDATE_HANDLING_TYPE_IGNORE_INVALID_UPDATES"
        ],
        "default": "INVALID_ACCOUNT_UPDATE_HANDLING_TYPE_FAIL_BATCH",
        "x-enum-value-descriptions": {
          "INVALID_ACCOUNT_UPDATE_HANDLING_TYPE_FAIL_BATCH": "Default value. Returns an error if any update is invalid.",
          "INVALID_ACCOUNT_UPDATE_HANDLING_TYPE_FAIL_INVALID_UPDATES_ONLY": "Invalid updates are created with REJECTED status.",
          "INVALID_ACCOUNT_UPDATE_HANDLING_TYPE_IGNORE_INVALID_UPDATES": "Invalid updates are ignored."
        }
      },
      "accountsListAccountMigrationsResponse": {
        "type": "object",
        "properties": {
          "account_migrations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/accountsAccountMigration"
            },
            "description": "A list of matching account migrations, ordered by ascending `create_timestamp`."
          },
          "previous_page_token": {
            "type": "string",
            "description": "Token used to retrieve the previous page. If empty, returns the first page of results."
          },
          "next_page_token": {
            "type": "string",
            "description": "Token used to retrieve the next page. If empty, returns the last page of results."
          }
        }
      },
      "accountsListAccountParamTimeseriesResponse": {
        "type": "object",
        "properties": {
          "account_param_timeseries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/accountsParameterTimeseries"
            },
            "description": "The account parameter timeseries retrieved for the specified account ID. The order of the elements is arbitrary and is not guaranteed to remain the same."
          },
          "product_version_param_timeseries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/accountsParameterTimeseries"
            },
            "description": "The retrieved product version parameter timeseries for the specified account ID. The order of the elements is arbitrary and is not guaranteed to remain the same."
          }
        }
      },
      "accountsListAccountScheduleAssocsResponse": {
        "type": "object",
        "properties": {
          "account_schedule_assocs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/accountsAccountScheduleAssoc"
            },
            "description": "A list of matching Account Schedule associations, ordered by ascending `create_timestamp`. In cases of matching timestamps, ordering is by ascending `id`. Note: Account Schedule Assoc is an Association resource where each Assoc holds a reference to an Account and a Schedule related to that Account. This will include Associations to previous Product Versions and disabled Schedules."
          },
          "previous_page_token": {
            "type": "string",
            "description": "Token used to retrieve the previous page. If empty, returns the first page of results."
          },
          "next_page_token": {
            "type": "string",
            "description": "Token used to retrieve the next page. If empty, returns the last page of results."
          }
        }
      },
      "accountsListAccountUpdateBatchesResponse": {
        "type": "object",
        "properties": {
          "account_update_batches": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/accountsAccountUpdateBatch"
            },
            "description": "A list of matching account update batches, ordered by descending `create_timestamp`."
          },
          "previous_page_token": {
            "type": "string",
            "description": "The pagination token used to retrieve the previous page. If empty, returns the first page of results."
          },
          "next_page_token": {
            "type": "string",
            "description": "The pagination token used to retrieve the next page. If empty, returns the last page of results."
          }
        }
      },
      "accountsListAccountUpdatesResponse": {
        "type": "object",
        "properties": {
          "account_updates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/accountsAccountUpdate"
            },
            "description": "A list of matching account updates, ordered by ascending `create_timestamp`."
          },
          "previous_page_token": {
            "type": "string",
            "description": "Token used to retrieve the previous page. If empty, returns the first page of results."
          },
          "next_page_token": {
            "type": "string",
            "description": "Token used to retrieve the next page. If empty, returns the last page of results."
          }
        }
      },
      "accountsListAccountsResponse": {
        "type": "object",
        "properties": {
          "accounts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/accountsAccount"
            },
            "description": "A list of matching accounts, ordered by ascending `id`."
          },
          "previous_page_token": {
            "type": "string",
            "description": "Token used to retrieve the previous page. If empty, returns the first page of results."
          },
          "next_page_token": {
            "type": "string",
            "description": "Token used to retrieve the next page. If empty, returns the last page of results."
          }
        }
      },
      "accountsParamValue": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "The value of a parameter."
          },
          "effective_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "A timestamp indicating when the parameter value is effective from."
          }
        }
      },
      "accountsParameterTimeseries": {
        "type": "object",
        "properties": {
          "param_name": {
            "type": "string",
            "description": "The parameter the value changes apply to."
          },
          "values": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/accountsParamValue"
            },
            "description": "The values of the parameter and the timestamp indicating when the parameter values became active, ordered by ascending `effective_timestamp`."
          }
        }
      },
      "accountsProductVersionMigration": {
        "type": "object",
        "properties": {
          "from_product_version_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The product version IDs of the accounts that are to be migrated."
          },
          "to_product_version_id": {
            "type": "string",
            "description": "The product version ID that accounts will be migrated to. For migrations to product versions that make use of contract modules, each named contract module in the target product version must have a corresponding smart contract module versions link."
          },
          "schedule_migration_type": {
            "$ref": "#/components/schemas/accountsScheduleMigrationType",
            "title": "Specifies how existing schedules should be migrated. Note, this field has no effect on migrations to a product version on Smart Contract API Version 4.X.X. [See Account migrations.](/reference/accounts/overview/#account_migrations)",
            "x-release-info": {
              "noticeVersion": {
                "major": 4,
                "minor": 6
              },
              "releaseVersion": {
                "major": 6
              },
              "changeType": "REMOVE_FIELD",
              "description": "This field is not used on updates to Contracts Language API version 4 and will be removed alongside Contracts Language API version 3."
            }
          }
        },
        "title": "Holds the information required to execute a product version migration. To be part of a product version migration an account needs to be in one of the following statuses: ACCOUNT_STATUS_PENDING, ACCOUNT_STATUS_OPEN, ACCOUNT_STATUS_PENDING_CLOSURE"
      },
      "accountsProductVersionUpdate": {
        "type": "object",
        "properties": {
          "product_version_id": {
            "type": "string",
            "description": "The product version ID of the product that the account is to be updated to. The product version ID can be for any type of product provided it supports all the denominations and has the same tside as the current product. For updates to product versions that make use of contract modules, each named contract module in the target product version must have a corresponding Smart Contract module versions link."
          },
          "instance_param_vals_to_add": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "A map from the new instance parameter name to its value, which will get added when updating the product version. All of the parameters provided must be new instance parameters defined in the product version.",
            "x-release-info": {
              "releaseVersion": {
                "major": 1,
                "minor": 10
              },
              "changeType": "ADD_FIELD",
              "description": "Allows instance parameter addition during a product version update."
            }
          },
          "schedule_migration_type": {
            "$ref": "#/components/schemas/v1accountsScheduleMigrationType",
            "description": "Specifies how existing schedules should be migrated.",
            "x-release-info": {
              "noticeVersion": {
                "major": 4,
                "minor": 6
              },
              "releaseVersion": {
                "major": 6
              },
              "changeType": "REMOVE_FIELD",
              "description": "This field is not used on updates to Contracts Language API version 4 and will be removed alongside Contracts Language API version 3."
            }
          }
        }
      },
      "accountsScheduleMigrationType": {
        "type": "string",
        "enum": [
          "SCHEDULE_MIGRATION_TYPE_RECREATE_ALL_SCHEDULES_AND_GROUPS",
          "SCHEDULE_MIGRATION_TYPE_PRESERVE_SCHEDULES_IF_NO_GROUP_CHANGES"
        ],
        "default": "SCHEDULE_MIGRATION_TYPE_RECREATE_ALL_SCHEDULES_AND_GROUPS",
        "x-enum-value-descriptions": {
          "SCHEDULE_MIGRATION_TYPE_PRESERVE_SCHEDULES_IF_NO_GROUP_CHANGES": "When updating the product version of an account, existing schedules are preserved if either: * They are not part of a group and a schedule of the same event type is defined in the new Smart Contract code; or * They are part of a group and a group of the same name, size and order is defined in the new Smart Contract code. New schedules are only created if they are defined in the new Smart Contract code.",
          "SCHEDULE_MIGRATION_TYPE_RECREATE_ALL_SCHEDULES_AND_GROUPS": "When updating the product version of an account, all existing schedules will be deleted then recreated according to the Smart Contract code of the new product version. Any updates previously made to existing schedules will not be preserved. This is the default behaviour."
        }
      },
      "accountsUpdateAccountDetailsRequest": {
        "type": "object",
        "properties": {
          "account_id": {
            "type": "string",
            "description": "The account that is to be updated. Required."
          },
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent.\n\nRequired.\nMax length: 512 characters."
          },
          "items_to_add": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Map of key to item to add to the account details. If the key already exists, the value will be updated. If the key already exists and the value is set to empty, the key will be removed. Optional."
          },
          "items_to_remove": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of the keys that are to be removed from the account details; removing the key also removes its value. Optional."
          }
        },
        "required": [
          "request_id"
        ]
      },
      "accountsUpdateAccountMigrationRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent.\n\nRequired.\nMax length: 512 characters."
          },
          "account_migration": {
            "$ref": "#/components/schemas/accountsAccountMigration",
            "description": "The account migration that is to be updated. Required.",
            "x-excluded-fields": [
              "id",
              "create_timestamp",
              "last_status_update_timestamp",
              "product_version_migration"
            ]
          },
          "update_mask": {
            "$ref": "#/components/schemas/protobufFieldMask",
            "description": "Field mask used to indicate which fields of the resource are to be updated. Required. Valid update mask is status which updates an account migration status from PENDING_EXECUTION to PAUSED and back."
          }
        },
        "required": [
          "request_id"
        ]
      },
      "accountsUpdateAccountRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent.\n\nRequired.\nMax length: 512 characters."
          },
          "account": {
            "$ref": "#/components/schemas/accountsAccount",
            "description": "The account object to be updated. Required.",
            "x-excluded-fields": [
              "name",
              "product_id",
              "product_version_id",
              "permitted_denominations",
              "opening_timestamp",
              "instance_param_vals",
              "derived_instance_param_vals",
              "details",
              "accounting"
            ]
          },
          "update_mask": {
            "$ref": "#/components/schemas/protobufFieldMask",
            "description": "Field mask that indicates which fields of the resource are to be updated. Required. Valid update masks are: stakeholder_ids which updates an account's stakeholders with the new stakeholder IDs. status which updates the status of an account from PENDING to OPEN or CANCELLED status, from OPEN to PENDING_CLOSURE and from PENDING_CLOSURE to CLOSED. The status cannot be updated at the same time as any other fields except the closing timestamp. The closing timestamp can only be updated when updating the status to CLOSED from PENDING_CLOSURE or OPEN."
          },
          "overrides": {
            "$ref": "#/components/schemas/commonOverrides",
            "description": "This lets the caller override PREVENT_CLOSURE restrictions on an account; no other restriction types can be overridden."
          }
        },
        "required": [
          "request_id"
        ]
      },
      "accounts_commonAccountStatus": {
        "type": "string",
        "enum": [
          "ACCOUNT_STATUS_UNKNOWN",
          "ACCOUNT_STATUS_OPEN",
          "ACCOUNT_STATUS_CLOSED",
          "ACCOUNT_STATUS_CANCELLED",
          "ACCOUNT_STATUS_PENDING_CLOSURE",
          "ACCOUNT_STATUS_PENDING"
        ],
        "default": "ACCOUNT_STATUS_UNKNOWN",
        "x-enum-value-descriptions": {
          "ACCOUNT_STATUS_CANCELLED": "Account was requested but was never approved, it is now permanently closed.",
          "ACCOUNT_STATUS_CLOSED": "Account was previously open but is now permanently closed.",
          "ACCOUNT_STATUS_OPEN": "Account has been approved and transactions are allowed.",
          "ACCOUNT_STATUS_PENDING": "Account and contract record has been created, it is waiting for another call to be made open.",
          "ACCOUNT_STATUS_PENDING_CLOSURE": "Account was requested closure but contract and account closure are not finished.",
          "ACCOUNT_STATUS_UNKNOWN": "Default value."
        }
      },
      "accounts_commonAccounting": {
        "type": "object",
        "properties": {
          "tside": {
            "$ref": "#/components/schemas/accountingTside",
            "description": "The side of the balance sheet where the account balance is counted. Can be optionally provided when creating Internal Accounts. Has no effect if provided when creating Customer Accounts."
          }
        }
      },
      "commonOverrideRestrictions": {
        "type": "object",
        "properties": {
          "all": {
            "type": "boolean",
            "description": "The caller can override all restriction checks for a call by setting this field to true."
          },
          "restriction_set_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The caller can override restrictions based on restriction sets by passing the restriction set IDs here."
          },
          "restriction_set_definition_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The caller can override restrictions based on restriction set definitions by passing the restriction set definition IDs here."
          },
          "restriction_set_definition_version_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The caller can override restrictions based on restriction set definition versions by passing the restriction set definition version IDs here."
          }
        },
        "description": "OverrideRestrictions lets a caller override some or all restriction checks on a call by setting the relevant field or fields."
      },
      "commonOverrides": {
        "type": "object",
        "properties": {
          "override_restrictions": {
            "$ref": "#/components/schemas/commonOverrideRestrictions"
          }
        },
        "description": "Overrides are used to override certain checks for a request."
      },
      "authBatchGetServiceAccountsResponse": {
        "type": "object",
        "properties": {
          "service_accounts": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/authServiceAccount"
            },
            "description": "A map of requested IDs to their service accounts."
          }
        }
      },
      "authCreateServiceAccountRequest": {
        "type": "object",
        "properties": {
          "service_account": {
            "$ref": "#/components/schemas/authServiceAccount",
            "description": "The service account to be created. Only the service account name is required for service account creation.",
            "x-excluded-fields": [
              "id",
              "token",
              "status"
            ]
          },
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent. Retries work as normal but lead to new random tokens being generated.\n\nRequired.\nMax length: 256 characters."
          }
        },
        "required": [
          "request_id"
        ]
      },
      "authListServiceAccountsResponse": {
        "type": "object",
        "properties": {
          "service_accounts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/authServiceAccount"
            },
            "description": "The list of service accounts which match the parameters of the request. Service accounts are ordered by ascending ID."
          },
          "next_page_token": {
            "type": "string",
            "description": "Pagination token. This can be used as the page_token in subsequent requests to retrieve the next page of results. The next_page_token is empty when the final page of results has been reached."
          },
          "previous_page_token": {
            "type": "string",
            "description": "Pagination token. This can be used as the page_token in subsequent requests to retrieve the previous page of results. The previous_page_token is empty when the first page of results has been reached."
          }
        }
      },
      "authServiceAccount": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "A unique string ID for a service account. Output only."
          },
          "name": {
            "type": "string",
            "description": "The name of the service account. Must be unique for each service account. Required for service account creation."
          },
          "token": {
            "type": "string",
            "description": "A service account access token. Output only; only returned on service account creation and token refresh. The token will not expire."
          },
          "status": {
            "$ref": "#/components/schemas/authServiceAccountStatus",
            "description": "The status of the service account."
          },
          "permissions": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The names of the endpoints this service account is permitted to access."
          }
        },
        "title": "Representation of a service account"
      },
      "authServiceAccountStatus": {
        "type": "string",
        "enum": [
          "SERVICE_ACCOUNT_STATUS_UNKNOWN",
          "SERVICE_ACCOUNT_STATUS_ACTIVE",
          "SERVICE_ACCOUNT_STATUS_INACTIVE",
          "SERVICE_ACCOUNT_STATUS_FROZEN"
        ],
        "default": "SERVICE_ACCOUNT_STATUS_UNKNOWN",
        "x-enum-value-descriptions": {
          "SERVICE_ACCOUNT_STATUS_ACTIVE": "The service account is active and can authenticate.",
          "SERVICE_ACCOUNT_STATUS_FROZEN": "The service account has been frozen and transactions are temporarily prohibited.",
          "SERVICE_ACCOUNT_STATUS_INACTIVE": "The service account has been deactivated and is no longer visible to users.",
          "SERVICE_ACCOUNT_STATUS_UNKNOWN": "The service account status is unknown."
        }
      },
      "authServiceAccountTokenUpdateOptions": {
        "type": "object",
        "properties": {
          "refresh_token": {
            "type": "boolean",
            "description": "Replaces the existing service account token with a new service account token. A service account token can only be refreshed for an active service account. Token refresh cannot be performed at the same time as a status change."
          }
        }
      },
      "authUpdateServiceAccountPermissionsRequest": {
        "type": "object",
        "properties": {
          "service_account_id": {
            "type": "string",
            "description": "The ID of the service account that is to be updated. Required."
          },
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent. Required.\n\nRequired."
          },
          "items_to_add": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of items to be added to the list of service account permissions. Optional."
          },
          "items_to_remove": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of items to be removed from the list of service account permissions. Optional."
          }
        },
        "required": [
          "request_id"
        ]
      },
      "authUpdateServiceAccountRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent.\n\nRequired.\nMax length: 512 characters."
          },
          "service_account": {
            "$ref": "#/components/schemas/authServiceAccount",
            "description": "The service_account to be updated. Required.",
            "x-excluded-fields": [
              "id",
              "token",
              "name",
              "permissions"
            ]
          },
          "update_mask": {
            "$ref": "#/components/schemas/protobufFieldMask",
            "description": "A field mask used to indicate which fields on the resource are to be updated. Required if there are no token_update_options. Required for updating service account status. The service account status cannot be updated at the same time as a token refresh."
          },
          "token_update_options": {
            "$ref": "#/components/schemas/authServiceAccountTokenUpdateOptions",
            "description": "The type of update required for the service account token. Optional."
          }
        },
        "required": [
          "request_id"
        ]
      },
      "authValidateTokenResponse": {
        "type": "object",
        "properties": {
          "is_valid": {
            "type": "boolean",
            "description": "Indicates if the token attached to the metadata is valid."
          }
        }
      },
      "balancesBalance": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The ID of the balance. Output only.",
            "x-example-override": "b2d26233-9438-43b3-abe5-cda0db5dfcae"
          },
          "account_id": {
            "type": "string",
            "description": "The ID of the associated account.",
            "x-example-override": "bebbe4e5-fdcc-4247-a71d-8b02ba3d3b90"
          },
          "account_address": {
            "type": "string",
            "description": "The account address represents one partition of the total balances held on the account.",
            "x-example-override": "DEFAULT"
          },
          "phase": {
            "$ref": "#/components/schemas/v1PostingPhase",
            "description": "The posting phase the balance applies to."
          },
          "asset": {
            "type": "string",
            "description": "The asset in which the balance is held.",
            "x-example-override": "COMMERCIAL_BANK_MONEY"
          },
          "denomination": {
            "type": "string",
            "description": "The denomination in which the balance is held for the given asset.",
            "x-example-override": "GBP"
          },
          "posting_instruction_batch_id": {
            "type": "string",
            "description": "The ID of the logical posting instruction batch which yielded this balance.",
            "x-example-override": "76c0ea2b-57df-4314-af28-63c3cf49d7da"
          },
          "update_posting_instruction_batch_id": {
            "type": "string",
            "description": "A backdated posting will lead to new balance entries for every existing balance with a later value_time. The update_posting_instruction_batch_id refers to the backdated posting that has caused such an update to the logical balance entry, if any.",
            "x-example-override": "0489a697-8d6e-4fd1-9f1d-c521adf7a35b"
          },
          "value_time": {
            "type": "string",
            "format": "date-time",
            "description": "The value time corresponding to that of the posting instruction batch ID in RFC 3339 format.",
            "x-example-override": "2020-01-13T19:13:23.898Z"
          },
          "amount": {
            "type": "string",
            "description": "The amount is the net value of the balance.",
            "x-example-override": "90.90"
          },
          "total_debit": {
            "type": "string",
            "description": "The total sum of debits.",
            "x-example-override": "132.22"
          },
          "total_credit": {
            "type": "string",
            "description": "The total sum of credits.",
            "x-example-override": "223.12"
          }
        }
      },
      "balancesListBalancesLiveResponse": {
        "type": "object",
        "properties": {
          "balances": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/balancesBalance"
            },
            "description": "A list of matching balances."
          },
          "previous_page_token": {
            "type": "string",
            "description": "Token used to retrieve the previous page. If empty, returns the first page of results.",
            "x-example-override": "JSlaAnS"
          },
          "next_page_token": {
            "type": "string",
            "description": "Token used to retrieve the next page. If empty, returns the last page of results.",
            "x-example-override": "ASDllspa"
          }
        }
      },
      "balancesListBalancesTimeRangeResponse": {
        "type": "object",
        "properties": {
          "balances": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/balancesBalance"
            },
            "description": "A list of matching balances."
          },
          "previous_page_token": {
            "type": "string",
            "description": "Token used to retrieve the previous page. If empty, returns the first page of results.",
            "x-example-override": "gdeSSJDn"
          },
          "next_page_token": {
            "type": "string",
            "description": "Token used to retrieve the next page. If empty, returns the last page of results.",
            "x-example-override": "sdSAksad"
          }
        }
      },
      "v1PostingPhase": {
        "type": "string",
        "enum": [
          "POSTING_PHASE_UNKNOWN",
          "POSTING_PHASE_PENDING_INCOMING",
          "POSTING_PHASE_PENDING_OUTGOING",
          "POSTING_PHASE_COMMITTED"
        ],
        "default": "POSTING_PHASE_UNKNOWN",
        "description": "* PostingPhase characterises the phase of a Posting.",
        "x-enum-value-descriptions": {
          "POSTING_PHASE_COMMITTED": "The posting is committed (hard posting).",
          "POSTING_PHASE_PENDING_INCOMING": "The posting is pending incoming (soft posting).",
          "POSTING_PHASE_PENDING_OUTGOING": "The posting is pending outgoing (soft posting).",
          "POSTING_PHASE_UNKNOWN": "The posting phase is not set which will result in a validation error."
        }
      },
      "ChangeCurrentCalendarPeriodRequestAction": {
        "type": "string",
        "enum": [
          "UNKNOWN",
          "HOLD",
          "ROLL"
        ],
        "default": "UNKNOWN"
      },
      "CoreAPICalendarINVALID_ARGUMENT_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "INVALID_ARGUMENT"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsBadRequest",
                  "title": "BadRequest"
                }
              ]
            }
          }
        }
      },
      "CoreAPICalendarNOT_FOUND_1": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "NOT_FOUND"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsResourceInfo",
                  "title": "ResourceInfo"
                }
              ]
            }
          }
        }
      },
      "CreateCalendarALREADY_EXISTS_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "ALREADY_EXISTS"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsResourceInfo",
                  "title": "ResourceInfo"
                }
              ]
            }
          }
        }
      },
      "CreateCalendarEventALREADY_EXISTS_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "ALREADY_EXISTS"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsResourceInfo",
                  "title": "ResourceInfo"
                }
              ]
            }
          }
        }
      },
      "CreateCalendarPeriodDescriptorALREADY_EXISTS_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "ALREADY_EXISTS"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsResourceInfo",
                  "title": "ResourceInfo"
                }
              ]
            }
          }
        }
      },
      "ListCalendarsRequestOrderBy": {
        "type": "string",
        "enum": [
          "ORDER_BY_CREATE_TIMESTAMP_ASC",
          "ORDER_BY_CREATE_TIMESTAMP_DESC"
        ],
        "default": "ORDER_BY_CREATE_TIMESTAMP_ASC"
      },
      "ListCalendarsUNIMPLEMENTED_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "UNIMPLEMENTED"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          }
        }
      },
      "NamePatternMatchMatchType": {
        "type": "string",
        "enum": [
          "MATCH_TYPE_UNKNOWN",
          "MATCH_TYPE_TEXT_REGEX",
          "MATCH_TYPE_TEXT_EXACT_CASE_SENSITIVE",
          "MATCH_TYPE_TEXT_EXACT_CASE_INSENSITIVE",
          "MATCH_TYPE_TEXT_SUBSTRING_CASE_SENSITIVE",
          "MATCH_TYPE_TEXT_SUBSTRING_CASE_INSENSITIVE",
          "MATCH_TYPE_TEXT_PREFIX_CASE_SENSITIVE",
          "MATCH_TYPE_TEXT_PREFIX_CASE_INSENSITIVE"
        ],
        "default": "MATCH_TYPE_UNKNOWN",
        "x-enum-value-descriptions": {
          "MATCH_TYPE_TEXT_EXACT_CASE_SENSITIVE": "issues."
        }
      },
      "calendarBatchGetCalendarEventsResponse": {
        "type": "object",
        "properties": {
          "calendar_events": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/calendarCalendarEvent"
            },
            "description": "Maps the Calendar Event IDs to the requested Calendar Events."
          }
        }
      },
      "calendarBookkeepingDate": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The Bookkeeping Date ID is associated with the corresponding Calendar."
          },
          "date": {
            "type": "string",
            "description": "Specifies the date for the Bookkeeping Date. Must be in the ISO-8601 extended date format: YYYY-MM-DD, or empty. This date string would be used to annotate the next Calendar Period that will be emitted for the corresponding Calendar."
          }
        }
      },
      "calendarCalendar": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The Calendar ID can be specified by the user when creating the Calendar, otherwise it will be generated by the service. Must be unique."
          },
          "calendar_period_descriptor_id": {
            "type": "string",
            "description": "ID of the Calendar Period Descriptor associated with the Calendar.",
            "x-release-info": {
              "releaseVersion": {
                "major": 2,
                "minor": 6
              },
              "changeType": "ADD_FIELD"
            }
          },
          "is_active": {
            "type": "boolean",
            "description": "Defaults to false. Note that when is_active is set to false, calendar periods (if a Calendar Period Descriptor has been assigned) will not be produced. When is_active is later set to true, Calendar Period production will resume."
          },
          "create_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "Defaults to the current time of the request."
          },
          "display_name": {
            "type": "string",
            "description": "Human-readable name of the calendar. Optional.",
            "x-release-info": {
              "releaseVersion": {
                "major": 2,
                "minor": 4
              },
              "changeType": "ADD_FIELD"
            }
          },
          "description": {
            "type": "string",
            "description": "Description of the calendar. Optional.",
            "x-release-info": {
              "releaseVersion": {
                "major": 2,
                "minor": 4
              },
              "changeType": "ADD_FIELD"
            }
          }
        }
      },
      "calendarCalendarEvent": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The Calendar Event ID can be specified by the user when creating the Calendar Event, otherwise it will be generated by the service. Must be unique."
          },
          "calendar_id": {
            "type": "string",
            "description": "The Calendar this resource belongs to. Required for create requests."
          },
          "name": {
            "type": "string",
            "description": "The name of the Calendar Event displayed on the UI."
          },
          "is_active": {
            "type": "boolean",
            "description": "The current effective state of the Calendar Event."
          },
          "start_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time that the Calendar Event will be effective from (inclusive). Required for create requests."
          },
          "end_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time that the Calendar Event will be effective to (exclusive). Required for create requests."
          }
        }
      },
      "calendarCalendarPeriod": {
        "type": "object",
        "properties": {
          "expected_end_timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "End of the period"
          },
          "actual_end_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "This timestamp will be updated when holding (pausing of given calendar) or rolling (advancing the period forward), for operational/accounting purposes."
          },
          "period": {
            "type": "integer",
            "format": "int64",
            "description": "A monotonically increasing value derived from the date and start_period_epoch timestamp.\n\nRequired."
          },
          "expected_start_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "Start of current period, unmodified by hold/roll changes.",
            "x-release-info": {
              "releaseVersion": {
                "major": 2,
                "minor": 8
              },
              "changeType": "ADD_FIELD",
              "description": "This field describes the unmodified start time of a period."
            }
          },
          "actual_start_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "Start of current period, affected by hold/roll of previous period.",
            "x-release-info": {
              "releaseVersion": {
                "major": 2,
                "minor": 8
              },
              "changeType": "ADD_FIELD",
              "description": "This field describes the start time of a period after applying hold/roll adjustments."
            }
          },
          "calendar_id": {
            "type": "string",
            "description": "References the Calendar that the period belongs to.",
            "x-release-info": {
              "releaseVersion": {
                "major": 2,
                "minor": 8
              },
              "changeType": "ADD_FIELD",
              "description": "This field describes the Calendar that this Calendar Period belongs to."
            }
          },
          "calendar_period_descriptor_id": {
            "type": "string",
            "description": "References the Calendar Period Descriptor that was used to generate the period.",
            "x-release-info": {
              "releaseVersion": {
                "major": 2,
                "minor": 8
              },
              "changeType": "ADD_FIELD",
              "description": "This field describes the Calendar Period Descriptor that this period was generated with."
            }
          },
          "bookkeeping_label": {
            "type": "string",
            "description": "Bookkeeping label, in the ISO-8601 extended date format YYYY-MM-DD. This field is populated using the date from the most recently associated UpdateBookkeepingDate call.",
            "x-release-info": {
              "releaseVersion": {
                "major": 3,
                "minor": 1
              },
              "changeType": "ADD_FIELD",
              "description": "This field describes the Bookkeeping label, in the ISO-8601 date format YYYY-MM-DD."
            }
          }
        },
        "required": [
          "period"
        ]
      },
      "calendarCalendarPeriodDescriptor": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The Calendar Period Descriptor ID can be specified by the user when creating the Calendar Period Descriptor, otherwise it will be generated by the service. Must be unique."
          },
          "name": {
            "type": "string",
            "description": "Name of the period descriptor."
          },
          "start_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time the Calendar Period is measured from. Defaults to the current time."
          },
          "resolution": {
            "$ref": "#/components/schemas/calendarPeriodResolution",
            "description": "The Period Resolution determines the size of each period. This is fixed to 1 day. Read only."
          }
        }
      },
      "calendarChangeCurrentCalendarPeriodRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "Unique ID that is used to identify the request.\n\nRequired."
          },
          "calendar_id": {
            "type": "string",
            "description": "ID of the calendar.\n\nRequired."
          },
          "action": {
            "$ref": "#/components/schemas/ChangeCurrentCalendarPeriodRequestAction",
            "description": "Action to perform on the current calendar period.\n\nRequired."
          },
          "action_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "When to Roll to/Until when to Hold. Cannot be in the past. Defaults to the current system timestamp in UTC."
          }
        },
        "required": [
          "request_id",
          "calendar_id",
          "action"
        ]
      },
      "calendarCreateCalendarEventRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique ID that is used to identify the request.\n\nRequired."
          },
          "calendar_event": {
            "$ref": "#/components/schemas/calendarCalendarEvent",
            "description": "The new Calendar Event resource that is to be created.\n\nRequired."
          }
        },
        "description": "A request to create a Calendar Event.",
        "required": [
          "request_id",
          "calendar_event"
        ]
      },
      "calendarCreateCalendarPeriodDescriptorRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "The ID of the request used for idempotency.\n\nRequired."
          },
          "calendar_period_descriptor": {
            "$ref": "#/components/schemas/calendarCalendarPeriodDescriptor",
            "description": "The Calendar Period Descriptor.\n\nRequired."
          }
        },
        "required": [
          "request_id",
          "calendar_period_descriptor"
        ]
      },
      "calendarCreateCalendarRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique ID that is used to identify the request.\n\nRequired."
          },
          "calendar": {
            "$ref": "#/components/schemas/calendarCalendar",
            "description": "The new Calendar resource that is to be created.\n\nRequired."
          }
        },
        "title": "A request to create a new Calendar",
        "required": [
          "request_id",
          "calendar"
        ]
      },
      "calendarListCalendarEventsResponse": {
        "type": "object",
        "properties": {
          "calendar_events": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/calendarCalendarEvent"
            }
          },
          "previous_page_token": {
            "type": "string",
            "description": "Token used to retrieve the previous page. If empty, this is the first page of results."
          },
          "next_page_token": {
            "type": "string",
            "description": "Token used to retrieve the next page. If empty, this is the last page of results."
          }
        }
      },
      "calendarListCalendarsResponse": {
        "type": "object",
        "properties": {
          "calendars": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/calendarCalendar"
            },
            "description": "Contains the list of requested Calendars."
          },
          "previous_page_token": {
            "type": "string",
            "description": "Token used to retrieve the previous page. If empty, this is the first page of results."
          },
          "next_page_token": {
            "type": "string",
            "description": "Token used to retrieve the next page. If empty, this is the last page of results."
          }
        }
      },
      "calendarNamePatternMatch": {
        "type": "object",
        "properties": {
          "pattern": {
            "type": "string"
          },
          "match_type": {
            "$ref": "#/components/schemas/NamePatternMatchMatchType"
          }
        }
      },
      "calendarPeriodResolution": {
        "type": "object",
        "properties": {
          "unit": {
            "$ref": "#/components/schemas/calendarTimeUnit",
            "description": "Defines the granularity of a time period.\n\nRequired."
          },
          "value": {
            "type": "integer",
            "format": "int64",
            "description": "Defines the quantity of the Unit specified in the Unit field.\n\nRequired."
          }
        },
        "required": [
          "unit",
          "value"
        ]
      },
      "calendarTimeUnit": {
        "type": "string",
        "enum": [
          "TIME_UNIT_UNKNOWN",
          "TIME_UNIT_HOURS",
          "TIME_UNIT_DAYS",
          "TIME_UNIT_WEEKS",
          "TIME_UNIT_MONTHS",
          "TIME_UNIT_YEARS"
        ],
        "default": "TIME_UNIT_UNKNOWN"
      },
      "calendarUpdateBookkeepingDateRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "The ID of the request, for idempotency.\n\nRequired."
          },
          "id": {
            "type": "string",
            "description": "\n\nRequired.",
            "title": "The ID, which is linked to the Calendar that will be affected"
          },
          "bookkeeping_date": {
            "$ref": "#/components/schemas/calendarBookkeepingDate",
            "description": "The data to be updated to.\n\nRequired."
          },
          "update_mask": {
            "$ref": "#/components/schemas/protobufFieldMask",
            "description": "\n\nRequired.",
            "title": "A mask of fields to be updated. This should only be \"date\""
          }
        },
        "required": [
          "request_id",
          "id",
          "bookkeeping_date",
          "update_mask"
        ]
      },
      "calendarUpdateCalendarEventRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "The ID of the request used for idempotency.\n\nRequired."
          },
          "calendar_event_id": {
            "type": "string",
            "description": "The ID of the calendar event that is to be updated.\n\nRequired."
          },
          "calendar_event": {
            "$ref": "#/components/schemas/calendarCalendarEvent",
            "description": "The calendar event fields that are to be updated.\n\nRequired.",
            "x-excluded-fields": [
              "id",
              "calendar_id",
              "start_timestamp",
              "end_timestamp"
            ]
          },
          "update_mask": {
            "$ref": "#/components/schemas/protobufFieldMask",
            "description": "A mask of calendar event fields that are to be updated.\n\nRequired."
          }
        },
        "required": [
          "request_id",
          "calendar_event_id",
          "calendar_event",
          "update_mask"
        ]
      },
      "calendarUpdateCalendarRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "The ID of the request used for idempotency.\n\nRequired."
          },
          "calendar_id": {
            "type": "string",
            "description": "The ID of the calendar that is to be updated.\n\nRequired."
          },
          "calendar": {
            "$ref": "#/components/schemas/calendarCalendar",
            "description": "The calendar fields that are to be updated.\n\nRequired.",
            "x-excluded-fields": [
              "id",
              "create_timestamp",
              "calendar_period_descriptor_id"
            ]
          },
          "update_mask": {
            "$ref": "#/components/schemas/protobufFieldMask",
            "description": "A mask of calendar fields that are to be updated.\n\nRequired."
          }
        },
        "required": [
          "request_id",
          "calendar_id",
          "calendar",
          "update_mask"
        ]
      },
      "BatchGetContractModuleVersionsRequestIncludeField": {
        "type": "string",
        "enum": [
          "INCLUDE_FIELD_CODE",
          "INCLUDE_FIELD_DETAILS_API_VERSION",
          "INCLUDE_FIELD_DETAILS_CALLABLE_DETAILS"
        ],
        "default": "INCLUDE_FIELD_CODE"
      },
      "contract_modulesBatchGetContractModuleVersionsResponse": {
        "type": "object",
        "properties": {
          "contract_module_versions": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/contract_modulesContractModuleVersion"
            },
            "description": "Map of ID to Contract Module Version."
          }
        }
      },
      "contract_modulesBatchGetContractModulesResponse": {
        "type": "object",
        "properties": {
          "contract_modules": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/contract_modulesContractModule"
            },
            "description": "Map of ID to Contract Module."
          }
        }
      },
      "contract_modulesBatchGetSmartContractModuleVersionsLinksResponse": {
        "type": "object",
        "properties": {
          "smart_contract_module_versions_links": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/contract_modulesSmartContractModuleVersionsLink"
            },
            "description": "Map of ID to Smart Contract Module Versions Link."
          }
        }
      },
      "contract_modulesContractModule": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "A unique ID. Can be provided by the client, otherwise it will be a service-generated UUID.\n"
          },
          "create_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp indicating when it was created.",
            "x-output-only": true
          },
          "display_name": {
            "type": "string",
            "description": "The human-readable name. Required for create requests."
          },
          "description": {
            "type": "string",
            "description": "The human-readable description.\n"
          }
        }
      },
      "contract_modulesContractModuleCodeDetails": {
        "type": "object",
        "properties": {
          "api_version": {
            "$ref": "#/components/schemas/versionSemVer",
            "description": "The Contracts language library version of the Contract Module."
          },
          "shared_function_details": {
            "$ref": "#/components/schemas/contract_modulesSharedFunctionDetails",
            "description": "The shared function details of the Contract Module."
          }
        }
      },
      "contract_modulesContractModuleVersion": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "A unique ID. Can be provided by the client, otherwise it will be a service-generated UUID.\n"
          },
          "create_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp indicating when it was created.",
            "x-output-only": true
          },
          "contract_module_id": {
            "type": "string",
            "description": "The ID of the Contract Module of which this is a version."
          },
          "display_name": {
            "type": "string",
            "description": "The human-readable name. Required for create requests."
          },
          "description": {
            "type": "string",
            "description": "The human-readable description.\n"
          },
          "code": {
            "type": "string",
            "description": "The source code."
          },
          "contract_module_code_details": {
            "$ref": "#/components/schemas/contract_modulesContractModuleCodeDetails",
            "description": "Additional information about the Contract Module derived from the code."
          }
        }
      },
      "contract_modulesCreateContractModuleRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID that is used to ensure the request is idempotent."
          },
          "contract_module": {
            "$ref": "#/components/schemas/contract_modulesContractModule",
            "description": "The Contract Module to be created.\n\nRequired.",
            "x-excluded-fields": [
              "create_timestamp"
            ]
          }
        },
        "required": [
          "contract_module"
        ]
      },
      "contract_modulesCreateContractModuleVersionRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID that is used to ensure the request is idempotent."
          },
          "contract_module_version": {
            "$ref": "#/components/schemas/contract_modulesContractModuleVersion",
            "description": "The Contract Module Version to be created.\n\nRequired.",
            "x-excluded-fields": [
              "create_timestamp",
              "contract_module_code_details"
            ]
          }
        },
        "required": [
          "contract_module_version"
        ]
      },
      "contract_modulesCreateSmartContractModuleVersionsLinkRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID that is used to ensure the request is idempotent."
          },
          "smart_contract_module_versions_link": {
            "$ref": "#/components/schemas/contract_modulesSmartContractModuleVersionsLink",
            "description": "The Smart Contract Module Versions Link to be created.\n\nRequired.",
            "x-excluded-fields": [
              "create_timestamp"
            ]
          }
        },
        "required": [
          "smart_contract_module_versions_link"
        ]
      },
      "contract_modulesListContractModuleVersionsResponse": {
        "type": "object",
        "properties": {
          "contract_module_versions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/contract_modulesContractModuleVersion"
            },
            "description": "A list of Contract Module Versions, ordered by descending creation timestamp.",
            "x-excluded-fields": [
              "code",
              "contract_module_code_details"
            ]
          },
          "next_page_token": {
            "type": "string",
            "description": "The token used to retrieve the next page. If empty, this returns the last page of results."
          },
          "previous_page_token": {
            "type": "string",
            "description": "The token used to retrieve the previous page. If empty, this returns the first page of results."
          }
        }
      },
      "contract_modulesListContractModulesResponse": {
        "type": "object",
        "properties": {
          "contract_modules": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/contract_modulesContractModule"
            },
            "description": "A list of Contract Modules, ordered by descending creation timestamp."
          },
          "next_page_token": {
            "type": "string",
            "description": "The token used to retrieve the next page. If empty, this returns the last page of results."
          },
          "previous_page_token": {
            "type": "string",
            "description": "The token used to retrieve the previous page. If empty, this returns the first page of results."
          }
        }
      },
      "contract_modulesListSmartContractModuleVersionsLinksResponse": {
        "type": "object",
        "properties": {
          "smart_contract_module_versions_links": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/contract_modulesSmartContractModuleVersionsLink"
            },
            "description": "A list of Smart Contract Module Versions Links, ordered by descending creation timestamp."
          },
          "next_page_token": {
            "type": "string",
            "description": "The token used to retrieve the next page. If empty, this returns the last page of results."
          },
          "previous_page_token": {
            "type": "string",
            "description": "The token used to retrieve the previous page. If empty, this returns the first page of results."
          }
        }
      },
      "contract_modulesSharedFunction": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the Contract Module function.\n\nRequired."
          },
          "args": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/contract_modulesSharedFunctionArg"
            },
            "description": "The arguments of the Contract Module function."
          },
          "return_type": {
            "type": "string",
            "description": "The return type of the Contract Module function."
          }
        },
        "required": [
          "name"
        ]
      },
      "contract_modulesSharedFunctionArg": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the Contract Module function argument.\n\nRequired."
          },
          "type": {
            "type": "string",
            "description": "The type of the Contract Module function argument."
          }
        },
        "required": [
          "name"
        ]
      },
      "contract_modulesSharedFunctionDetails": {
        "type": "object",
        "properties": {
          "shared_functions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/contract_modulesSharedFunction"
            },
            "description": "The shared functions that are implemented in the Contract Module."
          }
        }
      },
      "contract_modulesSmartContractModuleVersionsLink": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "A unique ID. Can be provided by the client, otherwise it will be a service-generated UUID.\n"
          },
          "smart_contract_version_id": {
            "type": "string",
            "description": "The ID of the Smart Contract Version this link relates to. Required for create requests."
          },
          "alias_to_contract_module_version_id": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Map of alias to ContractModuleVersionID containing all Contract Module Versions that are linked to the Smart Contract Version ID. The alias is defined by the Smart Contract code. A link must provide Contract Module Version IDs for all aliases defined in the Smart Contract. Required for create requests."
          },
          "create_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp indicating when it was created.",
            "x-output-only": true
          }
        }
      },
      "versionSemVer": {
        "type": "object",
        "properties": {
          "major": {
            "type": "integer",
            "format": "int32",
            "description": "The major version number."
          },
          "minor": {
            "type": "integer",
            "format": "int32",
            "description": "The minor version number."
          },
          "patch": {
            "type": "integer",
            "format": "int32",
            "description": "The patch version number."
          },
          "label": {
            "type": "string",
            "description": "The version label. Example: \"-beta\"."
          }
        },
        "description": "Minimal representation of a Semantic Versioning Specification (SemVer) version. For more information go to http://semver.org. If you require a Semantic Versioning representation in your proto you MUST use this common proto."
      },
      "ExistingProductDataBehaviourDataType": {
        "type": "string",
        "enum": [
          "UNKNOWN",
          "GLOBAL_PARAMETERS",
          "TEMPLATE_PARAMETERS",
          "CALENDARS"
        ],
        "default": "UNKNOWN"
      },
      "accounts_commonAccountNote": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The ID of the AccountNote."
          },
          "account_id": {
            "type": "string",
            "description": "The ID of the Account the AccountNote applies to."
          },
          "body": {
            "type": "string",
            "description": "The body of the AccountNote; see the type field for its meaning."
          },
          "type": {
            "$ref": "#/components/schemas/accounts_commonAccountNoteType",
            "description": "The \"type\" of the note, i.e. how to interpret the body field."
          },
          "effective_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The logical time the AccountNote was created at."
          },
          "is_visible_to_customer": {
            "type": "boolean",
            "description": "Whether the AccountNote is visible to customers or internal only."
          }
        }
      },
      "accounts_commonAccountNoteType": {
        "type": "string",
        "enum": [
          "ACCOUNT_NOTE_TYPE_UNKNOWN",
          "ACCOUNT_NOTE_TYPE_RAW_TEXT",
          "ACCOUNT_NOTE_TYPE_REASON_CODE"
        ],
        "default": "ACCOUNT_NOTE_TYPE_UNKNOWN",
        "x-enum-value-descriptions": {
          "ACCOUNT_NOTE_TYPE_RAW_TEXT": "The body is a literal string containing plaintext.",
          "ACCOUNT_NOTE_TYPE_REASON_CODE": "The body contains a reason code.",
          "ACCOUNT_NOTE_TYPE_UNKNOWN": "Default value."
        }
      },
      "contract_notificationResource": {
        "type": "string",
        "enum": [
          "RESOURCE_UNKNOWN",
          "RESOURCE_ACCOUNT",
          "RESOURCE_PLAN"
        ],
        "default": "RESOURCE_UNKNOWN",
        "title": "Resource is used to represent if a notification was generated by an account or plan resource (i.e. a contract or supervisor contract respectively)",
        "x-enum-value-descriptions": {
          "RESOURCE_ACCOUNT": "Indicates that the ContractNotificationEvent was generated for an Account resource;",
          "RESOURCE_PLAN": "Indicates that the ContractNotificationEvent was generated for a Plan resource;",
          "RESOURCE_UNKNOWN": "Default value."
        }
      },
      "contractsAccountNotes": {
        "type": "object",
        "properties": {
          "account_notes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/accounts_commonAccountNote"
            },
            "description": "Account notes for the account."
          }
        }
      },
      "contractsBalances": {
        "type": "object",
        "properties": {
          "balances": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/balancesBalance"
            },
            "description": "Balances for the account."
          }
        }
      },
      "contractsContractNotificationEvents": {
        "type": "object",
        "properties": {
          "contract_notification_events": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/v1contractsContractNotificationEvent"
            },
            "title": "Contract notification events for the plan or account"
          }
        }
      },
      "contractsCreateGlobalParameterInstruction": {
        "type": "object",
        "properties": {
          "global_parameter": {
            "$ref": "#/components/schemas/global_parametersGlobalParameter",
            "description": "The `GlobalParameter` to be created.",
            "x-excluded-fields": [
              "create_timestamp"
            ]
          },
          "initial_value": {
            "type": "string",
            "description": "This will be used to create a `GlobalParameterValue` associated with the newly created `GlobalParameter`."
          }
        }
      },
      "contractsDerivedParamsOutputRequest": {
        "type": "object",
        "properties": {
          "account_id": {
            "type": "string",
            "description": "The account ID that derived parameters are to be retrieved for."
          }
        }
      },
      "contractsDerivedParamsVals": {
        "type": "object",
        "properties": {
          "values": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "The values of the derived parameters."
          }
        }
      },
      "contractsExistingAccount": {
        "type": "object",
        "properties": {
          "account_id": {
            "type": "string",
            "description": "ID used to reference an existing Account from the Vault instance.\n\nRequired."
          },
          "is_internal": {
            "type": "boolean",
            "description": "Identifies whether the existing Account is an internal account or not. If unspecified, will default to being a non internal account."
          }
        },
        "required": [
          "account_id"
        ]
      },
      "contractsExistingContractModule": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "ID used to reference an existing Contract Module Version from the Vault instance.\n\nRequired."
          }
        },
        "required": [
          "id"
        ]
      },
      "contractsExistingProductDataBehaviour": {
        "type": "object",
        "properties": {
          "include_all": {
            "type": "boolean"
          },
          "include_data_types": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ExistingProductDataBehaviourDataType"
            }
          }
        }
      },
      "contractsExistingSmartContract": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "ID used to reference an existing Smart Contract template from the Vault instance.\n\nRequired."
          }
        },
        "required": [
          "id"
        ]
      },
      "contractsExistingSupervisorContract": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "ID used to reference an existing Supervisor Contract Version from the Vault instance.\n\nRequired."
          }
        },
        "required": [
          "id"
        ]
      },
      "contractsInstantiateWorkflowRequest": {
        "type": "object",
        "properties": {
          "workflow_definition_id": {
            "type": "string",
            "description": "The ID of the Workflow Definition."
          },
          "context": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "The initial data that was sent to the Workflow."
          }
        }
      },
      "contractsInstantiateWorkflowRequests": {
        "type": "object",
        "properties": {
          "instantiate_workflow_requests": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/contractsInstantiateWorkflowRequest"
            },
            "description": "Workflow instantiation requests for the account."
          }
        }
      },
      "contractsSimulateContractsInstruction": {
        "type": "object",
        "properties": {
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "Time of the instruction. Its exact meaning depends on the type of instruction.\n\nRequired."
          },
          "create_account": {
            "$ref": "#/components/schemas/accountsAccount",
            "required": false
          },
          "create_posting_instruction_batch": {
            "$ref": "#/components/schemas/v1PostingInstructionBatch",
            "required": false
          },
          "create_global_parameter": {
            "$ref": "#/components/schemas/contractsCreateGlobalParameterInstruction",
            "required": false
          },
          "create_global_parameter_value": {
            "$ref": "#/components/schemas/global_parametersGlobalParameterValue",
            "required": false
          },
          "create_flag_definition": {
            "$ref": "#/components/schemas/flagsFlagDefinition",
            "required": false
          },
          "create_flag": {
            "$ref": "#/components/schemas/flagsFlag",
            "required": false
          },
          "create_plan": {
            "$ref": "#/components/schemas/plansPlan",
            "required": false
          },
          "create_account_plan_assoc": {
            "$ref": "#/components/schemas/plansAccountPlanAssoc",
            "required": false
          },
          "create_account_update": {
            "$ref": "#/components/schemas/accountsAccountUpdate",
            "required": false
          },
          "update_account": {
            "$ref": "#/components/schemas/accountsAccount",
            "required": false
          },
          "create_calendar": {
            "$ref": "#/components/schemas/calendarCalendar",
            "required": false
          },
          "create_calendar_event": {
            "$ref": "#/components/schemas/calendarCalendarEvent",
            "required": false
          },
          "create_smart_contract_module_versions_link": {
            "$ref": "#/components/schemas/contract_modulesSmartContractModuleVersionsLink",
            "required": false
          },
          "update_smart_contract_param": {
            "$ref": "#/components/schemas/contractsUpdateSmartContractParamInstruction",
            "required": false
          }
        },
        "required": [
          "timestamp"
        ]
      },
      "contractsSimulateContractsOutputRequest": {
        "type": "object",
        "properties": {
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The timestamp used to calculate the output.\n\nRequired."
          },
          "derived_params": {
            "$ref": "#/components/schemas/contractsDerivedParamsOutputRequest",
            "required": true
          }
        },
        "required": [
          "timestamp"
        ]
      },
      "contractsSimulateContractsRequest": {
        "type": "object",
        "properties": {
          "start_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "Start time of the simulation.\n\nRequired."
          },
          "end_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "End time of the simulation. Instructions with a timestamp after this one will be rejected and the simulation will not start.\n\nRequired."
          },
          "smart_contracts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/contractsSmartContract"
            },
            "description": "A list of new Smart Contracts that can be used within simulation."
          },
          "existing_smart_contracts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/contractsExistingSmartContract"
            },
            "description": "A list existing Smart Contracts within Vault that can be used within simulation.",
            "x-release-info": {
              "releaseVersion": {
                "major": 4,
                "minor": 5
              },
              "changeType": "ADD_FIELD",
              "description": "Specify existing smart contracts to Simulate"
            }
          },
          "supervisor_contracts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/contractsSupervisorContract"
            },
            "description": "A list of new Supervisor Contracts that can be used within simulation. Although this is a list field, only one Supervisor Contract can currently be simulated for each request."
          },
          "existing_supervisor_contracts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/contractsExistingSupervisorContract"
            },
            "description": "A list of existing Supervisor Contracts that can be referenced within simulation.",
            "x-release-info": {
              "releaseVersion": {
                "major": 4,
                "minor": 5
              },
              "changeType": "ADD_FIELD",
              "description": "Specify existing supervisor contracts to Simulate"
            }
          },
          "contract_modules": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/v1contractsContractModule"
            },
            "description": "A list of new Contract Modules that can be referenced within simulation."
          },
          "existing_contract_modules": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/contractsExistingContractModule"
            },
            "description": "A list of existing Contract Modules that can be referenced within simulation.",
            "x-release-info": {
              "releaseVersion": {
                "major": 4,
                "minor": 5
              },
              "changeType": "ADD_FIELD",
              "description": "Specify existing contract modules to Simulate"
            }
          },
          "existing_accounts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/contractsExistingAccount"
            },
            "description": "A list of existing accounts to simulate.\n\nNote that any accounts specified within this list will have their Smart Contract versions as of `start_timestamp` fetched automatically. The product data associated with these Smart Contracts will be included or not based on the `existing_product_data_behaviour` field. Any account associated data (parameters, postings, balances, etc.) required by _any_ hooks defined in their Smart Contracts will always be fetched from the Vault instance as of `start_timestamp` and included in simulation.",
            "x-release-info": {
              "releaseVersion": {
                "major": 4,
                "minor": 5
              },
              "changeType": "ADD_FIELD",
              "description": "Specify existing accounts to Simulate"
            }
          },
          "existing_product_data_behaviour": {
            "$ref": "#/components/schemas/contractsExistingProductDataBehaviour",
            "description": "ExistingProductDataBehaviour is an optional field to control behaviour for whether or not simulation will fetch and include product data in simulation. Product data are data types available in contracts that are associated with products. That is, global parameters, template parameters, and calendar events.\n\nIf unspecified, the default behaviour is to fetch and include no product data.\n\nIf set, Simulation includes product data required by products specified in the request via: new or existing smart contracts, new or existing supervisor contracts, or existing smart contracts fetched due to specified existing accounts.",
            "x-release-info": {
              "releaseVersion": {
                "major": 4,
                "minor": 5
              },
              "changeType": "ADD_FIELD",
              "description": "Specify behaviour for including existing product data in Simulation"
            }
          },
          "instructions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/contractsSimulateContractsInstruction"
            },
            "description": "A list of timestamped exogenous instructions for simulation. These instructions dictate external events, such as postings or parameter updates, which (alongside the actual contract code) shape the simulation scenario."
          },
          "outputs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/contractsSimulateContractsOutputRequest"
            },
            "description": "A list of requests for data that is to be returned.",
            "x-release-info": {
              "releaseVersion": {
                "major": 2,
                "minor": 1
              },
              "changeType": "ADD_FIELD",
              "description": "Adds support for output requests to simulation"
            }
          }
        },
        "required": [
          "start_timestamp",
          "end_timestamp"
        ]
      },
      "contractsSimulateContractsResponse": {
        "type": "object",
        "properties": {
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp indicating when this response was generated."
          },
          "logs": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A text log that can contain additional information about the simulation. It can include the information about schedule changes, the this response was generated, etc. The information in this log is unstructured and must not be relied upon, as it can change without notice from one Vault release to the other."
          },
          "posting_instruction_batches": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/v1PostingInstructionBatch"
            },
            "description": "All Posting Instruction Batches created."
          },
          "balances": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/contractsBalances"
            },
            "description": "All balance changes created. Keyed on account ID."
          },
          "account_notes": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/contractsAccountNotes"
            },
            "description": "All account notes created. Keyed on account ID."
          },
          "instantiate_workflow_requests": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/contractsInstantiateWorkflowRequests"
            },
            "description": "All Workflow instantiation requests created. Keyed on account ID."
          },
          "derived_params": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/contractsDerivedParamsVals"
            },
            "description": "All derived parameters. Keyed on account ID.",
            "x-release-info": {
              "releaseVersion": {
                "major": 2,
                "minor": 1
              },
              "changeType": "ADD_FIELD",
              "description": "Adds support to return derived parameters"
            }
          },
          "contract_notification_events": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/contractsContractNotificationEvents"
            },
            "description": "All Contract notification events created. Keyed on resource ID.",
            "x-release-info": {
              "releaseVersion": {
                "major": 4,
                "minor": 1
              },
              "changeType": "ADD_FIELD",
              "description": "Adds support to return contract notification events"
            }
          }
        }
      },
      "contractsSmartContract": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "description": "Source code of the Smart Contract that is to be simulated."
          },
          "smart_contract_param_vals": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Values for the Smart Contract parameters."
          },
          "smart_contract_version_id": {
            "type": "string",
            "description": "The ID that will be used as the Smart Contract ID in the simulation and can be referenced by the simulation instructions."
          }
        }
      },
      "contractsSupervisorContract": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "description": "Source code of the Supervisor Contract that is to be simulated."
          },
          "supervisor_contract_version_id": {
            "type": "string",
            "description": "The ID that will be used as the Supervisor Contract version ID in the simulation and can be referenced by the simulation instructions."
          }
        }
      },
      "contractsUpdateSmartContractParamInstruction": {
        "type": "object",
        "properties": {
          "smart_contract_version_id": {
            "type": "string",
            "description": "The smart contract ID of the version to be updated.\n\nRequired."
          },
          "parameter_name": {
            "type": "string",
            "description": "\n\nRequired.",
            "title": "The template parameter that is to be updated"
          },
          "new_parameter_value": {
            "type": "string",
            "description": "The new value for the parameter that is to be added to the smart contract parameter timeseries.\n\nRequired."
          }
        },
        "required": [
          "smart_contract_version_id",
          "parameter_name",
          "new_parameter_value"
        ]
      },
      "flagsFlag": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The ID of the flag. Output only."
          },
          "flag_definition_id": {
            "type": "string",
            "description": "The ID of the flag definition. Required for create requests."
          },
          "description": {
            "type": "string",
            "description": "The description of the flag. Required for create requests."
          },
          "creation_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The timestamp indicating when the flag was created. Output only.",
            "x-output-only": true
          },
          "effective_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The timestamp indicating when the flag was activated. Optional for create requests; must be set to a future time.\n"
          },
          "expiry_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The timestamp indicating when the flag was deactivated. Optional for create requests; must be set to after the effective timestamp time.\n"
          },
          "is_active": {
            "type": "boolean",
            "description": "Indicates if the flag is active. Update only."
          },
          "customer_id": {
            "$ref": "#/components/schemas/customer_id",
            "required": false
          },
          "account_id": {
            "$ref": "#/components/schemas/account_id",
            "required": false
          },
          "payment_device_id": {
            "$ref": "#/components/schemas/payment_device_id",
            "required": false
          }
        }
      },
      "flagsFlagDefinition": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The ID of the flag definition. Must equal the flag definition name when creating a flag definition. Required for create requests."
          },
          "name": {
            "type": "string",
            "description": "The name of the flag definition. Must be unique. Required for create requests."
          },
          "description": {
            "type": "string",
            "description": "The description of the flag definition. Optional for create requests.\n"
          },
          "required_flag_level": {
            "$ref": "#/components/schemas/flagsFlagLevel",
            "description": "The level required to create this flag. Required for create requests."
          },
          "create_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time the flag definition was created. Output only."
          },
          "flag_visibility": {
            "$ref": "#/components/schemas/flagsFlagVisibility",
            "description": "The flag visibility. Used to hide flags from users where these are not relevant to them. Used when listing flags. Required for create requests."
          },
          "is_active": {
            "type": "boolean",
            "description": "Indicates if the flag definition is active. Update only."
          }
        }
      },
      "flagsFlagLevel": {
        "type": "string",
        "enum": [
          "FLAG_LEVEL_UNKNOWN",
          "FLAG_LEVEL_CUSTOMER",
          "FLAG_LEVEL_ACCOUNT",
          "FLAG_LEVEL_PAYMENT_DEVICE"
        ],
        "default": "FLAG_LEVEL_UNKNOWN",
        "description": "The levels the flag applies to.",
        "x-enum-value-descriptions": {
          "FLAG_LEVEL_ACCOUNT": "Makes a flag apply to the account ID.",
          "FLAG_LEVEL_CUSTOMER": "Makes a flag apply to the customer ID.",
          "FLAG_LEVEL_PAYMENT_DEVICE": "Makes a flag apply to the payment device ID.",
          "FLAG_LEVEL_UNKNOWN": "Used where the flag level is unknown."
        }
      },
      "flagsFlagVisibility": {
        "type": "string",
        "enum": [
          "FLAG_VISIBILITY_UNKNOWN",
          "FLAG_VISIBILITY_CONTRACT",
          "FLAG_VISIBILITY_OPERATOR"
        ],
        "default": "FLAG_VISIBILITY_UNKNOWN",
        "description": "The visibility of the flag.",
        "x-enum-value-descriptions": {
          "FLAG_VISIBILITY_CONTRACT": "The flag is visible only to Smart Contracts.",
          "FLAG_VISIBILITY_OPERATOR": "The flag is visible to UI operators and Smart Contracts.",
          "FLAG_VISIBILITY_UNKNOWN": "Used where the flag visibility is unknown."
        }
      },
      "global_parametersGlobalParameter": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The `GlobalParameter` ID. Used by Smart Contracts to retrieve values for this parameter.\n\nRequired."
          },
          "display_name": {
            "type": "string",
            "description": "A human-readable name.\n\nRequired."
          },
          "description": {
            "type": "string",
            "description": "A description of the parameter.\n\nRequired."
          },
          "create_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "A timestamp indicating when the `GlobalParameter` was created."
          },
          "number": {
            "$ref": "#/components/schemas/paramsNumberField",
            "required": false
          },
          "str": {
            "$ref": "#/components/schemas/paramsStringField",
            "required": false
          },
          "denomination": {
            "$ref": "#/components/schemas/paramsDenominationField",
            "required": false
          },
          "date": {
            "$ref": "#/components/schemas/paramsDateField",
            "required": false
          }
        },
        "description": "A `GlobalParameter` describes the metadata and shape of a parameter.",
        "required": [
          "id",
          "display_name",
          "description"
        ]
      },
      "global_parametersGlobalParameterValue": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The `GlobalParameterValue` ID."
          },
          "global_parameter_id": {
            "type": "string",
            "description": "The `GlobalParameter` ID this value belongs to.\n\nRequired."
          },
          "value": {
            "type": "string",
            "description": "The actual value. This is stored as a string and is processed together with the information stored in the associated `GlobalParameter`. This will determine how the value is parsed or displayed. For Date Global Parameters, it is in the format `YYYY-MM-DD`.\n\nRequired."
          },
          "effective_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "A timestamp indicating when the `GlobalParameterValue` is effective from.\n\nRequired."
          },
          "create_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "A timestamp indicating when the `GlobalParameterValue` was created."
          }
        },
        "description": "A `GlobalParameterValue` contains the value for a `GlobalParameter` at a specified `effective_timestamp`.",
        "required": [
          "global_parameter_id",
          "value",
          "effective_timestamp"
        ]
      },
      "paramsDate": {
        "type": "object",
        "properties": {
          "year": {
            "type": "integer",
            "format": "int32",
            "description": "The year of the specified date."
          },
          "month": {
            "type": "integer",
            "format": "int32",
            "description": "The month of the specified date."
          },
          "day": {
            "type": "integer",
            "format": "int32",
            "description": "The day of the specified date."
          }
        }
      },
      "paramsDateField": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/paramsDateType",
            "description": "The date type of the parameter."
          },
          "start": {
            "$ref": "#/components/schemas/paramsDate",
            "description": "The start date of the parameter."
          },
          "end": {
            "$ref": "#/components/schemas/paramsDate",
            "description": "The end date of the parameter."
          }
        }
      },
      "paramsDateType": {
        "type": "string",
        "enum": [
          "DATE_TYPE_UNKNOWN",
          "DATE_TYPE_RELATIVE",
          "DATE_TYPE_ABSOLUTE"
        ],
        "default": "DATE_TYPE_UNKNOWN",
        "x-enum-value-release-info": {
          "DATE_TYPE_RELATIVE": {
            "noticeVersion": {
              "major": 3
            },
            "releaseVersion": {
              "major": 5
            },
            "changeType": "REMOVE_ENUM_VALUE",
            "description": "This enum value has no equivalent in Contract Parameters. There are no guarantees on functionality or constraints for this type."
          }
        },
        "x-enum-value-descriptions": {
          "DATE_TYPE_ABSOLUTE": "The value must be in the range [start, end] to be valid. This means a specific date (year/month/day) must be set.",
          "DATE_TYPE_RELATIVE": "The value is relative to the current date. For example `start(year=-5), end()` means any day between five years ago and today.",
          "DATE_TYPE_UNKNOWN": "The date type is unknown."
        }
      },
      "paramsDenominationField": {
        "type": "object",
        "properties": {
          "permitted_denominations": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "ISO 4217 denomination codes - empty means any denomination."
          }
        }
      },
      "paramsNumberField": {
        "type": "object",
        "properties": {
          "value_type": {
            "$ref": "#/components/schemas/paramsNumberFieldDisplayStyle",
            "description": "The value type of the number field."
          },
          "min_value": {
            "type": "string",
            "description": "The minimum value allowed for the number field."
          },
          "max_value": {
            "type": "string",
            "description": "The maximum value allowed for the number field."
          },
          "step": {
            "type": "string",
            "description": "The incrementation step for the number field."
          }
        }
      },
      "paramsNumberFieldDisplayStyle": {
        "type": "string",
        "enum": [
          "NUMBER_FIELD_DISPLAY_STYLE_NOT_SPECIFIED",
          "NUMBER_FIELD_DISPLAY_STYLE_PLAIN",
          "NUMBER_FIELD_DISPLAY_STYLE_PERCENTAGE",
          "NUMBER_FIELD_DISPLAY_STYLE_MONEY",
          "NUMBER_FIELD_DISPLAY_STYLE_MONTHS"
        ],
        "default": "NUMBER_FIELD_DISPLAY_STYLE_NOT_SPECIFIED",
        "x-enum-value-descriptions": {
          "NUMBER_FIELD_DISPLAY_STYLE_MONEY": "The number will be displayed in monetary format.",
          "NUMBER_FIELD_DISPLAY_STYLE_MONTHS": "The number will be displayed as an amount of months.",
          "NUMBER_FIELD_DISPLAY_STYLE_NOT_SPECIFIED": "Default value.",
          "NUMBER_FIELD_DISPLAY_STYLE_PERCENTAGE": "The number will be displayed as a percentage.",
          "NUMBER_FIELD_DISPLAY_STYLE_PLAIN": "The number will be displayed exactly as entered."
        }
      },
      "paramsStringField": {
        "type": "object"
      },
      "plansAccountPlanAssoc": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "A unique ID for an account plan association.\n\nMax length: 36 characters."
          },
          "account_id": {
            "type": "string",
            "description": "The account ID associated with the plan."
          },
          "plan_id": {
            "type": "string",
            "description": "The plan ID associated with the account."
          },
          "create_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The timestamp indicating when this account plan association was created."
          },
          "start_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The timestamp indicating when this account plan association became active."
          },
          "end_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The timestamp indicating when this account plan association became inactive."
          },
          "status": {
            "$ref": "#/components/schemas/plansAccountPlanAssocStatus",
            "description": "The status of the account plan association."
          }
        }
      },
      "plansAccountPlanAssocStatus": {
        "type": "string",
        "enum": [
          "ACCOUNT_PLAN_ASSOC_STATUS_UNKNOWN",
          "ACCOUNT_PLAN_ASSOC_STATUS_ACTIVE",
          "ACCOUNT_PLAN_ASSOC_STATUS_INACTIVE"
        ],
        "default": "ACCOUNT_PLAN_ASSOC_STATUS_UNKNOWN",
        "x-enum-value-descriptions": {
          "ACCOUNT_PLAN_ASSOC_STATUS_ACTIVE": "The status of the account plan association is active. Can be updated to INACTIVE via plan updates.",
          "ACCOUNT_PLAN_ASSOC_STATUS_INACTIVE": "The status of the account plan association is inactive. This is a terminal status."
        }
      },
      "plansPlan": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "A unique ID for a plan. Optional for create requests.\n\nMax length: 36 characters."
          },
          "supervisor_contract_version_id": {
            "type": "string",
            "description": "The ID of the Supervisor Contract version. Required for create requests."
          },
          "create_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "A timestamp indicating when the plan was created."
          },
          "status": {
            "$ref": "#/components/schemas/plansPlanStatus",
            "description": "The status of the plan. Optional when creating the plan - defaults to `PLAN_STATUS_OPEN`.",
            "x-release-info": {
              "releaseVersion": {
                "major": 1,
                "minor": 13
              },
              "changeType": "ADD_FIELD"
            }
          },
          "opening_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "A timestamp indicating when the plan status was updated to `PLAN_STATUS_OPEN`.",
            "x-release-info": {
              "releaseVersion": {
                "major": 1,
                "minor": 13
              },
              "changeType": "ADD_FIELD"
            }
          },
          "activation_completed_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "A timestamp indicating when the activation PlanUpdate for the Plan succeeded and its status was updated to `PLAN_UPDATE_STATUS_COMPLETED`.",
            "x-release-info": {
              "releaseVersion": {
                "major": 1,
                "minor": 13
              },
              "changeType": "ADD_FIELD"
            }
          },
          "closing_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "A timestamp indicating when the plan status was updated to `PLAN_STATUS_CLOSED`.",
            "x-release-info": {
              "releaseVersion": {
                "major": 1,
                "minor": 13
              },
              "changeType": "ADD_FIELD"
            }
          },
          "closure_completed_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "A timestamp indicating when the closure PlanUpdate for the Plan succeeded and its status was updated to `PLAN_UPDATE_STATUS_COMPLETED`.",
            "x-release-info": {
              "releaseVersion": {
                "major": 1,
                "minor": 13
              },
              "changeType": "ADD_FIELD"
            }
          },
          "details": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Map of unstructured fields that hold instance-specific plan metadata."
          }
        }
      },
      "plansPlanStatus": {
        "type": "string",
        "enum": [
          "PLAN_STATUS_UNKNOWN",
          "PLAN_STATUS_PENDING",
          "PLAN_STATUS_OPEN",
          "PLAN_STATUS_CLOSED"
        ],
        "default": "PLAN_STATUS_UNKNOWN"
      },
      "posting_apiv1OverrideRestrictions": {
        "type": "object",
        "properties": {
          "all": {
            "type": "boolean",
            "description": "The caller may choose to override all account restriction checks for a posting instruction by setting this field to true."
          },
          "restriction_set_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The caller may choose to override certain account restrictions by passing its restriction set ID here."
          }
        },
        "description": "OverrideRestrictions allows a caller to skip all or some restrictions from impacting a PostingInstruction. Caller may not set more than one field. As such, either the `all`, or the `restriction_set_ids` field may be set.\n\nNote that the restrictions specified here will be overridden for each account targeted by this PostingInstruction."
      },
      "v1AccountViolation": {
        "type": "object",
        "properties": {
          "account_id": {
            "type": "string",
            "description": "The ID of the account affected by the violation."
          },
          "payment_device_token": {
            "type": "string",
            "description": "The payment device token affected by the violation."
          },
          "type": {
            "$ref": "#/components/schemas/v1AccountViolationType",
            "description": "The type of violation."
          }
        },
        "description": "* AccountViolation describes a violation related to an account targeted by a PostingInstruction."
      },
      "v1AccountViolationType": {
        "type": "string",
        "enum": [
          "ACCOUNT_VIOLATION_ACCOUNT_NOT_PRESENT",
          "ACCOUNT_VIOLATION_ACCOUNT_STATUS_INVALID",
          "ACCOUNT_VIOLATION_UNSUPPORTED_DENOMINATION",
          "ACCOUNT_VIOLATION_PAYMENT_DEVICE_INVALID"
        ],
        "default": "ACCOUNT_VIOLATION_ACCOUNT_NOT_PRESENT",
        "description": "* AccountViolation type characterises an account violations.",
        "x-enum-value-descriptions": {
          "ACCOUNT_VIOLATION_ACCOUNT_NOT_PRESENT": "The instruction's target account is not present.",
          "ACCOUNT_VIOLATION_ACCOUNT_STATUS_INVALID": "The instruction's target account is in a status that doesn't allow postings (for example, CLOSED or PENDING_OPENING).",
          "ACCOUNT_VIOLATION_PAYMENT_DEVICE_INVALID": "The instruction's payment device token resolved to a payment device that has an invalid status as of this batch's value_timestamp.",
          "ACCOUNT_VIOLATION_UNSUPPORTED_DENOMINATION": "The instruction's target account does not support the posted denomination."
        }
      },
      "v1AuthorisationAdjustment": {
        "type": "object",
        "properties": {
          "denomination": {
            "type": "string",
            "description": "The instruction denomination.",
            "x-output-only": true
          },
          "advice": {
            "type": "boolean",
            "description": "Can be set to true to ensure that funds are ringfenced regardless of the outcome of balance checks. To ensure that posting instructions with `advice` set to true are excluded from the contract balance check, the flag `exclude_advice` must also be set to true. See [Balance check](/reference/contracts/contracts_api_4xx/common_examples/#generic-balance_check)."
          },
          "target_account_id": {
            "type": "string",
            "description": "The `account_id` of the `target_account` for this `client_transaction`.",
            "x-output-only": true
          },
          "internal_account_id": {
            "type": "string",
            "description": "The `account_id` of the `internal_account` for this `client_transaction`.",
            "x-output-only": true
          },
          "authorised_amount": {
            "type": "string",
            "description": "The total amount authorised for this client transaction after the accepted instruction was accepted. This field is not returned if the instruction is rejected.",
            "x-output-only": true
          },
          "delta_amount": {
            "type": "string",
            "description": "The change the accepted instruction has made to the amount authorised for this client transaction. This field is not returned if the instruction is rejected.",
            "x-output-only": true
          },
          "amount": {
            "$ref": "#/components/schemas/amount",
            "required": false
          },
          "replacement_amount": {
            "$ref": "#/components/schemas/replacement_amount",
            "required": false
          }
        },
        "description": "* AuthorisationAdjustment can be used to change the amount that was ring-fenced by either: - A previously accepted OutboundAuthorisation or InboundAuthorisation; or - A previous AuthorisationAdjustment. The authorisation is identified by the PostingInstruction client_transaction_id.\n\nFor this instruction Vault will perform: - idempotency check - Posting logic checks (which verify that a previously accepted OutboundAuthorisation or   InboundAuthorisation exists and the client_transaction has not entered the   clearing/release state yet) - contract execution (only for positive ring-fenced amounts)\n\nResulting postings committed (if accepted):\n\nPostings for AuthorisationAdjustment of OutboundAuthorisation:  <> adjustment_amount = amount; amount > 0:   - Dr | amount | auth[target_account_id]   | PHASE_PENDING_OUTGOING   - Cr | amount | auth[internal_account_id] | PHASE_PENDING_OUTGOING  <> adjustment_amount = amount; amount < 0:   - Cr | amount | auth[target_account_id]   | PHASE_PENDING_OUTGOING   - Dr | amount | auth[internal_account_id] | PHASE_PENDING_OUTGOING  <> adjustment_amount = replacement_amount; replacement_amount > current amount   - Dr | delta_amount | auth[target_account_id]   | PHASE_PENDING_OUTGOING   - Cr | delta_amount | auth[internal_account_id] | PHASE_PENDING_OUTGOING  <> adjustment_amount = replacement_amount; replacement_amount < current amount   - Cr | delta_amount | auth[target_account_id]   | PHASE_PENDING_OUTGOING   - Dr | delta_amount | auth[internal_account_id] | PHASE_PENDING_OUTGOING\n\n--------------------------------------------------------------------------------------\n\n Postings for AuthorisationAdjustment of InboundAuthorisation:  <> adjustment_amount = amount; amount > 0:   - Cr | amount | auth[target_account_id]   | PHASE_PENDING_INCOMING   - Dr | amount | auth[internal_account_id] | PHASE_PENDING_INCOMING  <> adjustment_amount = amount; amount < 0:   - Dr | amount | auth[target_account_id]   | PHASE_PENDING_INCOMING   - Cr | amount | auth[internal_account_id] | PHASE_PENDING_INCOMING  <> adjustment_amount = replacement_amount; replacement_amount > current amount   - Cr | delta_amount | auth[target_account_id]   | PHASE_PENDING_INCOMING   - Dr | delta_amount | auth[internal_account_id] | PHASE_PENDING_INCOMING  <> adjustment_amount = replacement_amount; replacement_amount < current amount   - Dr | delta_amount | auth[target_account_id]   | PHASE_PENDING_INCOMING   - Cr | delta_amount | auth[internal_account_id] | PHASE_PENDING_INCOMING"
      },
      "v1ContractViolation": {
        "type": "object",
        "properties": {
          "account_id": {
            "type": "string",
            "description": "The ID of the account affected by the violation."
          },
          "type": {
            "$ref": "#/components/schemas/v1ContractViolationType",
            "description": "The type of contract violation."
          },
          "reason": {
            "type": "string",
            "description": "The reason for a contract violation."
          }
        },
        "description": "* ContractViolation characterises a violation regarding contracts."
      },
      "v1ContractViolationType": {
        "type": "string",
        "enum": [
          "CONTRACT_VIOLATION_BREACH_TERMS_AND_CONDITIONS",
          "CONTRACT_VIOLATION_INSUFFICIENT_FUNDS"
        ],
        "default": "CONTRACT_VIOLATION_BREACH_TERMS_AND_CONDITIONS",
        "description": "* ContractViolationType characterises a contract violation.",
        "x-enum-value-descriptions": {
          "CONTRACT_VIOLATION_BREACH_TERMS_AND_CONDITIONS": "The instruction breaches the terms and conditions of the target account's contract.",
          "CONTRACT_VIOLATION_INSUFFICIENT_FUNDS": "The Posting instruction cannot be applied due to insufficient funds."
        }
      },
      "v1CustomInstruction": {
        "type": "object",
        "properties": {
          "postings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/v1Posting"
            },
            "description": "A list of postings (credits and debits). The net sum of credit postings must equal the net sum of debit postings per asset/denomination/phase."
          }
        },
        "description": "* CustomInstruction specifies a list of credits and debits to be written to the ledger.\n\nFor this instruction Vault will perform the following checks: - There are 128 or fewer postings in the instruction - Net amounts credited and debited are equal - Idempotency - Account status - Account/customer/payment_device restrictions\n\n If they are accepted the resulting postings committed are specified by the postings field."
      },
      "v1InboundAuthorisation": {
        "type": "object",
        "properties": {
          "amount": {
            "type": "string",
            "description": "The authorisation amount."
          },
          "denomination": {
            "type": "string",
            "description": "The instruction denomination."
          },
          "target_account": {
            "$ref": "#/components/schemas/v1TargetAccount",
            "description": "The instruction `target_account`."
          },
          "internal_account_id": {
            "type": "string",
            "description": "The `internal_account_id` must be the ID of an internal account in Vault."
          },
          "advice": {
            "type": "boolean",
            "description": "Can be set to true to ensure that funds are ringfenced regardless of the outcome of balance checks. To ensure that posting instructions with `advice` set to true are excluded from the contract balance check, the flag `exclude_advice` must also be set to true. See [Balance check](/reference/contracts/contracts_api_4xx/common_examples/#generic-balance_check)."
          },
          "target_account_id": {
            "type": "string",
            "description": "The `account_id` of the instruction's `target_account`.",
            "x-output-only": true
          }
        },
        "description": "* InboundAuthorisation authorises incoming funds into the target_account.\n\nFor this instruction Vault will perform: - idempotency check - account resolution - account checks - account/customer/payment_device restrictions - contract execution\n\nResulting postings committed (if accepted):  - Dr | amount | internal_account_id | PHASE_PENDING_INCOMING  - Cr | amount | target_account_id   | PHASE_PENDING_INCOMING"
      },
      "v1InboundHardSettlement": {
        "type": "object",
        "properties": {
          "amount": {
            "type": "string",
            "description": "The instruction amount."
          },
          "denomination": {
            "type": "string",
            "description": "The instruction denomination."
          },
          "target_account": {
            "$ref": "#/components/schemas/v1TargetAccount",
            "description": "The instruction `target_account`."
          },
          "internal_account_id": {
            "type": "string",
            "description": "The `internal_account_id` must be the ID of an internal account in Vault."
          },
          "advice": {
            "type": "boolean",
            "description": "Can be set to true to ensure that funds are ringfenced regardless of the outcome of balance checks. To ensure that posting instructions with `advice` set to true are excluded from the contract balance check, the flag `exclude_advice` must also be set to true. See [Balance check](/reference/contracts/contracts_api_4xx/common_examples/#generic-balance_check)."
          },
          "target_account_id": {
            "type": "string",
            "description": "The `account_id` of the instruction's `target_account`.",
            "x-output-only": true
          }
        },
        "description": "* InboundHardSettlement is an instruction that authorises and settles incoming funds into the target account.\n\nFor this instruction Vault will perform: - idempotency check - account resolution - account checks - account/customer/payment_device restrictions - contract execution\n\nResulting postings committed (if accepted): - Dr | amount | internal_account_id | PHASE_COMMITTED - Cr | amount | target_account_id   | PHASE_COMMITTED"
      },
      "v1OutboundAuthorisation": {
        "type": "object",
        "properties": {
          "amount": {
            "type": "string",
            "description": "The authorisation amount."
          },
          "denomination": {
            "type": "string",
            "description": "The instruction denomination."
          },
          "target_account": {
            "$ref": "#/components/schemas/v1TargetAccount",
            "description": "The instruction `target_account`."
          },
          "internal_account_id": {
            "type": "string",
            "description": "The `internal_account_id` must be the ID of an internal account in Vault."
          },
          "advice": {
            "type": "boolean",
            "description": "This can be set to true to ensure that funds are ringfenced regardless of the outcome of balance checks. To ensure that posting instructions with `advice` set to true are excluded from the contract balance check, the flag `exclude_advice` must also be set to true. See [Balance check](/reference/contracts/contracts_api_4xx/common_examples/#generic-balance_check)."
          },
          "target_account_id": {
            "type": "string",
            "description": "The `account_id` of the instruction's `target_account`.",
            "x-output-only": true
          }
        },
        "description": "* OutboundAuthorisation creates a funds hold (ring-fence the funds) on the the target account.\n\nFor this instruction Vault will perform: - idempotency check - account resolution - account checks - account/customer/payment_device restrictions - contract execution\n\nResulting postings committed (if accepted):  - Dr | amount | target_account_id   | PHASE_PENDING_OUTGOING  - Cr | amount | internal_account_id | PHASE_PENDING_OUTGOING"
      },
      "v1OutboundHardSettlement": {
        "type": "object",
        "properties": {
          "amount": {
            "type": "string",
            "description": "The instruction amount."
          },
          "denomination": {
            "type": "string",
            "description": "The instruction denomination."
          },
          "target_account": {
            "$ref": "#/components/schemas/v1TargetAccount",
            "description": "The instruction `target_account`."
          },
          "internal_account_id": {
            "type": "string",
            "description": "The `internal_account_id` must be the ID of an internal account in Vault."
          },
          "advice": {
            "type": "boolean",
            "description": "Can be set to true to ensure that funds are ringfenced regardless of the outcome of balance checks. To ensure that posting instructions with `advice` set to true are excluded from the contract balance check, the flag `exclude_advice` must also be set to true. See [Balance check](/reference/contracts/contracts_api_4xx/common_examples/#generic-balance_check)."
          },
          "target_account_id": {
            "type": "string",
            "description": "The `account_id` of the instruction's `target_account`.",
            "x-output-only": true
          }
        },
        "description": "* OutboundHardSettlement is an instruction that authorises and settles outgoing funds from the target account.\n\nFor this instruction Vault will perform: - idempotency check - account resolution - account checks - account/customer/payment_device restrictions - contract execution\n\nResulting postings committed (if accepted): - Dr | amount | target_account_id   | PHASE_COMMITTED - Cr | amount | internal_account_id | PHASE_COMMITTED"
      },
      "v1Override": {
        "type": "object",
        "properties": {
          "restrictions": {
            "$ref": "#/components/schemas/posting_apiv1OverrideRestrictions"
          }
        },
        "description": "Override is used to override certain checks for a posting instruction."
      },
      "v1Posting": {
        "type": "object",
        "properties": {
          "credit": {
            "type": "boolean",
            "description": "Indicates whether the posting is a credit or debit."
          },
          "amount": {
            "type": "string",
            "description": "The posting amount."
          },
          "denomination": {
            "type": "string",
            "description": "The posting denomination."
          },
          "account_id": {
            "type": "string",
            "description": "The ID of the Vault account being posted to."
          },
          "account_address": {
            "type": "string",
            "description": "The address of the Vault account being posted to."
          },
          "asset": {
            "type": "string",
            "description": "The asset value of the posting."
          },
          "phase": {
            "$ref": "#/components/schemas/v1PostingPhase",
            "description": "The posting phase."
          }
        },
        "description": "* Posting represents a Credit/Debit of funds to an account_id/account_address."
      },
      "v1PostingInstruction": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Created by Vault. This uniquely identifies the posting instruction in Vault.",
            "x-output-only": true
          },
          "client_transaction_id": {
            "type": "string",
            "description": "Set by the client. This is the ID of the client transaction this posting instruction is creating or mutating. Required."
          },
          "pics": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Posting Identification Codes that can be associated to posting instruction, and consumed by downstream processes.",
            "x-release-info": {
              "noticeVersion": {
                "major": 1,
                "minor": 10
              },
              "releaseVersion": {
                "major": 5
              },
              "changeType": "REMOVE_FIELD",
              "description": "Metadata should instead be attached via the instruction details field"
            }
          },
          "instruction_details": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Stores metadata related to the posting instruction. Contract execution will have access to these. If a restriction has exemption conditions and all the exemption conditions are present as key-value pairs, the restriction will not be applied to this posting instruction."
          },
          "committed_postings": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/v1Posting"
            },
            "description": "Contains the list of Postings written to the Posting ledger if the posting instruction was accepted.",
            "x-output-only": true
          },
          "posting_violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/v1PostingViolation"
            },
            "description": "Captures rejection reasons caused by posting logic validity checks. For example: Cannot adjust an authorisation that has already been settled.",
            "x-output-only": true
          },
          "account_violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/v1AccountViolation"
            },
            "description": "Captures rejection reasons and details caused by account checks. For example: Account closed.",
            "x-output-only": true
          },
          "restriction_violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/v1RestrictionViolation"
            },
            "description": "Captures rejection reasons and rejection details caused by restrictions. For example: Restriction with ID 'xyz123' prevented this instruction.",
            "x-output-only": true
          },
          "contract_violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/v1ContractViolation"
            },
            "description": "Captures rejection reasons and rejection details caused by contract execution. For example: Insufficient funds.",
            "x-output-only": true
          },
          "override": {
            "$ref": "#/components/schemas/v1Override",
            "description": "Allows the caller to override certain checks for this PostingInstruction."
          },
          "transaction_code": {
            "$ref": "#/components/schemas/v1TransactionCode",
            "description": "ISO20022 Bank Transaction Code field, a set of properties to identify underlying transaction."
          },
          "outbound_authorisation": {
            "$ref": "#/components/schemas/v1OutboundAuthorisation",
            "required": false
          },
          "inbound_authorisation": {
            "$ref": "#/components/schemas/v1InboundAuthorisation",
            "required": false
          },
          "authorisation_adjustment": {
            "$ref": "#/components/schemas/v1AuthorisationAdjustment",
            "required": false
          },
          "settlement": {
            "$ref": "#/components/schemas/v1Settlement",
            "required": false
          },
          "release": {
            "$ref": "#/components/schemas/v1Release",
            "required": false
          },
          "inbound_hard_settlement": {
            "$ref": "#/components/schemas/v1InboundHardSettlement",
            "required": false
          },
          "outbound_hard_settlement": {
            "$ref": "#/components/schemas/v1OutboundHardSettlement",
            "required": false
          },
          "transfer": {
            "$ref": "#/components/schemas/v1Transfer",
            "required": false
          },
          "custom_instruction": {
            "$ref": "#/components/schemas/v1CustomInstruction",
            "required": false
          }
        },
        "description": "* A PostingInstruction acts against a client transaction. Vault offers a set of predefined PostingInstruction types, which each following a specific set of execution rules. A PostingInstruction may result in a balanced set of committed Postings to the ledger. OutboundAuthoriisations and InboundAuthorisations initiate a client transaction, which can then be acted upon, by the AuthorisationAdjustment, Settlement and Release instruction types. CustomInstruction, OutboundHardSettlement, InboundHardSettlement and Transfer instructions initiate and close a client transaction. As such, no other instructions can subsequently act on their client transactions. If accepted, a PostingInstruction is translated into a balanced set of Postings which are persisted atomically to the Posting Ledger."
      },
      "v1PostingInstructionBatch": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Uniquely identifies a posting instruction batch in Vault.",
            "x-output-only": true
          },
          "create_request_id": {
            "type": "string",
            "description": "The `request_id` of the `create-posting-instruction-batch` request.",
            "x-output-only": true
          },
          "client_id": {
            "type": "string",
            "description": "Uniquely identifies a client of the Posting API. Used to publish responses to the specified Kafka response topic. Together with `request_id` it forms a unique key used for idempotency. Required."
          },
          "client_batch_id": {
            "type": "string",
            "description": "This must be set by the client, and is used as a correlation ID across different posting instruction batches. The suggested use is to set the same `client_batch_id` across batches that contain posting instructions for the same financial transaction. The posting service provides indexing on this ID, allowing for efficient queries to return all posting instructions that belong to a client transaction. Required."
          },
          "posting_instructions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/v1PostingInstruction"
            },
            "description": "A non-empty list of posting instruction objects to be processed atomically. Required."
          },
          "batch_details": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Stores metadata related to the posting instruction batch resource. These details can also be retrieved in the posting instruction resource. Optional."
          },
          "value_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "Specifies the time at which all committed postings of this batch's posting instructions will affect balances. For most cases, including real time payments or fund movements, this should not be set and will default to the generated `insertion_timestamp`. Should be set only for backdated posting instruction batches and must be between 1970-01-01T00:00:00Z and 9999-12-31T23:59:59Z, inclusive. Optional; defaults to the insertion timestamp in UTC."
          },
          "status": {
            "$ref": "#/components/schemas/v1PostingInstructionBatchStatus",
            "description": "The status of the processing of the posting instruction batch.",
            "x-output-only": true
          },
          "error": {
            "$ref": "#/components/schemas/v1PostingInstructionBatchError",
            "description": "Any errors generated while trying to process the posting instruction batch. If any errors are present, the batch errors and nothing is committed to the database.",
            "x-output-only": true
          },
          "insertion_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "Specifies the time this posting instruction batch was inserted in Vault.",
            "x-output-only": true
          },
          "dry_run": {
            "type": "boolean",
            "description": "If true, the `create-posting-instruction-batch` request did not have any side effects and no posting instruction batch resource was created.",
            "x-output-only": true
          }
        },
        "description": "* PostingInstructionBatch is an atomic wrapper around PostingInstructions. All PostingInstruction within a PostingInstructionBatch are either all accepted, all rejected or all errored out."
      },
      "v1PostingInstructionBatchError": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/v1PostingInstructionBatchErrorType",
            "description": "The type of error returned."
          },
          "message": {
            "type": "string",
            "description": "Contains human-readable information about the error raised."
          }
        },
        "description": "* An InstructionBatchError holds information about an error encountered while trying to process an CreatePostingInstructionBatchRequest."
      },
      "v1PostingInstructionBatchErrorType": {
        "type": "string",
        "enum": [
          "POSTING_INSTRUCTION_BATCH_ERROR_TYPE_INVALID_ARGUMENT",
          "POSTING_INSTRUCTION_BATCH_ERROR_TYPE_INTERNAL",
          "POSTING_INSTRUCTION_BATCH_ERROR_TYPE_TTL_EXPIRED"
        ],
        "default": "POSTING_INSTRUCTION_BATCH_ERROR_TYPE_INVALID_ARGUMENT",
        "description": "* A PostingInstructionBatchErrorType is the type a PostingInstructionBatchError. The Vault Postings API are idempotent, and where adviced, requests can be retried. Each error indicates whether it is retriable or non-retriable.",
        "x-enum-value-descriptions": {
          "POSTING_INSTRUCTION_BATCH_ERROR_TYPE_INTERNAL": "An internal error occurred due to unexpected condition while processing the request. Can Retry.",
          "POSTING_INSTRUCTION_BATCH_ERROR_TYPE_INVALID_ARGUMENT": "CreatePostingInstructionBatchRequest contains invalid arguments and the request cannot be processed. See the error message for more details. Cannot Retry.",
          "POSTING_INSTRUCTION_BATCH_ERROR_TYPE_TTL_EXPIRED": "A time to live expiry error occured because the requested `time_to_live` timestamp has expired. Cannot Retry."
        }
      },
      "v1PostingInstructionBatchStatus": {
        "type": "string",
        "enum": [
          "POSTING_INSTRUCTION_BATCH_STATUS_UNKNOWN",
          "POSTING_INSTRUCTION_BATCH_STATUS_ACCEPTED",
          "POSTING_INSTRUCTION_BATCH_STATUS_REJECTED"
        ],
        "default": "POSTING_INSTRUCTION_BATCH_STATUS_UNKNOWN",
        "description": "* The status of the posting instruction batch.",
        "x-enum-value-descriptions": {
          "POSTING_INSTRUCTION_BATCH_STATUS_ACCEPTED": "The PostingInstructionBatch has been accepted and Postings have been committed to the ledger.",
          "POSTING_INSTRUCTION_BATCH_STATUS_REJECTED": "The PostingInstructionBatch has been rejected and no Postings have been committed to the ledger.",
          "POSTING_INSTRUCTION_BATCH_STATUS_UNKNOWN": "Default value."
        }
      },
      "v1PostingViolation": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/v1PostingViolationType",
            "description": "The type of violation."
          }
        },
        "description": "* PostingViolation describes a Posting API violation."
      },
      "v1PostingViolationType": {
        "type": "string",
        "enum": [
          "POSTING_VIOLATION_CLIENT_TRANSACTION_ALREADY_EXISTS",
          "POSTING_VIOLATION_CLIENT_TRANSACTION_DOES_NOT_EXIST",
          "POSTING_VIOLATION_ADJUSTMENT_YIELDS_AUTHORISATION_WITH_NEGATIVE_AMOUNT",
          "POSTING_VIOLATION_CLIENT_TRANSACTION_CLOSED",
          "POSTING_VIOLATION_CLIENT_TRANSACTION_INVALID_OPERATION"
        ],
        "default": "POSTING_VIOLATION_CLIENT_TRANSACTION_ALREADY_EXISTS",
        "description": "* PostingViolationType characterises a Posting API violation.",
        "x-enum-value-descriptions": {
          "POSTING_VIOLATION_ADJUSTMENT_YIELDS_AUTHORISATION_WITH_NEGATIVE_AMOUNT": "An AuthorisationAdjustment yields an authorisation with a negative amount.",
          "POSTING_VIOLATION_CLIENT_TRANSACTION_ALREADY_EXISTS": "An OutboundAuthorisation, InboundAuthorisation, Transfer, OutboundHardSettlement or InboundHardSettlement specifies a `client_transaction_id` which already exists in the namespace of the `client_id`.",
          "POSTING_VIOLATION_CLIENT_TRANSACTION_CLOSED": "An instruction is attempting to mutate a client transaction that has been closed.",
          "POSTING_VIOLATION_CLIENT_TRANSACTION_DOES_NOT_EXIST": "An AuthorisationAdjustment, Settlement, Release is referring to a non existent client transaction.",
          "POSTING_VIOLATION_CLIENT_TRANSACTION_INVALID_OPERATION": "An instruction is being added to a client transaction where the `value_timestamp` is not strictly later than the current latest instruction, or the instruction being processed would create a client transaction which has a combination of CustomInstructions and other instruction types."
        }
      },
      "v1Release": {
        "type": "object",
        "properties": {
          "amount": {
            "type": "string",
            "description": "The amount released.",
            "x-output-only": true
          },
          "denomination": {
            "type": "string",
            "description": "The instruction release denomination.",
            "x-output-only": true
          },
          "target_account_id": {
            "type": "string",
            "description": "The instruction `target_account_id`.",
            "x-output-only": true
          },
          "internal_account_id": {
            "type": "string",
            "description": "The instruction `internal_account_id`.",
            "x-output-only": true
          },
          "require_pre_posting_hook_execution": {
            "type": "boolean",
            "description": "If set to true, the pre-posting hook will be triggered for this instruction. Optional; if not supplied, the pre-posting hook may be triggered by other instructions within this batch, but this instruction will not be visible to the hook.",
            "x-release-info": {
              "releaseVersion": {
                "major": 3,
                "minor": 1
              },
              "changeType": "ADD_FIELD",
              "featureFlag": "TMV_1873_OPTIONAL_PRE_POSTINGS_HOOK_RELEASES"
            }
          }
        },
        "description": "* Release removes an authorisation hold. The client transaction being released is identified by the client_transaction_id in the parent PostingInstruction.\n\nNote: No other Posting Instructions will be accepted after the transaction has been released.\n\nFor this instruction Vault will perform: - idempotency check - Posting logic checks (was there an Inbound or Outbound authorisation for it? was accepted?) - check that underlying authorisation we are settling is still in a clearing state. (No Release   or final Settlement received). - if require_pre_posting_hook_execution is set to true, then the pre-posting hook will be   triggered for this instruction.\n\n Note  - ringfenced_amount = initial OutboundAuth/InboundAuth amount \t\t\t\t          + AuthAdjustment amounts (these can be +ve or -ve) \t\t\t\t          - Settlement amounts\n\nResulting postings committed (if accepted):\n\n <> Release of OutboundAuthorisation:   - Dr | ringfenced_amount | auth[internal_account_id] | PHASE_PENDING_OUTGOING   - Cr | ringfenced_amount | auth[target_account_id]   | PHASE_PENDING_OUTGOING  <> Release of InboundAuthorisation:   - Dr | ringfenced_amount | auth[target_account_id]   | PHASE_PENDING_INCOMING   - Cr | ringfenced_amount | auth[internal_account_id] | PHASE_PENDING_INCOMING"
      },
      "v1RestrictionViolation": {
        "type": "object",
        "properties": {
          "restriction_set_id": {
            "type": "string",
            "description": "Uniquely identifies this restriction in Vault."
          },
          "account_id": {
            "type": "string",
            "description": "This is set if this restriction violation is applied at an account level."
          },
          "payment_device_id": {
            "type": "string",
            "description": "This is set if this restriction violation is applied at a payment device level."
          },
          "customer_id": {
            "type": "string",
            "description": "This is set if this restriction violation is applied at a customer level."
          },
          "requires_review": {
            "type": "boolean",
            "description": "If true, this restriction requires review. Otherwise it simply prevents it."
          }
        },
        "description": "* RestrictionViolation characterises a violation regarding restriction."
      },
      "v1Settlement": {
        "type": "object",
        "properties": {
          "amount": {
            "type": "string",
            "description": "The amount to be cleared. Optional: if not supplied it will be calculated as amount = total amount authorised for this client transaction - total amount cleared."
          },
          "final": {
            "type": "boolean",
            "description": "If set to true, any remaining amount authorised for this client transaction will be released. No instruction may mutate a client transaction once a final settlement has mutated it."
          },
          "denomination": {
            "type": "string",
            "description": "The instruction denomination.",
            "x-output-only": true
          },
          "target_account_id": {
            "type": "string",
            "description": "The instruction `target_account_id`.",
            "x-output-only": true
          },
          "internal_account_id": {
            "type": "string",
            "description": "The instruction `internal_account_id`.",
            "x-output-only": true
          },
          "require_pre_posting_hook_execution": {
            "type": "boolean",
            "description": "If set to true, the pre-posting hook will be triggered for this instruction. Optional; if not supplied, the pre-posting hook may be triggered by other instructions within this batch, but this instruction will not be visible to the hook.",
            "x-release-info": {
              "releaseVersion": {
                "major": 3,
                "minor": 1
              },
              "changeType": "ADD_FIELD",
              "featureFlag": "TMV_1873_OPTIONAL_PRE_POSTINGS_HOOK_RELEASES"
            }
          }
        },
        "description": "* Settlement clears funds that have previously been authorised.\n\nSettlements can only act on client transactions that have not been release or settled with the final flag set.\n\nFor this instruction Vault will perform: - idempotency check - Posting logic checks (whether or not there was an accepted InboundAuthorisation or   OutboundAuthorisation for the same client transaction) - check that underlying authorisation we are settling is still in a clearing state.   (No Release or final Settlement received). - if the amount is specified and it's different than the authorisation hold, then Vault will   create additional postings to reflect the change. Please note that this may bring the account   balance negative, as contract execution won't be performed. - if final is set to true, Vault will release any outstanding balance ring-fenced by the original   authorisation. - if require_pre_posting_hook_execution is set to true, then the pre-posting hook will be   triggered for this instruction.\n\nNote: in the below examples for a given client_transaction_id:  - ringfenced_amount = initial OutboundAuth/InboundAuth amount \t\t\t\t          + AuthAdjustment amounts (these can be +ve or -ve) \t\t\t\t          - Settlement amounts\n\nResulting postings committed (if accepted):\n\nPostings for Settlement of OutboundAuthorisation:  <> Settlement of OutboundAuthorisation and amount = ringfenced_amount and final = true/false:   - Cr | amount                  | auth[target_account_id]   | PHASE_PENDING_OUTGOING   - Dr | amount                  | auth[internal_account_id] | PHASE_PENDING_OUTGOING   - Dr | amount                  | auth[target_account_id]   | PHASE_COMMITTED   - Cr | amount                  | auth[internal_account_id] | PHASE_COMMITTED\n\n <> Settlement of OutboundAuthorisation and amount > ringfenced_amount and final = true/false:   - Cr | ringfenced_amount       | auth[target_account_id]   | PHASE_PENDING_OUTGOING   - Dr | ringfenced_amount       | auth[internal_account_id] | PHASE_PENDING_OUTGOING   - Dr | amount                  | auth[target_account_id]   | PHASE_COMMITTED   - Cr | amount                  | auth[internal_account_id] | PHASE_COMMITTED\n\n <> Settlement of OutboundAuthorisation and amount < ringfenced_amount and final = false:   - Cr | amount                  | auth[target_account_id]   | PHASE_PENDING_OUTGOING   - Dr | amount                  | auth[internal_account_id] | PHASE_PENDING_OUTGOING   - Dr | amount                  | auth[target_account_id]   | PHASE_COMMITTED   - Cr | amount                  | auth[internal_account_id] | PHASE_COMMITTED\n\n <> Settlement of OutboundAuthorisation and amount < ringfenced_amount and final = true:   - Cr | ringfenced_amount       | auth[target_account_id]   | PHASE_PENDING_OUTGOING   - Dr | ringfenced_amount       | auth[internal_account_id] | PHASE_PENDING_OUTGOING   - Dr | amount                  | auth[target_account_id]   | PHASE_COMMITTED   - Cr | amount                  | auth[internal_account_id] | PHASE_COMMITTED\n\n--------------------------------------------------------------------------------------\n\n Postings for Settlement of InboundAuthorisation:  <> Settlement of InboundAuthorisation and amount = ringfenced_amount and final = true/false:   - Dr | amount                  | auth[target_account_id]   | PHASE_PENDING_INCOMING   - Cr | amount                  | auth[internal_account_id] | PHASE_PENDING_INCOMING   - Cr | amount                  | auth[target_account_id]   | PHASE_COMMITTED   - Dr | amount                  | auth[internal_account_id] | PHASE_COMMITTED\n\n <> Settlement of InboundAuthorisation and amount > ringfenced_amount and final = true/false:   - Dr | ringfenced_amount       | auth[target_account_id]   | PHASE_PENDING_INCOMING   - Cr | ringfenced_amount       | auth[internal_account_id] | PHASE_PENDING_INCOMING   - Cr | amount                  | auth[target_account_id]   | PHASE_COMMITTED   - Dr | amount                  | auth[internal_account_id] | PHASE_COMMITTED\n\n <> Settlement of InboundAuthorisation and amount < ringfenced_amount and final = false:   - Dr | amount                  | auth[target_account_id]   | PHASE_PENDING_INCOMING   - Cr | amount                  | auth[internal_account_id] | PHASE_PENDING_INCOMING   - Cr | amount                  | auth[target_account_id]   | PHASE_COMMITTED   - Dr | amount                  | auth[internal_account_id] | PHASE_COMMITTED\n\n <> Settlement of InboundAuthorisation and amount < ringfenced_amount and final = true:   - Dr | ringfenced_amount       | auth[target_account_id]   | PHASE_PENDING_OUTGOING   - Cr | ringfenced_amount       | auth[internal_account_id] | PHASE_PENDING_OUTGOING   - Cr | amount                  | auth[target_account_id]   | PHASE_COMMITTED   - Dr | amount                  | auth[internal_account_id] | PHASE_COMMITTED"
      },
      "v1TargetAccount": {
        "type": "object",
        "properties": {
          "payment_device_token": {
            "$ref": "#/components/schemas/payment_device_token",
            "required": false
          },
          "account_id": {
            "$ref": "#/components/schemas/account_id",
            "required": false
          }
        },
        "description": "* TargetAccount describes an account being targeted by a Posting instruction."
      },
      "v1TransactionCode": {
        "type": "object",
        "properties": {
          "domain": {
            "type": "string",
            "description": "Business area of the transaction."
          },
          "family": {
            "type": "string",
            "description": "A family within the domain."
          },
          "subfamily": {
            "type": "string",
            "description": "Sub-product family within a specific family."
          }
        },
        "description": "ISO20022 Bank Transaction Code."
      },
      "v1Transfer": {
        "type": "object",
        "properties": {
          "amount": {
            "type": "string",
            "description": "The amount to transfer."
          },
          "denomination": {
            "type": "string",
            "description": "The instruction denomination."
          },
          "debtor_target_account": {
            "$ref": "#/components/schemas/v1TargetAccount",
            "description": "The account being debited."
          },
          "debtor_target_account_id": {
            "type": "string",
            "description": "The `account_id` of the debtor.",
            "x-output-only": true
          },
          "creditor_target_account": {
            "$ref": "#/components/schemas/v1TargetAccount",
            "description": "The account being credited."
          },
          "creditor_target_account_id": {
            "type": "string",
            "description": "The `account_id` of the creditor.",
            "x-output-only": true
          }
        },
        "description": "Transfer PostingInstruction models an atomic transaction, no Adjustments, Settlements or other instructions can be passed with the same client_transaction_id.\n\nFor this instruction Vault will perform: - idempotency check - account resolution - account checks on both debitor and creditor's accounts - account/customer/payment_device restrictions on both debitor and creditor's accounts - contract execution on both debitor and creditor's accounts\n\nResulting postings committed (if accepted): - Dr | amount | debtor_account_id   | PHASE_COMMITTED - Cr | amount | creditor_account_id | PHASE_COMMITTED",
        "title": "* Transfer is an instruction that moves funds from the debtor to the creditor target account"
      },
      "v1accountsActivationUpdate": {
        "type": "object",
        "description": "An ActivationUpdate is automatically queued when updating an account status from `ACCOUNT_STATUS_PENDING` to `ACCOUNT_STATUS_OPEN`. An ActivationUpdate can also be retried if the account status is `ACCOUNT_STATUS_OPEN` and the Account has no other ActivationUpdates with status `ACCOUNT_UPDATE_STATUS_PENDING_EXECUTION` or `ACCOUNT_UPDATE_STATUS_COMPLETED`. This account update triggers the product activation code and sets up custom schedules."
      },
      "v1accountsClosureUpdate": {
        "type": "object",
        "description": "A ClosureUpdate is automatically queued when updating an account status from ACCOUNT_STATUS_OPEN to ACCOUNT_STATUS_PENDING_CLOSURE. A ClosureUpdate can also be retried if the account status is ACCOUNT_STATUS_PENDING_CLOSURE. This account update triggers the product close code, but it does not disable schedules."
      },
      "v1accountsScheduleMigrationType": {
        "type": "string",
        "enum": [
          "SCHEDULE_MIGRATION_TYPE_RECREATE_ALL_SCHEDULES_AND_GROUPS",
          "SCHEDULE_MIGRATION_TYPE_PRESERVE_SCHEDULES_IF_NO_GROUP_CHANGES"
        ],
        "default": "SCHEDULE_MIGRATION_TYPE_RECREATE_ALL_SCHEDULES_AND_GROUPS",
        "x-enum-value-descriptions": {
          "SCHEDULE_MIGRATION_TYPE_PRESERVE_SCHEDULES_IF_NO_GROUP_CHANGES": "When updating the product version of an account, existing schedules are preserved if either: * They are not part of a group and a schedule of the same event type is defined in the new Smart Contract code; or * They are part of a group and a group of the same name, size and order is defined in the new Smart Contract code. New schedules are only created if they are defined in the new Smart Contract code.",
          "SCHEDULE_MIGRATION_TYPE_RECREATE_ALL_SCHEDULES_AND_GROUPS": "When updating the product version of an account, all existing schedules will be deleted then recreated according to the Smart Contract code of the new product version. Any updates previously made to existing schedules will not be preserved. This is the default behaviour."
        }
      },
      "v1contractsContractModule": {
        "type": "object",
        "properties": {
          "code": {
            "type": "string",
            "description": "Source code of the Contract Module that is to be simulated."
          },
          "contract_module_version_id": {
            "type": "string",
            "description": "The ID that will be used as the Contract Module version ID in the simulation. Can be referenced by the simulation instructions."
          }
        }
      },
      "v1contractsContractNotificationEvent": {
        "type": "object",
        "properties": {
          "notification_type": {
            "type": "string",
            "description": "An user defined identifier indicating how the payload should be processed externally."
          },
          "resource_id": {
            "type": "string",
            "description": "The id of the resource that triggered the notification."
          },
          "resource_type": {
            "$ref": "#/components/schemas/contract_notificationResource",
            "description": "The type of resource that triggered the notification."
          },
          "notification_details": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Details passed to the external service as part of the notification."
          }
        }
      },
      "authIdentifier": {
        "type": "object",
        "properties": {
          "identifier_type": {
            "$ref": "#/components/schemas/authIdentifierType",
            "description": "The type of identifier."
          },
          "identifier": {
            "type": "string",
            "description": "The string value of the identifier. Must be unique."
          }
        },
        "description": "Identifiers associated with a user."
      },
      "authIdentifierType": {
        "type": "string",
        "enum": [
          "IDENTIFIER_TYPE_UNKNOWN",
          "IDENTIFIER_TYPE_USERNAME",
          "IDENTIFIER_TYPE_EMAIL",
          "IDENTIFIER_TYPE_PHONE"
        ],
        "default": "IDENTIFIER_TYPE_UNKNOWN",
        "x-enum-value-descriptions": {
          "IDENTIFIER_TYPE_EMAIL": "An email identifier.",
          "IDENTIFIER_TYPE_PHONE": "A phone number identifier.",
          "IDENTIFIER_TYPE_UNKNOWN": "An unknown identifier type.",
          "IDENTIFIER_TYPE_USERNAME": "A username identifier."
        }
      },
      "customersBatchGetCustomersResponse": {
        "type": "object",
        "properties": {
          "customers": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/customersCustomer"
            },
            "description": "Maps customer ID to customer."
          }
        }
      },
      "customersCreateCustomerAddressRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent.\n\nRequired.\nMax length: 512 characters.",
            "x-example-override": "98e7ed60-0305-4932-9cd9-7617942c13c5"
          },
          "customer_address": {
            "$ref": "#/components/schemas/customersCustomerAddress",
            "description": "The address to be created. Required.",
            "x-excluded-fields": [
              "id"
            ]
          }
        },
        "required": [
          "request_id"
        ]
      },
      "customersCreateCustomerRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent.\n\nRequired.\nMax length: 512 characters.",
            "x-example-override": "5f7b3fab-8d4c-4ee6-ab21-f89576038378"
          },
          "customer": {
            "$ref": "#/components/schemas/customersCustomer",
            "description": "The customer to be created. Required."
          }
        },
        "required": [
          "request_id"
        ]
      },
      "customersCustomer": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The unique ID of the customer. Defaults to a generated string ID if not provided.\n",
            "x-release-info": {
              "noticeVersion": {
                "major": 3,
                "minor": 3
              },
              "releaseVersion": {
                "major": 5
              },
              "changeType": "UPDATE_DEFAULT_FIELD_BEHAVIOUR",
              "description": "Defaults to a generated UUID instead of a string representation of an int64",
              "featureFlag": "TMV_215_STRING_CUSTOMER_IDS"
            },
            "x-example-override": "86d86f07-7ba6-466e-9f41-f72c24e9b13b"
          },
          "status": {
            "$ref": "#/components/schemas/customersCustomerStatus",
            "description": "The status of the customer. Optional for creation; can be PROSPECT or ACTIVE. Defaults to ACTIVE for creation.",
            "x-example-override": "CUSTOMER_STATUS_ACTIVE"
          },
          "identifiers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/authIdentifier"
            },
            "description": "The registered identifiers of the customer. A customer could have multiple identifiers associated with them, for example, a phone number, email address or username.",
            "x-example-override": "[{\"identifier_type\": \"IDENTIFIER_TYPE_EMAIL\", \"identifier\": \"api_user@domain.com\"}, {\"identifier_type\": \"IDENTIFIER_TYPE_USERNAME\", \"identifier\": \"api_user\"}, {\"identifier_type\": \"IDENTIFIER_TYPE_PHONE\", \"identifier\": \"+447700900796\"}]"
          },
          "customer_details": {
            "$ref": "#/components/schemas/customersCustomerDetails",
            "description": "Current details. Optional for create requests. This field will be replaced by a more general details object in a future release."
          },
          "additional_details": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Key value map of additional, non-structured customer details.<br> <br>The details must not include:<br> - Any image data, including any KYC collateral such as passport, licence or other images. These must be stored in a separate repository outside of Vault.<br> - Any data that is classified as PII data.<br> The details cannot be utilised by Smart Contracts to drive any type of product behaviour.<br><br> Max size: 1MB (but it is strongly recommended to keep below this size).",
            "x-example-override": "{\"key1\": \"value1\"}"
          }
        }
      },
      "customersCustomerAccessibility": {
        "type": "string",
        "enum": [
          "CUSTOMER_ACCESSIBILITY_UNKNOWN",
          "CUSTOMER_ACCESSIBILITY_AUDIO",
          "CUSTOMER_ACCESSIBILITY_LARGE_PRINT",
          "CUSTOMER_ACCESSIBILITY_BRAILLE",
          "CUSTOMER_ACCESSIBILITY_DEAF"
        ],
        "default": "CUSTOMER_ACCESSIBILITY_UNKNOWN",
        "description": "The customer's accessibility requirements.",
        "x-enum-value-descriptions": {
          "CUSTOMER_ACCESSIBILITY_AUDIO": "Audio required.",
          "CUSTOMER_ACCESSIBILITY_BRAILLE": "Braille required.",
          "CUSTOMER_ACCESSIBILITY_DEAF": "User is deaf.",
          "CUSTOMER_ACCESSIBILITY_LARGE_PRINT": "Large print required.",
          "CUSTOMER_ACCESSIBILITY_UNKNOWN": "Unknown accessibility."
        }
      },
      "customersCustomerAddress": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The address ID. Output only.",
            "x-example-override": "8c926ef4-f09c-4db0-9b58-57030e4547c0"
          },
          "house_name": {
            "type": "string",
            "description": "The house name. Optional for create requests.\n\nMax length: 256 characters.",
            "x-example-override": "Oaklands"
          },
          "street_number": {
            "type": "string",
            "description": "The street number. Optional for create requests.\n\nMax length: 256 characters.",
            "x-example-override": "2a"
          },
          "street": {
            "type": "string",
            "description": "The street name. Optional for create requests.\n\nMax length: 256 characters.",
            "x-example-override": "Lockleys Drive"
          },
          "local_municipality": {
            "type": "string",
            "description": "The local municipality. Optional for create requests.\n\nMax length: 256 characters.",
            "x-example-override": "Welwyn Parish Council"
          },
          "city": {
            "type": "string",
            "description": "The city. Optional for create requests.\n\nMax length: 256 characters.",
            "x-example-override": "Welwyn"
          },
          "postal_area": {
            "type": "string",
            "description": "The postcode or zip code. Optional for create requests.\n\nMax length: 256 characters.",
            "x-example-override": "AL69LU"
          },
          "governing_district": {
            "type": "string",
            "description": "The governing district. Optional for create requests.\n\nMax length: 256 characters.",
            "x-example-override": "East Herts"
          },
          "country": {
            "type": "string",
            "description": "The country. Optional for create requests.\n\nMax length: 256 characters.",
            "x-example-override": "GB"
          },
          "address_type": {
            "$ref": "#/components/schemas/customersCustomerAddressType",
            "description": "The address type. Optional for create requests.",
            "x-example-override": "CUSTOMER_ADDRESS_TYPE_HOME"
          },
          "start_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The date the address was valid from. Optional for create requests.",
            "x-example-override": "2018-04-10T20:14:37.808587Z"
          },
          "end_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The date the address changed. Optional for create requests.",
            "x-example-override": "2020-01-29T13:02:23.987234Z"
          },
          "customer_id": {
            "type": "string",
            "description": "The unique ID of the customer linked to the address.",
            "x-example-override": "6499023882596562732"
          }
        },
        "description": "An address. This address message will be replaced by a more general object in the future."
      },
      "customersCustomerAddressType": {
        "type": "string",
        "enum": [
          "CUSTOMER_ADDRESS_TYPE_UNKNOWN",
          "CUSTOMER_ADDRESS_TYPE_PO_BOX",
          "CUSTOMER_ADDRESS_TYPE_HOME",
          "CUSTOMER_ADDRESS_TYPE_OFFICE",
          "CUSTOMER_ADDRESS_TYPE_OTHER",
          "CUSTOMER_ADDRESS_TYPE_CORRESPONDENCE"
        ],
        "default": "CUSTOMER_ADDRESS_TYPE_UNKNOWN",
        "description": "Address type."
      },
      "customersCustomerContactMethod": {
        "type": "string",
        "enum": [
          "CUSTOMER_CONTACT_METHOD_UNKNOWN",
          "CUSTOMER_CONTACT_METHOD_NONE",
          "CUSTOMER_CONTACT_METHOD_EMAIL",
          "CUSTOMER_CONTACT_METHOD_SMS",
          "CUSTOMER_CONTACT_METHOD_NOTIFICATION"
        ],
        "default": "CUSTOMER_CONTACT_METHOD_UNKNOWN",
        "description": "The customer's preferred method of contact."
      },
      "customersCustomerDetails": {
        "type": "object",
        "properties": {
          "title": {
            "$ref": "#/components/schemas/customersCustomerTitle",
            "description": "The customer's title. Optional for create requests.",
            "x-example-override": "CUSTOMER_TITLE_MR"
          },
          "first_name": {
            "type": "string",
            "description": "The customer's first name. Optional for create requests.\n\nMax length: 256 characters.",
            "x-example-override": "Daniel"
          },
          "middle_name": {
            "type": "string",
            "description": "The customer's middle name. Optional for create requests.\n\nMax length: 256 characters.",
            "x-example-override": "Abbas"
          },
          "last_name": {
            "type": "string",
            "description": "The customer's last name. Optional for create requests.\n\nMax length: 256 characters.",
            "x-example-override": "Chorley"
          },
          "dob": {
            "type": "string",
            "description": "The customer's date of birth. Optional for create requests.\nThis field must contain a valid ISO-formatted date, e.g. 2018-06-03.",
            "x-example-override": "1980-12-25"
          },
          "gender": {
            "$ref": "#/components/schemas/customersCustomerGender",
            "description": "The customer's gender. Optional for create requests.",
            "x-example-override": "CUSTOMER_GENDER_MALE"
          },
          "nationality": {
            "type": "string",
            "description": "The customer's nationality. Optional for create requests.\n\nMax length: 256 characters.",
            "x-example-override": "British"
          },
          "email_address": {
            "type": "string",
            "description": "The customer's email address. Optional for create requests.\nThis field must contain a valid email address.",
            "x-example-override": "api_user@domain.com"
          },
          "mobile_phone_number": {
            "type": "string",
            "description": "The customer's mobile phone number. Optional for create requests.\nThis field must contain a valid telephone number.",
            "x-example-override": "+447700900796"
          },
          "home_phone_number": {
            "type": "string",
            "description": "The customer's home phone number. Optional for create requests.\nThis field must contain a valid telephone number.",
            "x-example-override": "+441632960138"
          },
          "business_phone_number": {
            "type": "string",
            "description": "The customer's business phone number. Optional for create requests.\nThis field must contain a valid telephone number.",
            "x-example-override": "+442079460933"
          },
          "contact_method": {
            "$ref": "#/components/schemas/customersCustomerContactMethod",
            "description": "The customer's preferred method of contact. Optional for create requests.",
            "x-example-override": "CUSTOMER_CONTACT_METHOD_EMAIL"
          },
          "country_of_residence": {
            "type": "string",
            "description": "The customer's country of residence. Optional for create requests.\n\nMax length: 256 characters.",
            "x-example-override": "GB"
          },
          "country_of_taxation": {
            "type": "string",
            "description": "The customer's country of taxation. Optional for create requests.\n\nMax length: 256 characters.",
            "x-example-override": "GB"
          },
          "accessibility": {
            "$ref": "#/components/schemas/customersCustomerAccessibility",
            "description": "The customer's accessibility requirements. Optional for create requests.",
            "x-example-override": "CUSTOMER_ACCESSIBILITY_LARGE_PRINT"
          },
          "external_customer_id": {
            "type": "string",
            "description": "An external customer ID. May be used to associate a customer in Vault with an existing customer ID. Vault does not use this for any other purpose. Optional for create requests.\n\nMax length: 256 characters.",
            "x-example-override": "b29ebe57-fbcd-4377-95b5-b0e3f3cf95d7"
          }
        },
        "description": "Customer details. This details object will be replaced by a more general object in the future."
      },
      "customersCustomerGender": {
        "type": "string",
        "enum": [
          "CUSTOMER_GENDER_UNKNOWN",
          "CUSTOMER_GENDER_FEMALE",
          "CUSTOMER_GENDER_MALE"
        ],
        "default": "CUSTOMER_GENDER_UNKNOWN",
        "description": "The customer's gender."
      },
      "customersCustomerStatus": {
        "type": "string",
        "enum": [
          "CUSTOMER_STATUS_UNKNOWN",
          "CUSTOMER_STATUS_ACTIVE",
          "CUSTOMER_STATUS_FROZEN",
          "CUSTOMER_STATUS_DECEASED",
          "CUSTOMER_STATUS_PROSPECT"
        ],
        "default": "CUSTOMER_STATUS_UNKNOWN",
        "x-enum-value-descriptions": {
          "CUSTOMER_STATUS_ACTIVE": "The customer status is active. To open an account, the customer status must be active; accounts cannot be opened for a customer with any other customer status. The status of an active customer could change to either frozen or deceased but cannot change to prospect.",
          "CUSTOMER_STATUS_DECEASED": "The customer status is deceased. Accounts cannot be opened for the customer but may still be active. The status of a deceased customer could change to either active or frozen but cannot change to prospect.",
          "CUSTOMER_STATUS_FROZEN": "The customer status is frozen. Accounts cannot be opened for the customer. The status of a frozen customer could change to either active or deceased but cannot change to prospect.",
          "CUSTOMER_STATUS_PROSPECT": "The customer status is not yet active. Accounts cannot be opened. The status of a prospect customer can only change to active. Once the status has changed from prospect, it cannot be changed back to prospect.",
          "CUSTOMER_STATUS_UNKNOWN": "The customer status is unknown."
        }
      },
      "customersCustomerTitle": {
        "type": "string",
        "enum": [
          "CUSTOMER_TITLE_UNKNOWN",
          "CUSTOMER_TITLE_MISS",
          "CUSTOMER_TITLE_MR",
          "CUSTOMER_TITLE_MRS",
          "CUSTOMER_TITLE_MS"
        ],
        "default": "CUSTOMER_TITLE_UNKNOWN",
        "description": "The customer's title."
      },
      "customersListCustomerAddressesResponse": {
        "type": "object",
        "properties": {
          "customer_addresses": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/customersCustomerAddress"
            },
            "description": "A list of customer addresses, ordered by descending creation time."
          },
          "next_page_token": {
            "type": "string",
            "description": "Token used to retrieve the next page. If empty, returns the last page of results.",
            "x-example-override": ""
          },
          "previous_page_token": {
            "type": "string",
            "description": "Token used to retrieve the previous page. If empty, returns the first page of results.",
            "x-example-override": "MTkw"
          }
        }
      },
      "customersListCustomersResponse": {
        "type": "object",
        "properties": {
          "customers": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/customersCustomer"
            },
            "description": "A list of customers. Customers are ordered by ascending ID."
          },
          "next_page_token": {
            "type": "string",
            "description": "Token used to retrieve the next page. If empty, the response contains the last page of results.",
            "x-example-override": ""
          },
          "previous_page_token": {
            "type": "string",
            "description": "Token used to retrieve the previous page. If empty, the response contains the first page of results.",
            "x-example-override": "MjI2NDEwMDM4OTg2MTU3NTI4OCE2NDk5MDIzODgyNTk2NTYyNzMy"
          }
        }
      },
      "customersUpdateCustomerAdditionalDetailsRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent.\n\nRequired.\nMax length: 512 characters.",
            "x-example-override": "b73bfaaf-7d8f-4bac-9c4f-69e7197108ee"
          },
          "customer_id": {
            "type": "string",
            "description": "The unique ID of the customer.\n\nRequired.",
            "x-example-override": "6499023882596562732"
          },
          "items_to_add": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Items that are to be added to the customer's additional details. Required if there are no items to remove.\n\nRequired.",
            "x-example-override": "{\"key1\": \"value1\"}"
          },
          "items_to_remove": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Items that are to be removed from the customer's additional details. Required if there are no items to add.",
            "x-example-override": "[\"key2\", \"key3\"]"
          }
        },
        "required": [
          "request_id",
          "customer_id",
          "items_to_add"
        ]
      },
      "customersUpdateCustomerAddressRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent.\n\nRequired.\nMax length: 512 characters.",
            "x-example-override": "106e5193-d062-4688-aef3-1f208bfa9b02"
          },
          "customer_address": {
            "$ref": "#/components/schemas/customersCustomerAddress",
            "description": "The address to be updated. Required.",
            "x-excluded-fields": [
              "id",
              "customer_id"
            ]
          },
          "update_mask": {
            "$ref": "#/components/schemas/protobufFieldMask",
            "description": "Field mask used to indicate which fields of the customer's address are to be updated. Required.",
            "x-example-override": "{\"paths\": [\"street_number\", \"street\", \"postal_area\"]}"
          }
        },
        "required": [
          "request_id"
        ]
      },
      "customersUpdateCustomerRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent.\n\nRequired.\nMax length: 512 characters.",
            "x-example-override": "2b245df5-5d0c-49f3-9a96-ec14a0795364"
          },
          "customer": {
            "$ref": "#/components/schemas/customersCustomer",
            "description": "The customer to update.",
            "x-excluded-fields": [
              "id",
              "additional_details"
            ]
          },
          "update_mask": {
            "$ref": "#/components/schemas/protobufFieldMask",
            "description": "Field mask used to indicate which fields of the customer's details are to be updated. Required.",
            "x-example-override": "{\"paths\": [\"status\", \"identifiers\", \"customer_details.contact_method\"]}"
          }
        },
        "required": [
          "request_id"
        ]
      },
      "CoreAPIJournalEventsUNIMPLEMENTED_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "UNIMPLEMENTED"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          }
        }
      },
      "eventsGetJournalEventsChecksumResponse": {
        "type": "object",
        "properties": {
          "window_journal_events_count": {
            "type": "integer",
            "format": "int32",
            "description": "The number of messages whose timestamps fall within the time window."
          },
          "window_journal_events_checksum": {
            "type": "string",
            "description": "The checksum of the journal events ids. Given an array of strings, each string is encoded using SHA256 returning a hexadecimal string representation with a fixed length. The XOR operation is performed on each bit in the SHA256 encoded representations of the first two strings. This is repeated for each subsequent encoded string performing the XOR operation with the previous result."
          }
        }
      },
      "eventsJournalEvent": {
        "type": "object",
        "properties": {
          "event_id": {
            "type": "string",
            "description": "Uniquely identifies the event in Vault."
          },
          "resource_id": {
            "type": "string",
            "description": "The identifier of affected resource that triggered this event."
          },
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time at which the journal event occurred."
          },
          "change_id": {
            "type": "string",
            "format": "int64",
            "description": "This is used to uniquely identify the version of this journal event."
          },
          "related_resource": {
            "$ref": "#/components/schemas/eventsRelatedResource",
            "description": "This is the related resource meaningful for this journal."
          },
          "published": {
            "type": "boolean",
            "description": "Indicates if this journal event has been published to the streaming API."
          }
        }
      },
      "eventsJournalEventToReplay": {
        "type": "object",
        "properties": {
          "event_identifier": {
            "$ref": "#/components/schemas/event_identifier",
            "required": false
          },
          "resource_identifier": {
            "$ref": "#/components/schemas/eventsResourceIdentifier",
            "required": false
          },
          "related_resource_identifier": {
            "$ref": "#/components/schemas/eventsRelatedResourceIdentifier",
            "required": false
          }
        }
      },
      "eventsListJournalEventsResponse": {
        "type": "object",
        "properties": {
          "journal_events": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/eventsJournalEvent"
            },
            "description": "A list of journal events whose timestamps fall within the time window."
          },
          "previous_page_token": {
            "type": "string",
            "description": "Token used to retrieve the previous page. If empty, returns the first page of results."
          },
          "next_page_token": {
            "type": "string",
            "description": "Token used to retrieve the next page. If empty, returns the last page of results."
          }
        }
      },
      "eventsRelatedResource": {
        "type": "object",
        "properties": {
          "type": {
            "$ref": "#/components/schemas/eventsResourceType"
          },
          "id": {
            "type": "string"
          },
          "sequence_number": {
            "type": "string",
            "format": "int64"
          }
        }
      },
      "eventsRelatedResourceIdentifier": {
        "type": "object",
        "properties": {
          "related_resource_id": {
            "type": "string"
          },
          "sequence_number": {
            "type": "string",
            "format": "int64"
          }
        }
      },
      "eventsReplayJournalEventsRequest": {
        "type": "object",
        "properties": {
          "resource_type": {
            "$ref": "#/components/schemas/eventsResourceType",
            "description": "The type of the Vault resource."
          },
          "journal_events_to_replay": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/eventsJournalEventToReplay"
            },
            "title": "The list of events to replay. Duplicate identifiers are ignored and the corresponding events will only be replayed once"
          }
        }
      },
      "eventsReplayJournalEventsResponse": {
        "type": "object",
        "properties": {
          "journal_events_batch_id": {
            "type": "string",
            "description": "All events whose replay is triggered by a single request will be identified by this unique ID. This ID is not persistent in Vault - if you need to use the ID to correlate which events have been streamed out as a result of this request, you will need to persist it."
          }
        },
        "title": "The response is either successful or an error is thrown"
      },
      "eventsResourceIdentifier": {
        "type": "object",
        "properties": {
          "resource_id": {
            "type": "string"
          },
          "change_id": {
            "type": "string",
            "format": "int64"
          }
        }
      },
      "eventsResourceType": {
        "type": "string",
        "enum": [
          "RESOURCE_TYPE_UNKNOWN",
          "RESOURCE_TYPE_SCHEDULER_OPERATION",
          "RESOURCE_TYPE_ACCOUNT_BALANCE",
          "RESOURCE_TYPE_ENRICHED_POSTING_INSTRUCTION_BATCH",
          "RESOURCE_TYPE_POSTING_INSTRUCTION_BATCH",
          "RESOURCE_TYPE_ACCOUNT",
          "RESOURCE_TYPE_ACCOUNT_UPDATE",
          "RESOURCE_TYPE_ACCOUNT_UPDATE_BATCH",
          "RESOURCE_TYPE_ACCOUNT_V2",
          "RESOURCE_TYPE_RESTRICTION_SET",
          "RESOURCE_TYPE_FLAG"
        ],
        "default": "RESOURCE_TYPE_UNKNOWN",
        "x-enum-value-release-info": {
          "RESOURCE_TYPE_ACCOUNT_V2": {
            "releaseVersion": {
              "major": 5
            },
            "changeType": "ADD_FIELD",
            "featureFlag": "CPP_1430_ACCOUNTS_V2"
          },
          "RESOURCE_TYPE_FLAG": {
            "releaseVersion": {
              "major": 4,
              "minor": 6
            },
            "changeType": "ADD_FIELD",
            "featureFlag": "TM_77174_FLAG_EVENT_RECONCILIATION"
          },
          "RESOURCE_TYPE_RESTRICTION_SET": {
            "releaseVersion": {
              "major": 4,
              "minor": 6
            },
            "changeType": "ADD_FIELD",
            "featureFlag": "TM_77183_RESTRICTION_SET_RECONCILIATION"
          }
        },
        "x-enum-value-descriptions": {
          "RESOURCE_TYPE_ACCOUNT": "Core API v1 Account.",
          "RESOURCE_TYPE_ACCOUNT_BALANCE": "Balance from Balances API.",
          "RESOURCE_TYPE_ACCOUNT_UPDATE": "Account Update from Account API.",
          "RESOURCE_TYPE_ACCOUNT_UPDATE_BATCH": "Account Update Batch from Account Processor (Accounts Service).",
          "RESOURCE_TYPE_ACCOUNT_V2": "Core API v2 Account.",
          "RESOURCE_TYPE_ENRICHED_POSTING_INSTRUCTION_BATCH": "Enriched Posting Instruction Batch from Postings API.",
          "RESOURCE_TYPE_POSTING_INSTRUCTION_BATCH": "Posting Instruction Batch from Postings API.",
          "RESOURCE_TYPE_RESTRICTION_SET": "Restriction Set from Restriction API.",
          "RESOURCE_TYPE_SCHEDULER_OPERATION": "Scheduler Operation from Scheduler API."
        }
      },
      "eventsTimeWindow": {
        "type": "object",
        "properties": {
          "lower_bound_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "Lower bound timestamp (inclusive)."
          },
          "upper_bound_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "Upper bound timestamp (exclusive)."
          }
        }
      },
      "flagsBatchGetFlagDefinitionsResponse": {
        "type": "object",
        "properties": {
          "flag_definitions": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/flagsFlagDefinition"
            },
            "description": "Maps requested flag definition IDs to their flag definitions."
          }
        }
      },
      "flagsBatchGetFlagsResponse": {
        "type": "object",
        "properties": {
          "flags": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/flagsFlag"
            },
            "description": "Maps requested flag IDs to their flag."
          }
        }
      },
      "flagsCreateFlagDefinitionRequest": {
        "type": "object",
        "properties": {
          "flag_definition": {
            "$ref": "#/components/schemas/flagsFlagDefinition",
            "description": "The flag definition that is to be created. Required.",
            "x-excluded-fields": [
              "create_timestamp",
              "is_active"
            ]
          },
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent.\n\nRequired.\nMax length: 256 characters."
          }
        },
        "required": [
          "request_id"
        ]
      },
      "flagsCreateFlagRequest": {
        "type": "object",
        "properties": {
          "flag": {
            "$ref": "#/components/schemas/flagsFlag",
            "description": "The flag that is to be created. Required.",
            "x-excluded-fields": [
              "id",
              "is_active"
            ]
          },
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent.\n\nRequired.\nMax length: 256 characters."
          }
        },
        "required": [
          "request_id"
        ]
      },
      "flagsListFlagDefinitionsResponse": {
        "type": "object",
        "properties": {
          "flag_definitions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/flagsFlagDefinition"
            },
            "description": "A list of matching flag definitions, sorted by descending `create_timestamp`."
          },
          "previous_page_token": {
            "type": "string",
            "description": "Token used to retrieve the previous page. If empty, returns the first page of results."
          },
          "next_page_token": {
            "type": "string",
            "description": "Token used to retrieve the next page. If empty, returns the last page of results."
          }
        }
      },
      "flagsListFlagsResponse": {
        "type": "object",
        "properties": {
          "flags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/flagsFlag"
            },
            "description": "A list of matching flags, sorted by descending creation time."
          },
          "previous_page_token": {
            "type": "string",
            "description": "Token used to retrieve the previous page. If empty, returns the first page of results."
          },
          "next_page_token": {
            "type": "string",
            "description": "Token used to retrieve the next page. If empty, returns the last page of results."
          }
        }
      },
      "flagsUpdateFlagDefinitionRequest": {
        "type": "object",
        "properties": {
          "flag_definition": {
            "$ref": "#/components/schemas/flagsFlagDefinition",
            "description": "The flag definition that is to be updated. Required.",
            "x-excluded-fields": [
              "id",
              "name",
              "description",
              "required_flag_level",
              "create_timestamp",
              "flag_visibility"
            ]
          },
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent.\n\nRequired.\nMax length: 256 characters."
          },
          "update_mask": {
            "$ref": "#/components/schemas/protobufFieldMask",
            "description": "Field mask used to indicate which fields in the field definition are to be updated. The only valid path in the update_mask is 'is_active'. Required."
          }
        },
        "required": [
          "request_id"
        ]
      },
      "flagsUpdateFlagRequest": {
        "type": "object",
        "properties": {
          "flag": {
            "$ref": "#/components/schemas/flagsFlag",
            "description": "The flag that is to be updated. Required.",
            "x-excluded-fields": [
              "id",
              "flag_definition_id",
              "customer_id",
              "account_id",
              "payment_device_id",
              "effective_timestamp",
              "expiry_timestamp"
            ]
          },
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent.\n\nRequired.\nMax length: 256 characters."
          },
          "update_mask": {
            "$ref": "#/components/schemas/protobufFieldMask",
            "description": "Field mask used to indicate which fields in the flag are to be updated. Valid paths in the update mask are 'description' and 'is_active'. Required."
          }
        },
        "required": [
          "request_id"
        ]
      },
      "CreateGlobalParameterValueFAILED_PRECONDITION_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "FAILED_PRECONDITION"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsPreconditionFailureCreateGlobalParameterValueFAILED_PRECONDITION_0",
                  "title": "PreconditionFailure"
                }
              ]
            }
          }
        }
      },
      "PreconditionFailureViolationCreateGlobalParameterValueFAILED_PRECONDITION_0": {
        "type": "object",
        "properties": {
          "violation_type": {
            "type": "string",
            "title": "A set of canonical violation types that can be used by API client to programmatically handle the error. A resource or API specific enum type must be defined for the supported precondition violation subjects. e.g. enum DirectDebitPreconditionFailureTypes {     UNKNOWN               = 0; // string representation: \"UNKNOWN\"     BANK_ACCOUNT_DISABLED = 1; // string representation: \"BANK_ACCOUNT_DISABLED\"     MANDATE_INACTIVE      = 2; // string representation: \"MANDATE_INACTIVE\" }",
            "x-example-override": "OVERLAPS_EXPLICIT_PARAMETER_VALUE_EFFECTIVE_TIMESTAMP_RANGE"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional structured details about this error.\n\nKeys should match /[a-zA-Z0-9-_]/ and be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than {\"instance_limit\": \"100/request\"}, should be returned as, {\"instance_limit_per_request\": \"100\"}, if the client exceeds the number of instances that can be created in a single (batch) request.",
            "x-example-override": "{\"parameter_value.effective_from_timestamp\":\"value\",\"parameter_value.effective_to_timestamp\":\"value\",\"parameter_value.id\":\"value\"}",
            "x-metadata-release-info": [
              {
                "key": "parameter_value.id",
                "description": "The ID of the overlapped ParameterValue."
              },
              {
                "key": "parameter_value.effective_from_timestamp",
                "description": "The effective_from_timestamp of the overlapped ParameterValue."
              },
              {
                "key": "parameter_value.effective_to_timestamp",
                "description": "The effective_to_timestamp of the overlapped ParameterValue."
              }
            ]
          }
        },
        "description": "A message type used to describe a single precondition failure."
      },
      "errorsPreconditionFailureCreateGlobalParameterValueFAILED_PRECONDITION_0": {
        "type": "object",
        "properties": {
          "@type": {
            "type": "string",
            "description": "A type name to identify this detail.",
            "x-example-override": "http://type.googleapis.com/errors.PreconditionFailure"
          },
          "violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PreconditionFailureViolationCreateGlobalParameterValueFAILED_PRECONDITION_0"
            },
            "description": "Describes all precondition violations."
          }
        },
        "description": "Describes what preconditions have failed.\n\nFor example, if creating a direct debit failed because bank account validation failed, it could list the account violation in the PreconditionFailure message."
      },
      "global_parametersBatchGetGlobalParametersResponse": {
        "type": "object",
        "properties": {
          "global_parameters": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/global_parametersGlobalParameter"
            },
            "description": "Maps `GlobalParameter` ID to `GlobalParameter`."
          }
        }
      },
      "global_parametersCreateGlobalParameterRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID used for idempotency.\n\nRequired."
          },
          "global_parameter": {
            "$ref": "#/components/schemas/global_parametersGlobalParameter",
            "description": "The `GlobalParameter` to be created.\n\nRequired.",
            "x-excluded-fields": [
              "create_timestamp"
            ]
          },
          "initial_value": {
            "type": "string",
            "description": "This will be used to create a `GlobalParameterValue` associated with the newly created `GlobalParameter`. Use this value accordingly for each Global Parameter Type; for Dates, it is in the format `YYYY-MM-DD`. The `effective_timestamp` of the created `GlobalParameterValue` will be the Unix epoch.\n\nRequired."
          }
        },
        "required": [
          "request_id",
          "global_parameter",
          "initial_value"
        ]
      },
      "global_parametersCreateGlobalParameterValueRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID used for idempotency.\n\nRequired."
          },
          "global_parameter_value": {
            "$ref": "#/components/schemas/global_parametersGlobalParameterValue",
            "description": "The `GlobalParameterValue` to be created.\n\nRequired.",
            "x-excluded-fields": [
              "id",
              "create_timestamp"
            ]
          }
        },
        "required": [
          "request_id",
          "global_parameter_value"
        ]
      },
      "global_parametersListGlobalParameterValuesResponse": {
        "type": "object",
        "properties": {
          "global_parameter_values": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/global_parametersGlobalParameterValue"
            },
            "description": "A list of `GlobalParameterValue`s, ordered by ascending effective time."
          },
          "next_page_token": {
            "type": "string",
            "description": "The token used to retrieve the next page. If empty, this returns the last page of results."
          },
          "previous_page_token": {
            "type": "string",
            "description": "The token used to retrieve the previous page. If empty, this returns the first page of results."
          }
        }
      },
      "global_parametersListGlobalParametersResponse": {
        "type": "object",
        "properties": {
          "global_parameters": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/global_parametersGlobalParameter"
            },
            "description": "A list of `GlobalParameter`s, ordered by descending creation time."
          },
          "next_page_token": {
            "type": "string",
            "description": "The token used to retrieve the next page. If empty, this returns the last page of results."
          },
          "previous_page_token": {
            "type": "string",
            "description": "The token used to retrieve the previous page. If empty, this returns the first page of results."
          }
        }
      },
      "accounts_commonAccountView": {
        "type": "string",
        "enum": [
          "ACCOUNT_VIEW_BASIC"
        ],
        "default": "ACCOUNT_VIEW_BASIC",
        "x-enum-value-descriptions": {
          "ACCOUNT_VIEW_BASIC": "Returned Account(s) include no balances. Default."
        }
      },
      "internal_accountsBatchGetInternalAccountsResponse": {
        "type": "object",
        "properties": {
          "internal_accounts": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/internal_accountsInternalAccount"
            },
            "description": "Map of the internal account ID to the internal account."
          }
        }
      },
      "internal_accountsCreateInternalAccountRequest": {
        "type": "object",
        "properties": {
          "internal_account": {
            "$ref": "#/components/schemas/internal_accountsInternalAccount",
            "description": "The internal account that is to be created. Required.",
            "x-excluded-fields": [
              "name",
              "product_version_id",
              "status",
              "opening_timestamp"
            ]
          },
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent. Required.\n\nRequired.\nMax length: 256 characters."
          }
        },
        "required": [
          "request_id"
        ]
      },
      "internal_accountsInternalAccount": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "A unique identifier for the account.\n\nRequired.\nMax length: 36 characters."
          },
          "name": {
            "type": "string",
            "description": "The account name."
          },
          "product_id": {
            "type": "string",
            "description": "The ID of the product. Required for create requests."
          },
          "product_version_id": {
            "type": "string",
            "description": "The ID of the product version."
          },
          "permitted_denominations": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Denominations the account can hold balances in. Must be a subset of the denomination supported for the product version. Optional for create requests, defaults to the denominations supported for the product version if the product version defines `supported_denominations`. Otherwise, defaults to the `PERMITTED_DENOMINATIONS` defined in the configuration."
          },
          "status": {
            "$ref": "#/components/schemas/accounts_commonAccountStatus",
            "description": "The status of the account."
          },
          "opening_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time when the account was opened."
          },
          "details": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "A map of unstructured fields that hold instance-specific account details, for example, the source of funds. Optional for create requests.<br> <br>The details must not include:<br> - Any image data, including any KYC collateral such as passport, licence or other images. These must be stored in a separate repository outside of Vault.<br> - Any data that is classified as PII data.<br> The details cannot be utilised by Smart Contracts to drive any type of product behaviour.<br><br> Max size: 1MB (but it is strongly recommended to keep below this size)."
          },
          "accounting": {
            "$ref": "#/components/schemas/accounts_commonAccounting",
            "description": "The accounting data that Vault supports as first-class fields. Required for create requests."
          }
        },
        "required": [
          "id"
        ]
      },
      "internal_accountsListInternalAccountsResponse": {
        "type": "object",
        "properties": {
          "internal_accounts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/internal_accountsInternalAccount"
            },
            "description": "List of matching internal accounts, ordered by ascending `id`."
          },
          "previous_page_token": {
            "type": "string",
            "description": "Token used to retrieve the previous page. If empty, returns the first page of results."
          },
          "next_page_token": {
            "type": "string",
            "description": "Token used to retrieve the next page. If empty, returns the last page of results."
          }
        }
      },
      "ledger_balancesLedgerBalance": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The ID of the Ledger Balance. Output only.",
            "x-example-override": "b2d26233-9438-43b3-abe5-cda0db5dfcae"
          },
          "account_id": {
            "type": "string",
            "description": "The ID of the associated account.",
            "x-example-override": "bebbe4e5-fdcc-4247-a71d-8b02ba3d3b90"
          },
          "account_address": {
            "type": "string",
            "description": "The account address, which represents one partition of the total balances held on the account.",
            "x-example-override": "DEFAULT"
          },
          "phase": {
            "$ref": "#/components/schemas/ledger_balancesPostingPhase",
            "description": "The posting phase the balance applies to."
          },
          "asset": {
            "type": "string",
            "description": "The asset in which the balance is held.",
            "x-example-override": "COMMERCIAL_BANK_MONEY"
          },
          "denomination": {
            "type": "string",
            "description": "The denomination in which the balance is held for the given asset.",
            "x-example-override": "GBP"
          },
          "amount": {
            "type": "string",
            "description": "The amount, which is the net value of the balance.",
            "x-example-override": "30.50"
          },
          "total_debit": {
            "type": "string",
            "description": "The total sum of debits.",
            "x-example-override": "60.00"
          },
          "total_credit": {
            "type": "string",
            "description": "The total sum of credits.",
            "x-example-override": "90.50"
          }
        }
      },
      "ledger_balancesListLedgerBalancesResponse": {
        "type": "object",
        "properties": {
          "ledger_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The Postings Ledger timestamp indicating at what time these Ledger Balances were valid.",
            "x-example-override": "2020-01-13T19:13:23.000Z"
          },
          "ledger_balances": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/ledger_balancesLedgerBalance"
            },
            "description": "A list of matching Ledger Balances."
          },
          "previous_page_token": {
            "type": "string",
            "description": "The pagination token used to retrieve the previous page. If empty, this is the first page of results.",
            "x-example-override": "NiFDMjU"
          },
          "next_page_token": {
            "type": "string",
            "description": "The pagination token used to retrieve the next page. If empty, this is the last page of results.",
            "x-example-override": "KN2iHe4"
          }
        }
      },
      "ledger_balancesPostingPhase": {
        "type": "string",
        "enum": [
          "POSTING_PHASE_UNKNOWN",
          "POSTING_PHASE_PENDING_INCOMING",
          "POSTING_PHASE_PENDING_OUTGOING",
          "POSTING_PHASE_COMMITTED"
        ],
        "default": "POSTING_PHASE_UNKNOWN",
        "x-enum-value-descriptions": {
          "POSTING_PHASE_COMMITTED": "The posting is committed (hard posting).",
          "POSTING_PHASE_PENDING_INCOMING": "The posting is pending incoming (soft posting).",
          "POSTING_PHASE_PENDING_OUTGOING": "The posting is pending outgoing (soft posting).",
          "POSTING_PHASE_UNKNOWN": "The posting phase is not set which will result in a validation error."
        }
      },
      "payment_devicesBatchGetPaymentDeviceLinksResponse": {
        "type": "object",
        "properties": {
          "payment_device_links": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/payment_devicesPaymentDeviceLink"
            },
            "description": "Map of requested ids to their payment device links."
          }
        }
      },
      "payment_devicesBatchGetPaymentDevicesResponse": {
        "type": "object",
        "properties": {
          "payment_devices": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/payment_devicesPaymentDevice"
            },
            "description": "Map of requested ids to their payment device."
          }
        }
      },
      "payment_devicesCreatePaymentDeviceLinkRequest": {
        "type": "object",
        "properties": {
          "payment_device_link": {
            "$ref": "#/components/schemas/payment_devicesPaymentDeviceLink",
            "description": "The payment device link to create. Must have status active. The provided account must have status PENDING, OPEN or PENDING_CLOSURE and the payment device must have status PENDING or ACTIVE.",
            "x-excluded-fields": [
              "start_timestamp",
              "end_timestamp"
            ]
          },
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure this request is idempotent. Required.\n\nRequired.\nMax length: 256 characters."
          }
        },
        "required": [
          "request_id"
        ]
      },
      "payment_devicesCreatePaymentDeviceRequest": {
        "type": "object",
        "properties": {
          "payment_device": {
            "$ref": "#/components/schemas/payment_devicesPaymentDevice",
            "description": "The payment device to create.",
            "x-excluded-fields": [
              "create_timestamp"
            ]
          },
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure this request is idempotent. Required.\n\nRequired.\nMax length: 256 characters."
          }
        },
        "required": [
          "request_id"
        ]
      },
      "payment_devicesListPaymentDeviceLinksResponse": {
        "type": "object",
        "properties": {
          "payment_device_links": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/payment_devicesPaymentDeviceLink"
            },
            "description": "List of matching payment device links. Items are ordered by start_timestamp in descending order."
          }
        }
      },
      "payment_devicesPaymentDevice": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Caller injected or Vault auto-generated unique ID for payment device. Optional. When auto-generated, this is a UUID in the canonical 8-4-4-4-12 form.\n\nMax length: 36 characters.",
            "x-create-only": true
          },
          "routing_info": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Key -> value map for caller to reference when receiving/originating payment. Optional.\n",
            "x-create-only": true
          },
          "status": {
            "$ref": "#/components/schemas/payment_devicesPaymentDeviceStatus",
            "description": "Incremental payment device status. Required."
          },
          "create_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "Create timestamp. Differs from effective timestamp if created in pending. Output only.",
            "x-output-only": true
          },
          "start_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "When the payment device became active if the value is historic, or when the payment device will become active if the value is in the future. Defaults to current time when creating a payment device in `PAYMENT_DEVICE_STATUS_ACTIVE` status. Required for creating a payment device with status `PAYMENT_DEVICE_STATUS_INACTIVE`, optional for other create requests, and output only otherwise.\n"
          },
          "end_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "When the payment device became inactive if the value is historic, or when the payment device will become inactive if the value is in the future. Required for creating a payment device with status `PAYMENT_DEVICE_STATUS_INACTIVE`, optional for other create requests, and output only otherwise.\n"
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tags assigned to this payment device. Optional for creation; otherwise this is output only.",
            "x-create-only": true,
            "x-release-info": {
              "releaseVersion": {
                "major": 1,
                "minor": 9
              },
              "changeType": "ADD_FIELD"
            }
          }
        },
        "title": "Generic object to represent an instrument that can originate or/and receive payments Payment devices are immutable except for the status which reflects whether the payment device can be linked to accounts using payment device tokens or not"
      },
      "payment_devicesPaymentDeviceLink": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "A caller-injected or Vault auto-generated unique ID for the payment device link. When auto-generated, this is a UUID in the canonical 8-4-4-4-12 form.\n\nMax length: 36 characters.",
            "x-create-only": true
          },
          "token": {
            "type": "string",
            "description": "Token to identify this link. It has to be unique across active links. Required for create requests.",
            "x-create-only": true
          },
          "payment_device_id": {
            "type": "string",
            "description": "Payment device id this token connects an account to. Required for create requests.",
            "x-create-only": true
          },
          "account_id": {
            "type": "string",
            "description": "Account ID this token connects a payment device to. Required for create requests.",
            "x-create-only": true
          },
          "status": {
            "$ref": "#/components/schemas/payment_devicesPaymentDeviceLinkStatus",
            "description": "The status of the payment device link. Must have a value of `PAYMENT_DEVICE_LINK_STATUS_ACTIVE` or `PAYMENT_DEVICE_LINK_STATUS_INACTIVE` for create requests. Required for create requests."
          },
          "start_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "When the link became active. Required for create requests of payment device links with status `PAYMENT_DEVICE_LINK_STATUS_INACTIVE`, output only otherwise."
          },
          "end_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "When the link became inactive. Required for create requests of payment device links with status `PAYMENT_DEVICE_LINK_STATUS_INACTIVE`, output only otherwise."
          }
        },
        "description": "Represents a link between a payment device and an account via a token. Both payment devices and accounts can be connected via multiple such links. A payment device token can be associated with a single link at a time and moved across links. Movement can happen once a link has been soft deleted(or detokenised); the link will be made inactive and the token it used to held can be reused to create a new payment device link."
      },
      "payment_devicesPaymentDeviceLinkStatus": {
        "type": "string",
        "enum": [
          "PAYMENT_DEVICE_LINK_STATUS_UNKNOWN",
          "PAYMENT_DEVICE_LINK_STATUS_ACTIVE",
          "PAYMENT_DEVICE_LINK_STATUS_INACTIVE"
        ],
        "default": "PAYMENT_DEVICE_LINK_STATUS_UNKNOWN",
        "x-enum-value-descriptions": {
          "PAYMENT_DEVICE_LINK_STATUS_ACTIVE": "Link between account id and payment device can be used via the token.",
          "PAYMENT_DEVICE_LINK_STATUS_INACTIVE": "Invalid when creating a payment device link. Terminal status state, link is disabled, token can be reused.",
          "PAYMENT_DEVICE_LINK_STATUS_UNKNOWN": "Invalid when creating a payment device link."
        }
      },
      "payment_devicesPaymentDeviceStatus": {
        "type": "string",
        "enum": [
          "PAYMENT_DEVICE_STATUS_UNKNOWN",
          "PAYMENT_DEVICE_STATUS_PENDING",
          "PAYMENT_DEVICE_STATUS_ACTIVE",
          "PAYMENT_DEVICE_STATUS_INACTIVE"
        ],
        "default": "PAYMENT_DEVICE_STATUS_UNKNOWN",
        "x-enum-value-descriptions": {
          "PAYMENT_DEVICE_STATUS_ACTIVE": "Can transition only to PAYMENT_DEVICE_STATUS_INACTIVE. A payment device with this status can be linked to a valid account.",
          "PAYMENT_DEVICE_STATUS_INACTIVE": "Terminal status state, linking is disabled.",
          "PAYMENT_DEVICE_STATUS_PENDING": "Can transition only to PAYMENT_DEVICE_STATUS_ACTIVE or PAYMENT_DEVICE_STATUS_INACTIVE. A payment device with this status can be linked to a valid account. Clients can manage sub-statuses (e.g. card generated, card sent, card activated) within their own records.",
          "PAYMENT_DEVICE_STATUS_UNKNOWN": "Invalid when creating a payment device."
        }
      },
      "payment_devicesUpdatePaymentDeviceLinkRequest": {
        "type": "object",
        "properties": {
          "payment_device_link": {
            "$ref": "#/components/schemas/payment_devicesPaymentDeviceLink",
            "description": "Payment device to update. Currently only 'status' is supported.",
            "x-excluded-fields": [
              "id",
              "token",
              "payment_device_id",
              "account_id",
              "start_timestamp",
              "end_timestamp"
            ]
          },
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure this request is idempotent. Required.\n\nRequired.\nMax length: 256 characters."
          },
          "update_mask": {
            "$ref": "#/components/schemas/protobufFieldMask",
            "description": "Field mask to indicate which fields on the resource to update. Required. Valid update masks are: \"status\"."
          }
        },
        "required": [
          "request_id"
        ]
      },
      "payment_devicesUpdatePaymentDeviceRequest": {
        "type": "object",
        "properties": {
          "payment_device": {
            "$ref": "#/components/schemas/payment_devicesPaymentDevice",
            "description": "The payment device to update.",
            "x-excluded-fields": [
              "id",
              "routing_info",
              "create_timestamp",
              "start_timestamp",
              "end_timestamp",
              "tags"
            ]
          },
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure this request is idempotent. Required.\n\nRequired.\nMax length: 256 characters."
          },
          "update_mask": {
            "$ref": "#/components/schemas/protobufFieldMask",
            "description": "Field mask to indicate which fields on the resource to update. Required. Valid update masks are: \"status\"."
          },
          "overrides": {
            "$ref": "#/components/schemas/commonOverrides",
            "description": "This lets the caller override PREVENT_CLOSURE restrictions on a payment device; no other restriction types can be overridden."
          }
        },
        "required": [
          "request_id"
        ]
      },
      "calendar_operationsCalendarMode": {
        "type": "string",
        "enum": [
          "CALENDAR_MODE_NOOP",
          "CALENDAR_MODE_DELAY",
          "CALENDAR_MODE_SKIP",
          "CALENDAR_MODE_FORWARD"
        ],
        "default": "CALENDAR_MODE_NOOP",
        "x-enum-value-descriptions": {
          "CALENDAR_MODE_DELAY": "The schedule should be delayed.",
          "CALENDAR_MODE_FORWARD": "The schedule should be fast forwarded.",
          "CALENDAR_MODE_NOOP": "No operation",
          "CALENDAR_MODE_SKIP": "The schedule should be skipped."
        }
      },
      "calendar_operationsCalendarOperation": {
        "type": "object",
        "properties": {
          "calendar_id": {
            "type": "string",
            "description": "Calendar resource containing calendar events.",
            "x-example-override": "BACS"
          },
          "event_name": {
            "type": "string",
            "description": "The name of a calendar event.",
            "x-example-override": "FPS Working Day"
          },
          "calendar_mode": {
            "$ref": "#/components/schemas/calendar_operationsCalendarMode",
            "description": "Action to be taken on the schedules according to the calendar events."
          },
          "event_duration": {
            "type": "string",
            "description": "The duration of each calendar event. This is a strictly positive integer followed by time units \"m\" or \"h\". Possible valid durations include (but are not limited to): \"30m\", \"6h\", \"24h\".",
            "x-release-info": {
              "noticeVersion": {
                "major": 2
              },
              "releaseVersion": {
                "major": 5
              },
              "changeType": "REMOVE_FIELD",
              "description": "Event duration is computed internally from CalendarEvents."
            },
            "x-example-override": "24h"
          }
        },
        "description": "A Calendar Operation contains the information necessary to ensure forward dated payments consider weekends etc."
      },
      "payment_ordersBatchGetPaymentOrdersResponse": {
        "type": "object",
        "properties": {
          "payment_orders": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/payment_ordersPaymentOrder"
            },
            "description": "A map of the PaymentOrder ID to the PaymentOrder."
          }
        }
      },
      "payment_ordersCreatePaymentOrderRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A string UUID generated by the client used to ensure the request is idempotent.\nThis field must contain a valid UUID in the canonical 8-4-4-4-12 form.\nRequired.\nMax length: 36 characters."
          },
          "payment_order": {
            "$ref": "#/components/schemas/payment_ordersPaymentOrder",
            "description": "The PaymentOrder to be submitted. Required on resource creation.",
            "x-excluded-fields": [
              "id",
              "create_request_id",
              "type",
              "current_status",
              "create_timestamp",
              "update_timestamp"
            ]
          }
        },
        "required": [
          "request_id"
        ]
      },
      "payment_ordersFuturePaymentSchedule": {
        "type": "object",
        "properties": {
          "payment_date": {
            "type": "string",
            "description": "The date of the payment with format YYYY-MM-DDTHH:MM. A PaymentOrderExecution object with `payment_amount` will be streamed out on this date, and the PaymentOrderStatus will be set to COMPLETED. Required on resource creation.",
            "x-example-override": "2020-10-01T10:01"
          },
          "payment_amount": {
            "type": "string",
            "description": "The amount of the payment. Required on resource creation.",
            "x-example-override": "10.00"
          }
        }
      },
      "payment_ordersListPaymentOrdersResponse": {
        "type": "object",
        "properties": {
          "payment_orders": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/payment_ordersPaymentOrder"
            },
            "description": "A list of matching PaymentOrders in order of descending create_timestamp (most recent first)."
          },
          "previous_page_token": {
            "type": "string",
            "description": "Token used to retrieve the previous page. If empty, returns the first page of results."
          },
          "next_page_token": {
            "type": "string",
            "description": "Token used to retrieve the next page. If empty, returns the last page of results."
          }
        }
      },
      "payment_ordersParty": {
        "type": "object",
        "properties": {
          "routing_info_type": {
            "type": "string",
            "description": "The type of routing info (eg. \"IBAN\", \"UK.SortCodeAccountNumber\").",
            "x-example-override": "UK.SortCodeAccountNumber"
          },
          "identification": {
            "type": "string",
            "description": "Identification of the party account under the routing info type (eg. \"08080021325698\").",
            "x-example-override": "080800-21325698"
          },
          "name": {
            "type": "string",
            "description": "The customer name associated with the party account.",
            "x-example-override": "John Smith"
          }
        }
      },
      "payment_ordersPaymentOrder": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The UUID of the PaymentOrder inside Vault. Optional on resource creation; if it is not set, a UUID will be generated. Required for update calls.\nThis field must contain a valid UUID in the canonical 8-4-4-4-12 form.\nMax length: 36 characters."
          },
          "create_request_id": {
            "type": "string",
            "description": "The ID of the request that originally generated the payment. Used as idempotency key."
          },
          "client_id": {
            "type": "string",
            "description": "Uniquely identifies a client of the PaymentOrder endpoints. Required on resource creation.",
            "x-example-override": "scheduled_payments_processor"
          },
          "client_order_id": {
            "type": "string",
            "description": "An order ID set by the client. Optional on resource creation.",
            "x-example-override": "fdp_2020_09_01_1"
          },
          "debtor_account_id": {
            "type": "string",
            "description": "The debtor's Vault account ID. If the account does not exist or is not in a state which allows payment creation, an error is returned and no PaymentOrder will be created. Allowed account status is OPEN only. Required on resource creation."
          },
          "debtor_party": {
            "$ref": "#/components/schemas/payment_ordersParty",
            "description": "The details of the party sending the payment. No validation or logic is done on this field. Optional on resource creation."
          },
          "creditor_party": {
            "$ref": "#/components/schemas/payment_ordersParty",
            "description": "The details of the party receiving the payment. No validation or logic is done on this field. Optional on resource creation."
          },
          "denomination": {
            "type": "string",
            "description": "The three-letter alphabetic currency code based on ISO 4217, for example GBP and USD. Required on resource creation."
          },
          "reference": {
            "type": "string",
            "description": "Reference information associated with the payment that will be passed to the beneficiary. Optional on resource creation.\n\nMax length: 512 characters.",
            "x-example-override": "Rent October"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Metadata related to the payment. Optional on resource creation."
          },
          "type": {
            "$ref": "#/components/schemas/payment_ordersPaymentOrderType",
            "description": "The type of this PaymentOrder."
          },
          "current_status": {
            "$ref": "#/components/schemas/payment_ordersPaymentOrderStatus",
            "description": "The status of the PaymentOrder."
          },
          "create_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The timestamp indicating when the PaymentOrder was created."
          },
          "update_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The timestamp indicating when the last change to the PaymentOrder occurred."
          },
          "calendar_operation": {
            "$ref": "#/components/schemas/calendar_operationsCalendarOperation",
            "description": "\n",
            "title": "CalendarOperation details for this PaymentOrder",
            "x-release-info": {
              "releaseVersion": {
                "major": 1,
                "minor": 12
              },
              "changeType": "ADD_FIELD"
            }
          },
          "future_schedule": {
            "$ref": "#/components/schemas/payment_ordersFuturePaymentSchedule",
            "required": false
          },
          "recurring_schedule": {
            "$ref": "#/components/schemas/payment_ordersRecurringPaymentSchedule",
            "required": false
          }
        }
      },
      "payment_ordersPaymentOrderStatus": {
        "type": "string",
        "enum": [
          "PAYMENT_ORDER_STATUS_UNKNOWN",
          "PAYMENT_ORDER_STATUS_ACTIVE",
          "PAYMENT_ORDER_STATUS_INACTIVE",
          "PAYMENT_ORDER_STATUS_CANCELLED",
          "PAYMENT_ORDER_STATUS_COMPLETED"
        ],
        "default": "PAYMENT_ORDER_STATUS_UNKNOWN",
        "x-enum-value-descriptions": {
          "PAYMENT_ORDER_STATUS_ACTIVE": "The PaymentOrder has been accepted, committed to the ledger and sent for scheduling or execution.",
          "PAYMENT_ORDER_STATUS_CANCELLED": "The PaymentOrder has been cancelled by the client and no further events will be streamed.",
          "PAYMENT_ORDER_STATUS_COMPLETED": "The PaymentOrder has been completed and no further events will be streamed.",
          "PAYMENT_ORDER_STATUS_INACTIVE": "The PaymentOrder is suspended and no events will be streamed.",
          "PAYMENT_ORDER_STATUS_UNKNOWN": "Default value."
        }
      },
      "payment_ordersPaymentOrderType": {
        "type": "string",
        "enum": [
          "PAYMENT_ORDER_TYPE_UNKNOWN",
          "PAYMENT_ORDER_TYPE_FUTURE_DATED",
          "PAYMENT_ORDER_TYPE_RECURRING"
        ],
        "default": "PAYMENT_ORDER_TYPE_UNKNOWN",
        "x-enum-value-descriptions": {
          "PAYMENT_ORDER_TYPE_FUTURE_DATED": "Indicates a single payment executed in the future.",
          "PAYMENT_ORDER_TYPE_RECURRING": "Indicates a recurring payment.",
          "PAYMENT_ORDER_TYPE_UNKNOWN": "Default value."
        }
      },
      "payment_ordersRecurringPaymentSchedule": {
        "type": "object",
        "properties": {
          "first_payment_date": {
            "type": "string",
            "description": "The date of the first payment with format YYYY-MM-DDTHH:MM. A PaymentOrderExecution object with `first_payment_amount` (or `recurring_amount` if it is not set) will be streamed on this date. Required on resource creation.",
            "x-example-override": "2020-10-01T15:02"
          },
          "first_payment_amount": {
            "type": "string",
            "description": "The amount of the first payment. Optional on resource creation.",
            "x-example-override": "500.00"
          },
          "last_payment_amount": {
            "type": "string",
            "description": "The amount of the last payment. Optional on resource creation.",
            "x-example-override": "200.00"
          },
          "recurring_schedule_start_date": {
            "type": "string",
            "description": "The recurring schedule start date with format YYYY-MM-DDTHH:MM. This field should be set as part of a `recurring_schedule_expression` update to specify when the new expression should be applied from. A PaymentOrderExecution object with `recurring_amount` will be streamed on this date and then at regular intervals according to the new `recurring_schedule_expression`. This field cannot be set if the `first_payment_date` has not yet been reached. The date must be in the future.",
            "x-update-only": true,
            "x-example-override": "2021-10-01T15:02"
          },
          "recurring_schedule_expression": {
            "type": "string",
            "description": "The cron expression for the recurring payment. The recurring schedule will generate PaymentOrderExecution events with `recurring_amount` after `first_payment_date` (or `recurring_schedule_expression` on updates). Required on resource creation.",
            "x-example-override": "2 15 1 * *"
          },
          "recurring_amount": {
            "type": "string",
            "description": "The amount of the recurring payment. Required on resource creation.",
            "x-example-override": "100.00"
          },
          "last_payment_date": {
            "$ref": "#/components/schemas/last_payment_date",
            "required": false
          },
          "number_of_payments": {
            "$ref": "#/components/schemas/number_of_payments",
            "required": false
          }
        }
      },
      "payment_ordersUpdatePaymentOrderRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A string UUID used to ensure the request is idempotent. Required.\nThis field must contain a valid UUID in the canonical 8-4-4-4-12 form.\nRequired.\nMax length: 36 characters."
          },
          "payment_order": {
            "$ref": "#/components/schemas/payment_ordersPaymentOrder",
            "description": "The PaymentOrder object that needs to be updated. Required.",
            "x-excluded-fields": [
              "create_request_id",
              "client_id",
              "client_order_id",
              "debtor_account_id",
              "debtor_party",
              "creditor_party",
              "metadata",
              "type",
              "create_timestamp",
              "update_timestamp",
              "recurring_schedule.number_of_payments"
            ]
          },
          "update_mask": {
            "$ref": "#/components/schemas/protobufFieldMask",
            "description": "Field mask used to indicate which fields in the resource are to be updated. The allowed fields are `current_status`, `denomination`, `reference`, `future_schedule.payment_date`, `future_schedule.payment_amount`, `recurring_schedule.first_payment_date`, `recurring_schedule.first_payment_amount`, `recurring_schedule.recurring_schedule_expression`, `recurring_schedule.recurring_amount`, `recurring_schedule.last_payment_date`, `recurring_schedule.last_payment_amount`, `calendar_operation.calendar_id`, `calendar_operation.event_name`, `calendar_operation.calendar_mode`. Required.",
            "x-example-override": "{\"paths\": [\"reference\", \"current_status\", \"denomination\", \"future_schedule.payment_amount\", \"future_schedule.payment.date\"]}"
          }
        },
        "required": [
          "request_id"
        ]
      },
      "plansActivationUpdate": {
        "type": "object"
      },
      "plansAssociateAccountUpdate": {
        "type": "object",
        "properties": {
          "account_id": {
            "type": "string",
            "description": "The ID of the account to associate with the plan."
          }
        }
      },
      "plansBatchGetAccountPlanAssocsResponse": {
        "type": "object",
        "properties": {
          "account_plan_assocs": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/plansAccountPlanAssoc"
            },
            "description": "A map of the account plan association ID to the account plan association."
          }
        }
      },
      "plansBatchGetPlanMigrationsResponse": {
        "type": "object",
        "properties": {
          "plan_migrations": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/plansPlanMigration"
            },
            "description": "A map of the plan migration ID to the plan migration."
          }
        }
      },
      "plansBatchGetPlanUpdatesResponse": {
        "type": "object",
        "properties": {
          "plan_updates": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/plansPlanUpdate"
            },
            "description": "A map of the plan update ID to the plan update."
          }
        }
      },
      "plansBatchGetPlansResponse": {
        "type": "object",
        "properties": {
          "plans": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/plansPlan"
            },
            "description": "A map of the plan ID to the plan."
          }
        }
      },
      "plansClosureUpdate": {
        "type": "object"
      },
      "plansCreatePlanMigrationRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure this request is idempotent. Mandatory.\n\nRequired.\nMax length: 512 characters."
          },
          "plan_migration": {
            "$ref": "#/components/schemas/plansPlanMigration",
            "description": "The plan migration to create. Mandatory.",
            "x-excluded-fields": [
              "status",
              "create_timestamp",
              "last_status_update_timestamp"
            ]
          }
        },
        "required": [
          "request_id"
        ]
      },
      "plansCreatePlanRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent. Required.\n\nRequired.\nMax length: 512 characters."
          },
          "plan": {
            "$ref": "#/components/schemas/plansPlan",
            "description": "The plan object to be created. Required.",
            "x-excluded-fields": [
              "create_timestamp",
              "opening_timestamp",
              "activation_completed_timestamp",
              "closing_timestamp",
              "closure_completed_timestamp"
            ]
          }
        },
        "required": [
          "request_id"
        ]
      },
      "plansCreatePlanUpdateRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent. Required.\n\nRequired.\nMax length: 256 characters."
          },
          "plan_update": {
            "$ref": "#/components/schemas/plansPlanUpdate",
            "description": "The plan update to create. Required.",
            "x-excluded-fields": [
              "create_timestamp",
              "last_status_update_timestamp",
              "failure_reason"
            ]
          }
        },
        "required": [
          "request_id"
        ]
      },
      "plansDisassociateAccountUpdate": {
        "type": "object",
        "properties": {
          "account_plan_assoc_id": {
            "type": "string",
            "description": "The ID of the account plan association to dissasociate."
          }
        }
      },
      "plansListAccountPlanAssocsResponse": {
        "type": "object",
        "properties": {
          "account_plan_assocs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/plansAccountPlanAssoc"
            },
            "description": "A list of matching plans, ordered by descending `create_timestamp`."
          },
          "previous_page_token": {
            "type": "string",
            "description": "The pagination token used to retrieve the previous page. If empty, this is the first page of results."
          },
          "next_page_token": {
            "type": "string",
            "description": "The pagination token used to retrieve the next page. If empty, this is the last page of results."
          }
        }
      },
      "plansListPlanMigrationsResponse": {
        "type": "object",
        "properties": {
          "plan_migrations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/plansPlanMigration"
            },
            "description": "A list of PlanMigrations, ordered by timestamp."
          },
          "previous_page_token": {
            "type": "string",
            "description": "Token used to retrieve the previous page. If empty, the response contains the first page of results."
          },
          "next_page_token": {
            "type": "string",
            "description": "Token used to retrieve the next page. If empty, the response contains the last page of results."
          }
        }
      },
      "plansListPlanSchedulesResponse": {
        "type": "object",
        "properties": {
          "plan_schedules": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/plansPlanSchedule"
            },
            "description": "A list of matching plan schedules, ordered by ascending `create_timestamp`. Note: Plan Schedule is a resource that represents an Event Type of the current Supervisor Contract. It references a Schedule that is related to a particular Event Type of the current Supervisor Contract, which is not disabled."
          },
          "previous_page_token": {
            "type": "string",
            "description": "The pagination token used to retrieve the previous page. If empty, this is the first page of results."
          },
          "next_page_token": {
            "type": "string",
            "description": "The pagination token used to retrieve the next page. If empty, this is the last page of results."
          }
        }
      },
      "plansListPlanUpdatesResponse": {
        "type": "object",
        "properties": {
          "plan_updates": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/plansPlanUpdate"
            },
            "description": "A list of matching plans, ordered by ascending `create_timestamp`."
          },
          "previous_page_token": {
            "type": "string",
            "description": "The pagination token used to retrieve the previous page. If empty, this is the first page of results."
          },
          "next_page_token": {
            "type": "string",
            "description": "The pagination token used to retrieve the next page. If empty, this is the last page of results."
          }
        }
      },
      "plansPlanMigration": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for this plan migration. Optional."
          },
          "status": {
            "$ref": "#/components/schemas/plansPlanMigrationStatus",
            "description": "Status of the PlanMigration."
          },
          "create_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The timestamp of when this plan migration was created."
          },
          "last_status_update_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The timestamp of when the last update happened."
          },
          "supervisor_contract_version_migration": {
            "$ref": "#/components/schemas/plansSupervisorContractVersionMigration",
            "required": true
          }
        }
      },
      "plansPlanMigrationStatus": {
        "type": "string",
        "enum": [
          "PLAN_MIGRATION_STATUS_UNKNOWN",
          "PLAN_MIGRATION_STATUS_PENDING_EXECUTION",
          "PLAN_MIGRATION_STATUS_COMPLETED"
        ],
        "default": "PLAN_MIGRATION_STATUS_UNKNOWN",
        "title": "Status of the plan migration",
        "x-enum-value-descriptions": {
          "PLAN_MIGRATION_STATUS_COMPLETED": "Indicates the plan migration completed.",
          "PLAN_MIGRATION_STATUS_PENDING_EXECUTION": "The plan migration is in progress.",
          "PLAN_MIGRATION_STATUS_UNKNOWN": "Default value."
        }
      },
      "plansPlanSchedule": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The ID of the plan schedule."
          },
          "plan_id": {
            "type": "string",
            "description": "The plan ID associated with the plan schedule."
          },
          "name": {
            "type": "string",
            "description": "The name of the plan schedule."
          },
          "group_name": {
            "type": "string",
            "description": "The name of the group associated with the plan schedule."
          },
          "time_expression": {
            "type": "string",
            "description": "The time expression that defines when Jobs will be run. This could be a CRON expression or a single timestamp."
          },
          "schedule_tag_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The schedule tag IDs for a given plan schedule."
          }
        }
      },
      "plansPlanUpdate": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "A unique ID for a plan. Optional for create requests.\n\nMax length: 36 characters."
          },
          "plan_id": {
            "type": "string",
            "description": "The ID of the plan. Required for create requests."
          },
          "job_id": {
            "type": "string",
            "description": "The job ID the plan update belongs to.",
            "x-release-info": {
              "releaseVersion": {
                "major": 2,
                "minor": 3
              },
              "changeType": "ADD_FIELD"
            }
          },
          "status": {
            "$ref": "#/components/schemas/plansPlanUpdateStatus",
            "description": "The status of the plan update. Optional for create requests."
          },
          "create_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The timestamp indicating when this plan update was created."
          },
          "last_status_update_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The timestamp indicating when the status was last updated."
          },
          "failure_reason": {
            "type": "string",
            "description": "The reason a plan update was not completed successfully. This will only be populated if the plan update status is either `PLAN_UPDATE_STATUS_REJECTED` or `PLAN_UPDATE_STATUS_ERRORED`."
          },
          "associate_account_update": {
            "$ref": "#/components/schemas/plansAssociateAccountUpdate",
            "required": false
          },
          "disassociate_account_update": {
            "$ref": "#/components/schemas/plansDisassociateAccountUpdate",
            "required": false
          },
          "activation_update": {
            "$ref": "#/components/schemas/plansActivationUpdate",
            "required": false
          },
          "supervisor_contract_version_update": {
            "$ref": "#/components/schemas/plansSupervisorContractVersionUpdate",
            "required": false
          },
          "closure_update": {
            "$ref": "#/components/schemas/plansClosureUpdate",
            "required": false
          }
        }
      },
      "plansPlanUpdateStatus": {
        "type": "string",
        "enum": [
          "PLAN_UPDATE_STATUS_UNKNOWN",
          "PLAN_UPDATE_STATUS_PENDING_EXECUTION",
          "PLAN_UPDATE_STATUS_COMPLETED",
          "PLAN_UPDATE_STATUS_REJECTED",
          "PLAN_UPDATE_STATUS_ERRORED"
        ],
        "default": "PLAN_UPDATE_STATUS_UNKNOWN",
        "description": "Status of the plan update.",
        "x-enum-value-descriptions": {
          "PLAN_UPDATE_STATUS_COMPLETED": "The plan update was successfully executed.",
          "PLAN_UPDATE_STATUS_ERRORED": "The plan update errored.",
          "PLAN_UPDATE_STATUS_PENDING_EXECUTION": "The plan update has not been picked up from the queue yet, or is in progress.",
          "PLAN_UPDATE_STATUS_REJECTED": "The plan update failed validation and has been rejected.",
          "PLAN_UPDATE_STATUS_UNKNOWN": "Default value."
        }
      },
      "plansScheduleMigrationType": {
        "type": "string",
        "enum": [
          "SCHEDULE_MIGRATION_TYPE_RECREATE_ALL_SCHEDULES_AND_GROUPS",
          "SCHEDULE_MIGRATION_TYPE_PRESERVE_SCHEDULES_IF_NO_GROUP_CHANGES"
        ],
        "default": "SCHEDULE_MIGRATION_TYPE_RECREATE_ALL_SCHEDULES_AND_GROUPS",
        "x-enum-value-descriptions": {
          "SCHEDULE_MIGRATION_TYPE_PRESERVE_SCHEDULES_IF_NO_GROUP_CHANGES": "When updating the Supervisor Contract version of a plan, existing schedules are preserved if either: * They are not part of a group and a schedule of the same event type is defined in the new Supervisor Contract code; or * They are part of a group and a group of the same name, size and order is defined in the new Supervisor Contract code. New schedules are only created if they are defined in the new Supervisor Contract code.",
          "SCHEDULE_MIGRATION_TYPE_RECREATE_ALL_SCHEDULES_AND_GROUPS": "When updating the Supervisor Contract version of a plan, all existing schedules will be deleted then recreated according to the Supervisor Contract code of the new product version. Any updates previously made to existing schedules will not be preserved. This is the default behaviour."
        }
      },
      "plansSupervisorContractVersionMigration": {
        "type": "object",
        "properties": {
          "from_supervisor_contract_version_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The Supervisor Contract version IDs to migrate plans from.\n\nRequired.\nMin count: 1."
          },
          "to_supervisor_contract_version_id": {
            "type": "string",
            "description": "The Supervisor Contract version ID to migrate the plans to.\n\nRequired."
          },
          "schedule_migration_type": {
            "$ref": "#/components/schemas/plansScheduleMigrationType",
            "description": "Specifies how existing schedules should be migrated.",
            "x-release-info": {
              "noticeVersion": {
                "major": 4,
                "minor": 6
              },
              "releaseVersion": {
                "major": 6
              },
              "changeType": "REMOVE_FIELD",
              "description": "This field is not used on updates to Contracts Language API version 4 and will be removed alongside Contracts Language API version 3."
            }
          }
        },
        "required": [
          "from_supervisor_contract_version_ids",
          "to_supervisor_contract_version_id"
        ]
      },
      "plansSupervisorContractVersionUpdate": {
        "type": "object",
        "properties": {
          "supervisor_contract_version_id": {
            "type": "string",
            "description": "The ID of the Supervisor Contract version to update the plan to.",
            "x-release-info": {
              "releaseVersion": {
                "major": 1,
                "minor": 13
              },
              "changeType": "ADD_FIELD",
              "featureFlag": "KERN_289_SUPERVISOR_CONTRACT_UPDATE"
            }
          },
          "schedule_migration_type": {
            "$ref": "#/components/schemas/plansScheduleMigrationType",
            "title": "Specifies how existing schedules should be migrated. Note, this field has no effect on migrations to a supervisor contract version on Smart Contract API Version 4.X.X. [See Plan migrations.](/reference/plans/#plan_migrations)",
            "x-release-info": {
              "noticeVersion": {
                "major": 4,
                "minor": 6
              },
              "releaseVersion": {
                "major": 6
              },
              "changeType": "REMOVE_FIELD",
              "description": "This field is not used on updates to Contracts Language API version 4 and will be removed alongside Contracts Language API version 3."
            }
          }
        }
      },
      "BatchGetPoliciesNOT_FOUND_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "NOT_FOUND"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsResourceInfo",
                  "title": "ResourceInfo"
                }
              ]
            }
          }
        }
      },
      "CoreAPIPolicyManagementINVALID_ARGUMENT_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "INVALID_ARGUMENT"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsBadRequest",
                  "title": "BadRequest"
                }
              ]
            }
          }
        }
      },
      "GetPolicyNOT_FOUND_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "NOT_FOUND"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsResourceInfo",
                  "title": "ResourceInfo"
                }
              ]
            }
          }
        }
      },
      "UpdatePolicyNOT_FOUND_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "NOT_FOUND"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsResourceInfo",
                  "title": "ResourceInfo"
                }
              ]
            }
          }
        }
      },
      "policy_managementBatchGetPoliciesRequestIncludeField": {
        "type": "string",
        "enum": [
          "INCLUDE_FIELD_REGO_SOURCE"
        ],
        "default": "INCLUDE_FIELD_REGO_SOURCE",
        "x-enum-value-descriptions": {
          "INCLUDE_FIELD_REGO_SOURCE": "Includes the rego_source field."
        }
      },
      "policy_managementBatchGetPoliciesResponse": {
        "type": "object",
        "properties": {
          "policies": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/policy_managementPolicy"
            },
            "description": "A map of the Policy ID to their respective Policy."
          }
        }
      },
      "policy_managementCreatePolicyRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A string UUID used to ensure the request is idempotent. Required.\nThis field must contain a valid UUID in the canonical 8-4-4-4-12 form.\nRequired."
          },
          "policy": {
            "$ref": "#/components/schemas/policy_managementPolicy",
            "description": "The Policy that is to be created. Required.\n\nRequired.",
            "x-excluded-fields": [
              "version",
              "create_timestamp",
              "update_timestamp"
            ]
          }
        },
        "required": [
          "request_id",
          "policy"
        ]
      },
      "policy_managementListPoliciesRequestIncludeField": {
        "type": "string",
        "enum": [
          "INCLUDE_FIELD_REGO_SOURCE"
        ],
        "default": "INCLUDE_FIELD_REGO_SOURCE",
        "x-enum-value-descriptions": {
          "INCLUDE_FIELD_REGO_SOURCE": "Includes the rego_source field."
        }
      },
      "policy_managementListPoliciesResponse": {
        "type": "object",
        "properties": {
          "policies": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/policy_managementPolicy"
            },
            "description": "A list of matching Policies, ordered alphabetically by Policy ID."
          },
          "previous_page_token": {
            "type": "string",
            "description": "The token used to retrieve the previous page. If empty, this is the first page of results."
          },
          "next_page_token": {
            "type": "string",
            "description": "The token used to retrieve the next page. If empty, this is the last page of results."
          }
        }
      },
      "policy_managementPolicy": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The unique identifier for the Policy. Required.\n\nRequired."
          },
          "version": {
            "type": "string",
            "format": "uint64",
            "description": "The Policy version number.",
            "x-release-info": {
              "noticeVersion": {
                "major": 4,
                "minor": 5
              },
              "releaseVersion": {
                "major": 6
              },
              "changeType": "REMOVE_FIELD",
              "description": "Remove internal policy version number from public API."
            }
          },
          "policy_schema_id": {
            "type": "string",
            "description": "The ID of the policy schema this Policy is associated with."
          },
          "description": {
            "type": "string",
            "description": "The human-readable description of the Policy.\n\nMax length: 256 characters."
          },
          "rego_source": {
            "type": "string",
            "description": "The rego policy definition. Rego Package name must be equal to the Policy ID.\n\nMax length: 2048 characters."
          },
          "create_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The timestamp indicating when the Policy was created."
          },
          "update_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The timestamp indicating when the last change to the Policy occurred."
          }
        },
        "required": [
          "id"
        ]
      },
      "policy_managementUpdatePolicyRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A string UUID used to ensure the request is idempotent. Required.\nThis field must contain a valid UUID in the canonical 8-4-4-4-12 form.\nRequired."
          },
          "policy": {
            "$ref": "#/components/schemas/policy_managementPolicy",
            "description": "The Policy that is to be updated. Required.\n\nRequired.",
            "x-excluded-fields": [
              "id",
              "version",
              "policy_schema_id",
              "create_timestamp",
              "update_timestamp"
            ]
          },
          "update_mask": {
            "$ref": "#/components/schemas/protobufFieldMask",
            "description": "\n\nRequired.",
            "title": "The field mask used to indicate which fields in the resource are to be updated. Required. The allowed fields are: `description`, `rego_source`,"
          }
        },
        "required": [
          "request_id",
          "policy",
          "update_mask"
        ]
      },
      "BatchGetPostPostingFailuresNOT_FOUND_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "NOT_FOUND"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsResourceInfo",
                  "title": "ResourceInfo"
                }
              ]
            }
          }
        }
      },
      "CoreAPIPostPostingRepublisherINVALID_ARGUMENT_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "INVALID_ARGUMENT"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsBadRequest",
                  "title": "BadRequest"
                }
              ]
            }
          }
        }
      },
      "DeletePostPostingFailureFAILED_PRECONDITION_0": {
        "type": "object",
        "properties": {
          "message": {
            "type": "string",
            "description": "An error message provided by the endpoint."
          },
          "code": {
            "type": "string",
            "description": "The Vault code of the error.",
            "x-example-override": "FAILED_PRECONDITION"
          },
          "tracing_id": {
            "type": "string",
            "description": "Tracing ID used to identify a response's origin.",
            "x-example-override": "699cc484-49b0-40c5-a26e-a857dab67e65"
          },
          "vault_error_code": {
            "type": "string",
            "description": "This field is deprecated and will no longer be returned from version 5.0.0. Use the new `code` and `details` fields instead.",
            "x-example-override": "XXX.YYY.ZZZ"
          },
          "details": {
            "type": "array",
            "items": {
              "anyOf": [
                {
                  "$ref": "#/components/schemas/errorsPreconditionFailureDeletePostPostingFailureFAILED_PRECONDITION_0",
                  "title": "PreconditionFailure"
                }
              ]
            }
          }
        }
      },
      "PreconditionFailureViolationDeletePostPostingFailureFAILED_PRECONDITION_0": {
        "type": "object",
        "properties": {
          "violation_type": {
            "type": "string",
            "title": "A set of canonical violation types that can be used by API client to programmatically handle the error. A resource or API specific enum type must be defined for the supported precondition violation subjects. e.g. enum DirectDebitPreconditionFailureTypes {     UNKNOWN               = 0; // string representation: \"UNKNOWN\"     BANK_ACCOUNT_DISABLED = 1; // string representation: \"BANK_ACCOUNT_DISABLED\"     MANDATE_INACTIVE      = 2; // string representation: \"MANDATE_INACTIVE\" }",
            "x-example-override": "INVALID_ACCOUNT_ID"
          },
          "metadata": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "Additional structured details about this error.\n\nKeys should match /[a-zA-Z0-9-_]/ and be limited to 64 characters in length. When identifying the current value of an exceeded limit, the units should be contained in the key, not the value. For example, rather than {\"instance_limit\": \"100/request\"}, should be returned as, {\"instance_limit_per_request\": \"100\"}, if the client exceeds the number of instances that can be created in a single (batch) request.",
            "x-example-override": "{}"
          }
        },
        "description": "A message type used to describe a single precondition failure."
      },
      "errorsPreconditionFailureDeletePostPostingFailureFAILED_PRECONDITION_0": {
        "type": "object",
        "properties": {
          "@type": {
            "type": "string",
            "description": "A type name to identify this detail.",
            "x-example-override": "http://type.googleapis.com/errors.PreconditionFailure"
          },
          "violations": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/PreconditionFailureViolationDeletePostPostingFailureFAILED_PRECONDITION_0"
            },
            "description": "Describes all precondition violations."
          }
        },
        "description": "Describes what preconditions have failed.\n\nFor example, if creating a direct debit failed because bank account validation failed, it could list the account violation in the PreconditionFailure message."
      },
      "post_posting_republisherBatchGetPostPostingFailuresResponse": {
        "type": "object",
        "properties": {
          "post_posting_failures": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/post_posting_republisherPostPostingFailure"
            },
            "description": "A map of Post Posting Failure ID to Post Posting Failures."
          }
        }
      },
      "post_posting_republisherDeletePostPostingFailureResponse": {
        "type": "object"
      },
      "post_posting_republisherListPostPostingFailuresResponse": {
        "type": "object",
        "properties": {
          "post_posting_failures": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/post_posting_republisherPostPostingFailure"
            },
            "description": "A list of matching Post Posting Failures, ordered by Update Count."
          },
          "previous_page_token": {
            "type": "string",
            "description": "The pagination token used to retrieve the previous page. If empty, this is the first page of results."
          },
          "next_page_token": {
            "type": "string",
            "description": "The pagination token used to retrieve the next page. If empty, this is the last page of results."
          }
        }
      },
      "post_posting_republisherPostPostingFailure": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "A unique, service-generated UUID."
          },
          "account_id": {
            "type": "string",
            "description": "The ID of the account which had this Post Posting Failure."
          },
          "posting_instruction_batch_id": {
            "type": "string",
            "description": "The ID of the Posting Instruction Batch that triggered the post_posting_code execution that failed."
          },
          "attempt_number": {
            "type": "integer",
            "format": "int32",
            "description": "A counter describing the number of times the Post Posting Failure has been republished by the user. It starts at 0."
          },
          "status": {
            "$ref": "#/components/schemas/post_posting_republisherPostPostingFailureStatus",
            "description": "Gives the status of the Post Posting Failure."
          },
          "failure_reason": {
            "type": "string",
            "description": "Contains the reason as to why the Post Posting Failure occurred."
          },
          "insertion_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The timestamp when the Post Posting Failure was inserted into the database."
          }
        }
      },
      "post_posting_republisherPostPostingFailureStatus": {
        "type": "string",
        "enum": [
          "POST_POSTING_FAILURE_STATUS_UNKNOWN",
          "POST_POSTING_FAILURE_STATUS_FAILURE",
          "POST_POSTING_FAILURE_STATUS_BUFFERED",
          "POST_POSTING_FAILURE_STATUS_PUBLISHED"
        ],
        "default": "POST_POSTING_FAILURE_STATUS_UNKNOWN",
        "x-enum-value-descriptions": {
          "POST_POSTING_FAILURE_STATUS_BUFFERED": "Indicates this is a Post Posting Failure that has never been attempted because it was blocked by a previous failure.",
          "POST_POSTING_FAILURE_STATUS_FAILURE": "Indicates the Post Posting Failure was created after a `post_posting_code` execution was attempted and failed.",
          "POST_POSTING_FAILURE_STATUS_PUBLISHED": "Indicates this is a republished Post Posting event and is currently being processed asynchronously.",
          "POST_POSTING_FAILURE_STATUS_UNKNOWN": "Default value."
        }
      },
      "post_posting_republisherRepublishPostPostingFailureRequest": {
        "type": "object",
        "properties": {
          "account_id": {
            "type": "string",
            "description": "The Account ID to be republished.\n\nRequired."
          },
          "republish_type": {
            "$ref": "#/components/schemas/post_posting_republisherRepublishType",
            "description": "Chosen Republish Type. Defaults to `REPUBLISH_TYPE_REPUBLISH_SINGLE_FAILURE`."
          }
        },
        "required": [
          "account_id"
        ]
      },
      "post_posting_republisherRepublishType": {
        "type": "string",
        "enum": [
          "REPUBLISH_TYPE_REPUBLISH_UNKNOWN",
          "REPUBLISH_TYPE_REPUBLISH_SINGLE_FAILURE",
          "REPUBLISH_TYPE_REPUBLISH_BLOCKED_FAILURES"
        ],
        "default": "REPUBLISH_TYPE_REPUBLISH_UNKNOWN",
        "x-enum-value-descriptions": {
          "REPUBLISH_TYPE_REPUBLISH_BLOCKED_FAILURES": "Republishes all Post Posting Failures in chronological order.",
          "REPUBLISH_TYPE_REPUBLISH_SINGLE_FAILURE": "Republishes the earliest Post Posting Failure that exists for the account.",
          "REPUBLISH_TYPE_REPUBLISH_UNKNOWN": "Unknown Republish type."
        }
      },
      "async_operationsAsyncOperation": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The ID that can be used to retrieve this operation."
          },
          "metadata": {
            "$ref": "#/components/schemas/protobufAny",
            "description": "Metadata of the operation.",
            "x-third-party": "GOOGLE_PROTOBUF_ANY"
          },
          "create_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "When this operation was created.",
            "x-third-party": "GOOGLE_PROTOBUF_TIMESTAMP"
          },
          "done_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "When this operation was completed.",
            "x-third-party": "GOOGLE_PROTOBUF_TIMESTAMP"
          },
          "done": {
            "type": "boolean",
            "description": "Whether the operation is completed or not."
          },
          "response": {
            "$ref": "#/components/schemas/protobufAny",
            "required": false
          },
          "error": {
            "$ref": "#/components/schemas/rpcStatus",
            "required": false
          }
        },
        "description": "Represents a long-running or asynchronous operation in a service. It contains the status of this operation and, upon successful completion, the resource that was created or mutated as part of this operation."
      },
      "async_operationsBatchGetAsyncOperationsResponse": {
        "type": "object",
        "properties": {
          "async_operations": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/async_operationsAsyncOperation"
            },
            "description": "Map of ID to the Async Operation with that ID."
          }
        },
        "description": "BatchGetAsyncOperationsResponse is a response containing multiple Async Operation resources."
      },
      "orderingOrderByDirection": {
        "type": "string",
        "enum": [
          "ORDER_BY_DESC",
          "ORDER_BY_ASC"
        ],
        "default": "ORDER_BY_DESC",
        "description": "The OrderByDirection controls how the results are ordered. This enum is deprecated. Ordering should now be implemented using a repeated enum of field names. See change https://phabricator.iap.tmachine.io/D39490 for details."
      },
      "posting_instruction_batchesBatchGetPostingInstructionBatchesResponse": {
        "type": "object",
        "properties": {
          "posting_instruction_batches": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/v1PostingInstructionBatch"
            },
            "description": "A map of posting instruction batch ID to posting instruction batches."
          }
        }
      },
      "posting_instruction_batchesListPostingInstructionBatchesResponse": {
        "type": "object",
        "properties": {
          "posting_instruction_batches": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/v1PostingInstructionBatch"
            },
            "description": "A list of posting instruction batches that match the applied filters. The results are ordered by `value_timestamp` which defaults to descending, unless otherwise specified with `order_by_direction`."
          },
          "previous_page_token": {
            "type": "string",
            "description": "The pagination token to retrieve the previous page of results. If empty, this is the first page of results."
          },
          "next_page_token": {
            "type": "string",
            "description": "The pagination token to retrieve the next page of results. If empty, this is the last page of results."
          }
        }
      },
      "posting_instruction_batchesPostingsAPIType": {
        "type": "string",
        "enum": [
          "POSTINGS_API_TYPE_HIGH_PRIORITY",
          "POSTINGS_API_TYPE_LOW_PRIORITY"
        ],
        "default": "POSTINGS_API_TYPE_HIGH_PRIORITY",
        "description": "* PostingsAPIType defines which Postings API type to use.",
        "x-enum-value-descriptions": {
          "POSTINGS_API_TYPE_HIGH_PRIORITY": "Default value. Indicates that the request will be submitted to the high-priority Postings API.",
          "POSTINGS_API_TYPE_LOW_PRIORITY": "Indicates that the request will be submitted to the low-priority Postings API."
        }
      },
      "posting_instruction_batchesValidateCreatePostingInstructionBatchRequestRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique ID generated by the client (payment processor) that is used for idempotency. The client must ensure a unique `request_id` is passed within their namespace (determined by `client_id`). Multiple requests with the same <`client_id` - `request_id`> will receive the same response. Required.",
            "x-example-override": "9ea7fb24-634b-4e78-9d53-3556ec7b271a"
          },
          "posting_instruction_batch": {
            "$ref": "#/components/schemas/v1PostingInstructionBatch",
            "description": "A posting instruction batch object. Required.",
            "x-example-override": "{\"client_id\": \"ExamplePaymentProcessorClientID\", \"client_batch_id\": \"478ff244-9870-4452-cde1-40b27c644a39\", \"posting_instructions\": [{\"client_transaction_id\": \"tx_5ba67013-c060-422f\", \"outbound_authorisation\": {\"amount\": \"10.50\", \"denomination\": \"GBP\", \"target_account\": {\"account_id\": \"2cb63354-e431-135b-eda5-69db11421f84\"}, \"internal_account_id\": \"25\", \"advice\": false}, \"instruction_details\": {\"scheme_name\": \"domestic_payment_scheme\", \"settlement_date\": \"12-01-2020\", \"category\": \"personal\"}}], \"batch_details\": {\"tx_id\": \"tx_46624c03-71e7-4ef1-8fb9-cdb617c72e50\"}}"
          }
        },
        "description": "* ValidateCreatePostingInstructionBatchRequestRequest is used to validate if the request messages for CreatePostingInstructionBatch and CreatePostingInstructionBatchAsync are correct."
      },
      "posting_instruction_batchesValidateCreatePostingInstructionBatchRequestResponse": {
        "type": "object",
        "properties": {
          "is_valid": {
            "type": "boolean",
            "description": "Indicates whether the syntax of the `create-posting-instruction-batch` request is valid."
          },
          "failure_reason": {
            "type": "string",
            "description": "A string that communicates the reason why the `create-posting-instruction-batch` request failed validation. Optional.",
            "x-example-override": ""
          }
        }
      },
      "protobufAny": {
        "type": "object",
        "properties": {
          "type_url": {
            "type": "string",
            "description": "A URL/resource name that uniquely identifies the type of the serialized protocol buffer message. This string must contain at least one \"/\" character. The last segment of the URL's path must represent the fully qualified name of the type (as in `path/google.protobuf.Duration`). The name should be in a canonical form (e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they expect it to use in the context of Any. However, for URLs which use the scheme `http`, `https`, or no scheme, one can optionally set up a type server that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed. * An HTTP GET on the URL must yield a [google.protobuf.Type][]   value in binary format, or produce an error. * Applications are allowed to cache lookup results based on the   URL, or have them precompiled into a binary to avoid any   lookup. Therefore, binary compatibility needs to be preserved   on changes to types. (Use versioned type names to manage   breaking changes.)\n\nNote: this functionality is not currently available in the official protobuf release, and it is not used for type URLs beginning with type.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be used with implementation specific semantics."
          },
          "value": {
            "type": "string",
            "format": "byte",
            "description": "Must be a valid serialized protocol buffer of the above specified type."
          }
        },
        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a URL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form of utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;     Any any;     any.PackFrom(foo);     ...     if (any.UnpackTo(&foo)) {       ...     }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;     Any any = Any.pack(foo);     ...     if (any.is(Foo.class)) {       foo = any.unpack(Foo.class);     }\n\n Example 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)     any = Any()     any.Pack(foo)     ...     if any.Is(Foo.DESCRIPTOR):       any.Unpack(foo)       ...\n\n Example 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}      any, err := anypb.New(foo)      if err != nil {        ...      }      ...      foo := &pb.Foo{}      if err := any.UnmarshalTo(foo); err != nil {        ...      }\n\nThe pack methods provided by protobuf library will by default use 'type.googleapis.com/full.type.name' as the type URL and the unpack methods only use the fully qualified type name after the last '/' in the type URL, for example \"foo.bar.com/x/y.z\" will yield type name \"y.z\".\n\n\nJSON ==== The JSON representation of an `Any` value uses the regular representation of the deserialized, embedded message, with an additional field `@type` which contains the type URL. Example:\n\n    package google.profile;     message Person {       string first_name = 1;       string last_name = 2;     }\n\n    {       \"@type\": \"type.googleapis.com/google.profile.Person\",       \"firstName\": <string>,       \"lastName\": <string>     }\n\nIf the embedded message type is well-known and has a custom JSON representation, that representation will be embedded adding a field `value` which holds the custom JSON in addition to the `@type` field. Example (for message [google.protobuf.Duration][]):\n\n    {       \"@type\": \"type.googleapis.com/google.protobuf.Duration\",       \"value\": \"1.212s\"     }"
      },
      "rpcStatus": {
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "format": "int32",
            "description": "The status code, which should be an enum value of [google.rpc.Code][google.rpc.Code]."
          },
          "message": {
            "type": "string",
            "description": "A developer-facing error message, which should be in English. Any user-facing error message should be localized and sent in the [thoughtmachine.rpc.Status.details][thoughtmachine.rpc.Status.details] field, or localized by the client."
          },
          "details": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/protobufAny"
            },
            "description": "A list of messages that carry the error details.  There will be a common set of message types for APIs to use."
          }
        },
        "description": "- Simple to use and understand for most users - Flexible enough to meet unexpected needs\n\n# Overview\n\nThe `Status` message contains three pieces of data: error code, error message, and error details. The error code should be an enum value of [google.rpc.Code][google.rpc.Code], but it may accept additional error codes if needed.  The error message should be a developer-facing English message that helps developers *understand* and *resolve* the error. If a localized user-facing error message is needed, put the localized message in the error details or localize it in the client. The optional error details may contain arbitrary information about the error. There is a predefined set of error detail types in the package `google.rpc` which can be used for common error conditions.\n\n# Language mapping\n\nThe `Status` message is the logical representation of the error model, but it is not necessarily the actual wire format. When the `Status` message is exposed in different client libraries and different wire protocols, it can be mapped differently. For example, it will likely be mapped to some exceptions in Java, but more likely mapped to some error codes in C.\n\n# Other uses\n\nThe error model and the `Status` message can be used in a variety of environments, either with or without APIs, to provide a consistent developer experience across different environments.\n\nExample uses of this error model include:\n\n- Partial errors. If a service needs to return partial errors to the client,     it may embed the `Status` in the normal response to indicate the partial     errors.\n\n- Workflow errors. A typical workflow has multiple steps. Each step may     have a `Status` message for error reporting purpose.\n\n- Batch operations. If a client uses batch request and batch response, the     `Status` message should be used directly inside batch response, one for     each error sub-response.\n\n- Asynchronous operations. If an API call embeds asynchronous operation     results in its response, the status of those operations should be     represented directly using the `Status` message.\n\n- Logging. If some API errors are stored in logs, the message `Status` could     be used directly after any stripping needed for security/privacy reasons.",
        "title": "The `Status` type defines a logical error model that is suitable for different programming environments, including REST APIs and RPC APIs. It is used by [gRPC](https://github.com/grpc). The error model is designed to be:"
      },
      "v1OverrideRestrictions": {
        "type": "object",
        "properties": {
          "all": {
            "type": "boolean",
            "description": "The caller may choose to override all account restriction checks for a posting instruction by setting this field to true."
          },
          "restriction_set_ids": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The caller may choose to override certain account restrictions by passing its restriction set ID here."
          }
        },
        "description": "OverrideRestrictions allows a caller to skip all or some restrictions from impacting a PostingInstruction. Caller may not set more than one field. As such, either the `all`, or the `restriction_set_ids` field may be set.\n\nNote that the restrictions specified here will be overridden for each account targeted by this PostingInstruction."
      },
      "v1posting_instruction_batchesCreatePostingInstructionBatchRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique ID generated by the client (the payment processor) used for idempotency. The client must ensure a unique `request_id` is passed within their namespace (determined by `client_id`). Multiple requests with the same <`client_id` - `request_id`> will receive the same response. Required.",
            "x-example-override": "9ea7fb24-634b-4e78-9d53-3556ec7b271a"
          },
          "posting_instruction_batch": {
            "$ref": "#/components/schemas/v1PostingInstructionBatch",
            "description": "A posting instruction batch object. Required.",
            "x-example-override": "{\"client_id\": \"ExamplePaymentProcessorClientID\", \"client_batch_id\": \"478ff244-9870-4452-cde1-40b27c644a39\", \"posting_instructions\": [{\"client_transaction_id\": \"tx_5ba67013-c060-422f\", \"outbound_authorisation\": {\"amount\": \"10.50\", \"denomination\": \"GBP\", \"target_account\": {\"account_id\": \"2cb63354-e431-135b-eda5-69db11421f84\"}, \"internal_account_id\": \"25\", \"advice\": false}, \"instruction_details\": {\"scheme_name\": \"domestic_payment_scheme\", \"settlement_date\": \"12-01-2020\", \"category\": \"personal\"}}], \"batch_details\": {\"tx_id\": \"tx_46624c03-71e7-4ef1-8fb9-cdb617c72e50\"}}"
          },
          "api_type": {
            "$ref": "#/components/schemas/posting_instruction_batchesPostingsAPIType",
            "description": "This defines which type of Postings API to use. Optional.",
            "x-release-info": {
              "releaseVersion": {
                "major": 2,
                "minor": 7
              },
              "changeType": "ADD_FIELD",
              "featureFlag": "TMV_543_LOW_PRIORITY_CREATE_PIB_ASYNC"
            }
          }
        },
        "description": "* CreatePostingInstructionBatchRequest defines request for the Vault Postings API. For each PostingInstructionBatchRequest published in the request topic, a PostingInstructionBatch will be published in the response topic (or DLQ if the request is badly-formed).\n\nThe Postings API is idempotent to duplicate PostingInstructionBatchRequest and will respond idempotently to PostingInstructionBatchRequest messages with the same <client_id-request_id>."
      },
      "postings_api_clientsBatchGetPostingsAPIClientsResponse": {
        "type": "object",
        "properties": {
          "postings_api_clients": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/postings_api_clientsPostingsAPIClient"
            },
            "description": "A list of `PostingsAPIClient`s."
          }
        }
      },
      "postings_api_clientsCreatePostingsAPIClientRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique ID generated for idempotency. Required.",
            "x-example-override": "35433eb8-6afa-42bf-b7b3-b23504d3e325"
          },
          "postings_api_client": {
            "$ref": "#/components/schemas/postings_api_clientsPostingsAPIClient",
            "description": "A `PostingsAPIClient` object. Required.",
            "x-example-override": "{\"id\": \"ExamplePaymentProcessorClientID\", \"response_topic\": \"integration.postings_api.domestic_payment_processor_id.response\"}"
          }
        },
        "description": "Creates a `PostingsAPIClient`."
      },
      "postings_api_clientsListPostingsAPIClientsResponse": {
        "type": "object",
        "properties": {
          "postings_api_clients": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/postings_api_clientsPostingsAPIClient"
            },
            "description": "A list of `PostingsAPIClient` objects.",
            "x-example-override": "[{\"id\": \"ExamplePaymentProcessorClientID1\", \"response_topic\": \"integration.postings_api.domestic_payment_processor_id.response\"}, {\"id\": \"ExamplePaymentProcessorClientID2\", \"response_topic\": \"integration.postings_api.domestic_payment_processor_id.response\"}]"
          },
          "previous_page_token": {
            "type": "string",
            "description": "The pagination token used to retrieve the previous page. If empty, this returns the first page of results."
          },
          "next_page_token": {
            "type": "string",
            "description": "The pagination token used to retrieve the next page. If empty, this returns the last page of results."
          }
        },
        "description": "Returns a list of `PostingsAPIClient`s."
      },
      "postings_api_clientsPostingsAPIClient": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "A unique ID that identifies a `PostingsAPIClient` to the Postings API.",
            "x-example-override": "ExamplePaymentProcessorClientID"
          },
          "response_topic": {
            "type": "string",
            "description": "The Kafka topic that the Postings API should respond to for this `PostingsAPIClient`. NOTES: - Multiple `PostingsAPIClient`s may share a response topic. - Must contain the prefix 'integration.'. For compatibility, existing topics that are not prefixed with 'integration.' are allowed.",
            "x-example-override": "integration.postings_api.domestic_payment_processor_id.response"
          },
          "response_topic_low_priority": {
            "type": "string",
            "description": "The low priority Kafka topic that the Postings API should respond to for this `PostingsAPIClient`. NOTES: - Multiple `PostingsAPIClient`s may share a response topic. - Must contain the prefix 'integration.'. For compatibility, existing topics that are not prefixed with 'integration.' are allowed.",
            "x-release-info": {
              "releaseVersion": {
                "major": 1,
                "minor": 9
              },
              "changeType": "ADD_FIELD"
            },
            "x-example-override": "integration.postings_api.domestic_payment_processor_id.low_priority.response"
          }
        },
        "description": "Configuration of a `PostingsAPIClient` that maps a unique `id` to their (non-unique) response topic."
      },
      "postings_api_clientsUpdatePostingsAPIClientRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique ID generated for idempotency. Required.",
            "x-example-override": "4c82213e-11ff-4358-980b-714a10dcfb76"
          },
          "postings_api_client": {
            "$ref": "#/components/schemas/postings_api_clientsPostingsAPIClient",
            "description": "A `PostingsAPIClient` object. Required.",
            "x-example-override": "{\"id\": \"ExamplePaymentProcessorClientID\", \"response_topic\": \"integration.postings_api.domestic_payment_processor_id.response\", \"response_topic_low_priority\": \"integration.postings_api.domestic_payment_processor_id.low_priority.response\"}",
            "x-excluded-fields": [
              "response_topic"
            ]
          },
          "update_mask": {
            "$ref": "#/components/schemas/protobufFieldMask",
            "description": "The field mask used to indicate which fields in the resource are to be updated. The only allowed field is `response_topic_low_priority`, which must differ from `response_topic`. NOTE: Once the low priority response topic is set, it can be changed but it cannot be unset. Required.",
            "x-example-override": "{\"paths\": [\"response_topic_low_priority\"]}"
          }
        },
        "description": "Updates a `PostingsAPIClient`. Currently, only a single path for the update mask is supported, i.e. `response_topic_low_priority`. Clients managing their postings API clients outside of the Configuration Layer Utility should use this endpoint to add a `low_priority_response_topic` if they want to start using the low priority functionality. Care must be used when using the endpoint. If a `response_topic_low_priority` was already defined for a `PostingsAPIClient`, changing it will require planning a migration from the old topic to the new."
      },
      "ListProductsRequestInternalityRefiner": {
        "type": "string",
        "enum": [
          "INTERNALITY_REFINER_ANY_INTERNALITY",
          "INTERNALITY_REFINER_INTERNAL",
          "INTERNALITY_REFINER_EXTERNAL"
        ],
        "default": "INTERNALITY_REFINER_ANY_INTERNALITY",
        "x-enum-value-descriptions": {
          "INTERNALITY_REFINER_ANY_INTERNALITY": "Default. Lists both internal and external products.",
          "INTERNALITY_REFINER_EXTERNAL": "Lists external products only.",
          "INTERNALITY_REFINER_INTERNAL": "Lists internal products only."
        }
      },
      "paramsAccountField": {
        "type": "object"
      },
      "paramsLevel": {
        "type": "string",
        "enum": [
          "LEVEL_UNKNOWN",
          "LEVEL_GLOBAL",
          "LEVEL_PRODUCT",
          "LEVEL_INSTANCE",
          "LEVEL_SIMULATION"
        ],
        "default": "LEVEL_UNKNOWN",
        "x-enum-value-release-info": {
          "LEVEL_GLOBAL": {
            "noticeVersion": {
              "major": 1,
              "minor": 7
            },
            "releaseVersion": {
              "major": 5
            },
            "changeType": "REMOVE_ENUM_VALUE",
            "description": "This enum value was never, and never will be, returned."
          },
          "LEVEL_SIMULATION": {
            "noticeVersion": {
              "major": 1,
              "minor": 4
            },
            "releaseVersion": {
              "major": 5
            },
            "changeType": "REMOVE_ENUM_VALUE",
            "description": "This enum value was replaced by the events field in the SimulateSmartContractRequest"
          }
        },
        "x-enum-value-descriptions": {
          "LEVEL_GLOBAL": "The parameter is only available at a global level.",
          "LEVEL_INSTANCE": "The parameter is only available at an instance level.",
          "LEVEL_PRODUCT": "The parameter is only available at a product level.",
          "LEVEL_UNKNOWN": "The level is unknown."
        }
      },
      "paramsParam": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the parameter."
          },
          "display_name": {
            "type": "string",
            "description": "The name of the parameter to be displayed in the UI."
          },
          "description": {
            "type": "string",
            "description": "The description of the parameter."
          },
          "value": {
            "type": "string",
            "description": "The current value of the parameter, populated only for product level parameters."
          },
          "default_value": {
            "type": "string",
            "description": "The default value of the parameter."
          },
          "effective_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The timestamp the parameter is effective from."
          },
          "level": {
            "$ref": "#/components/schemas/paramsLevel",
            "description": "The level the parameter is effective at."
          },
          "update_permission": {
            "$ref": "#/components/schemas/paramsUpdatePermission",
            "description": "The permission level required to update the parameter."
          },
          "derived": {
            "type": "boolean",
            "description": "Indicates whether this parameter is derived or not. Only applicable to instance-level parameters."
          },
          "is_optional": {
            "type": "boolean",
            "description": "Indicates whether this parameter value is optional or not."
          },
          "number": {
            "$ref": "#/components/schemas/paramsNumberField",
            "required": false
          },
          "account": {
            "$ref": "#/components/schemas/paramsAccountField",
            "required": false
          },
          "values": {
            "$ref": "#/components/schemas/paramsValueChoiceField",
            "required": false
          },
          "denomination": {
            "$ref": "#/components/schemas/paramsDenominationField",
            "required": false
          },
          "date": {
            "$ref": "#/components/schemas/paramsDateField",
            "required": false
          }
        }
      },
      "paramsUpdatePermission": {
        "type": "string",
        "enum": [
          "UPDATE_PERMISSION_UNKNOWN",
          "UPDATE_PERMISSION_FIXED",
          "UPDATE_PERMISSION_OPS_EDITABLE",
          "UPDATE_PERMISSION_CUSTOMER_EDITABLE",
          "UPDATE_PERMISSION_CUSTOMER_EDITABLE_WITH_OPS_PERMISSION"
        ],
        "default": "UPDATE_PERMISSION_UNKNOWN",
        "x-enum-value-descriptions": {
          "UPDATE_PERMISSION_CUSTOMER_EDITABLE": "The product is editable by a bank employee.",
          "UPDATE_PERMISSION_CUSTOMER_EDITABLE_WITH_OPS_PERMISSION": "The product is only editable by a bank employee with operations permission.",
          "UPDATE_PERMISSION_FIXED": "The product cannot be updated.",
          "UPDATE_PERMISSION_OPS_EDITABLE": "The product is editable by operations.",
          "UPDATE_PERMISSION_UNKNOWN": "The update permission is unknown."
        }
      },
      "paramsValueChoice": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "The value of the value choice entry."
          },
          "display_name": {
            "type": "string",
            "description": "The name of the value choice displayed to the bank."
          }
        }
      },
      "paramsValueChoiceField": {
        "type": "object",
        "properties": {
          "values": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/paramsValueChoice"
            },
            "description": "A list of value choices for this parameter."
          }
        }
      },
      "productsAddressDetails": {
        "type": "object",
        "properties": {
          "address_name": {
            "type": "string",
            "description": "The account address the details refer to."
          },
          "description": {
            "type": "string",
            "description": "A human-readable description of the address."
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "A list of tags that describe the address."
          }
        },
        "description": "A detailed description of an account address."
      },
      "productsBatchGetProductVersionsResponse": {
        "type": "object",
        "properties": {
          "product_versions": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/productsProductVersion"
            },
            "description": "Maps the product version ID to the product version."
          }
        }
      },
      "productsBatchGetProductsResponse": {
        "type": "object",
        "properties": {
          "products": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/productsProduct"
            },
            "description": "Maps the product ID to the product."
          }
        }
      },
      "productsContractModuleDetails": {
        "type": "object",
        "properties": {
          "alias_to_shared_function_details": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/contract_modulesSharedFunctionDetails"
            },
            "description": "A map of Contract Module aliases to the function details required for the Contract to run."
          }
        }
      },
      "productsCreateProductVersionRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID that is used to ensure the request is idempotent.\n\nRequired.\nMax length: 256 characters."
          },
          "product_version": {
            "$ref": "#/components/schemas/productsProductVersion",
            "description": "The product version to be created. Required.",
            "x-excluded-fields": [
              "display_version_number",
              "create_timestamp",
              "is_current",
              "tside",
              "address_details",
              "contract_module_details"
            ]
          },
          "migration_strategy": {
            "$ref": "#/components/schemas/productsProductVersionMigrationStrategy",
            "description": "The migration strategy for applying the new version. Optional."
          },
          "is_internal": {
            "type": "boolean",
            "description": "When creating a new product, used to indicate if the new product is for internal accounts only and not available to customers."
          }
        },
        "description": "Create a ProductVersion.",
        "required": [
          "request_id"
        ]
      },
      "productsListProductVersionParametersTimeseriesResponse": {
        "type": "object",
        "properties": {
          "product_version_param_timeseries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/productsParameterTimeseries"
            },
            "description": "The product version parameter timeseries that is retrieved for the specified product version ID."
          }
        }
      },
      "productsListProductVersionsResponse": {
        "type": "object",
        "properties": {
          "product_versions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/productsProductVersion"
            },
            "description": "A list of the product versions matching the specified product_version_id. The order of the items is arbitrary and is not guaranteed to remain the same."
          },
          "previous_page_token": {
            "type": "string",
            "description": "Token used to retrieve the previous page. If empty, returns the first page of results."
          },
          "next_page_token": {
            "type": "string",
            "description": "Token used to retrieve the next page If empty, returns the last page of results."
          }
        }
      },
      "productsListProductsResponse": {
        "type": "object",
        "properties": {
          "products": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/productsProduct"
            },
            "description": "A list of matching products. The order of the items is arbitrary and is not guaranteed to remain the same."
          },
          "previous_page_token": {
            "type": "string",
            "description": "Token used to retrieve the previous page. If empty, returns the first page of results."
          },
          "next_page_token": {
            "type": "string",
            "description": "Token used to retrieve the next page. If empty, returns the last page of results."
          }
        }
      },
      "productsParamValue": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "The value of a parameter."
          },
          "effective_from_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "A timestamp that indicates when the parameter value is effective from."
          }
        }
      },
      "productsParameterTimeseries": {
        "type": "object",
        "properties": {
          "param_name": {
            "type": "string",
            "description": "The parameter the value changes apply to."
          },
          "values": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/productsParamValue"
            },
            "description": "The value of the parameter and the timestamp that indicates when the parameter value became active."
          }
        }
      },
      "productsProduct": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "A globally-unique ID for the product."
          },
          "display_name": {
            "type": "string",
            "description": "The name of the product displayed to the customer."
          },
          "is_internal": {
            "type": "boolean",
            "description": "Indicates if the product is meant for customers to sign up to (external) or if it used to model internal bank accounts (internal)."
          },
          "current_version_id": {
            "type": "string",
            "description": "The ID of the current version of the product."
          }
        },
        "description": "A product specifies the behaviours and rules for an account in Vault. Each product will have one or more versions; one of these versions will be the current version. The current version is the version that will be used when customers open an account of the given product type."
      },
      "productsProductVersion": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "A globally-unique ID for the product version."
          },
          "display_name": {
            "type": "string",
            "description": "The name of the product displayed to the customer. This can be set in the contract code. Optional."
          },
          "display_version_number": {
            "$ref": "#/components/schemas/versionSemVer",
            "description": "The version number of the product. This is set in the contract code."
          },
          "create_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp indicating when the product version was created."
          },
          "is_current": {
            "type": "boolean",
            "description": "Indicates whether this is the current version of the product."
          },
          "description": {
            "type": "string",
            "description": "A description of the product version. If set on creation, this will override any description set in the Smart Contract code. Optional."
          },
          "summary": {
            "type": "string",
            "description": "A summary of the product version. If set on creation and the major version of the display_version_number is < 4, this will override the summary set in the Smart Contract code. Optional."
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "Tags for the product version; these are created by users of Vault and simplify searching. Optional."
          },
          "core_tags": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/productsProductVersionCoreTag"
            },
            "description": "Core tags for the product version; these are created by Vault and could be, for example, savings or loan. Optional."
          },
          "params": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/paramsParam"
            },
            "description": "The parameter values for the product version. Required in a POST product-versions request when the contract has product level parameters (only name and value attributes of parameters need to be provided)."
          },
          "code": {
            "type": "string",
            "description": "The Smart Contract code for the product version. Required."
          },
          "product_id": {
            "type": "string",
            "description": "Used as the product_id when the migration strategy is set to NEW_PRODUCT; otherwise this will add product_version to a specified product. Required."
          },
          "tside": {
            "$ref": "#/components/schemas/accountingTside",
            "description": "Tside for any accounts created with this product version. Tside is used by the bank to indicate the side of the balance sheet the accounts are on. This is set in the Smart Contract code or set to LIABILITY by default."
          },
          "supported_denominations": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The denominations supported by this product version. Required for non-internal products."
          },
          "address_details": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/productsAddressDetails"
            },
            "description": "The address details described in this product version."
          },
          "contract_module_details": {
            "$ref": "#/components/schemas/productsContractModuleDetails",
            "description": "The Contract Module interfaces required for the execution of this product. This is set in the Contract code.",
            "x-release-info": {
              "releaseVersion": {
                "major": 2,
                "minor": 6
              },
              "changeType": "ADD_FIELD"
            }
          },
          "entity_id": {
            "type": "string",
            "description": "The entity ID for the product version.",
            "x-release-info": {
              "changeType": "ADD_FIELD",
              "featureFlag": "TMV_685_MULTI_ENTITY_MVP"
            }
          },
          "notification_types": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The notification types supported by this product version.",
            "x-release-info": {
              "changeType": "ADD_FIELD",
              "featureFlag": "TM_66923_CONTRACTS_NOTIFICATION_EVENT"
            }
          }
        },
        "description": "A product version that holds detailed information about a specific version of a product, including the code for a smart contract."
      },
      "productsProductVersionCoreTag": {
        "type": "string",
        "enum": [
          "PRODUCT_VERSION_CORE_TAG_UNKNOWN",
          "PRODUCT_VERSION_CORE_TAG_DEPOSIT",
          "PRODUCT_VERSION_CORE_TAG_FIXED_TERM_DEPOSIT",
          "PRODUCT_VERSION_CORE_TAG_SAVING",
          "PRODUCT_VERSION_CORE_TAG_LOAN",
          "PRODUCT_VERSION_CORE_TAG_CREDIT",
          "PRODUCT_VERSION_CORE_TAG_MORTGAGE"
        ],
        "default": "PRODUCT_VERSION_CORE_TAG_UNKNOWN",
        "x-enum-value-descriptions": {
          "PRODUCT_VERSION_CORE_TAG_CREDIT": "Tags the product as a credit product.",
          "PRODUCT_VERSION_CORE_TAG_DEPOSIT": "Tags the product version as a single deposit.",
          "PRODUCT_VERSION_CORE_TAG_FIXED_TERM_DEPOSIT": "Tags the product version as several deposits over a fixed term.",
          "PRODUCT_VERSION_CORE_TAG_LOAN": "Tags the product as a loan.",
          "PRODUCT_VERSION_CORE_TAG_MORTGAGE": "Tags the product as a mortgage.",
          "PRODUCT_VERSION_CORE_TAG_SAVING": "Tags the product as a savings product.",
          "PRODUCT_VERSION_CORE_TAG_UNKNOWN": "Default value."
        }
      },
      "productsProductVersionMigrationStrategy": {
        "type": "string",
        "enum": [
          "PRODUCT_VERSION_MIGRATION_STRATEGY_UNKNOWN",
          "PRODUCT_VERSION_MIGRATION_STRATEGY_NEW_PRODUCT",
          "PRODUCT_VERSION_MIGRATION_STRATEGY_ADD_VERSION",
          "PRODUCT_VERSION_MIGRATION_STRATEGY_ADD_VERSION_APPLY_NEW_USERS",
          "PRODUCT_VERSION_MIGRATION_STRATEGY_ADD_VERSION_ASK_EXISTING_USERS",
          "PRODUCT_VERSION_MIGRATION_STRATEGY_ADD_VERSION_AUTO_MIGRATE_USERS",
          "PRODUCT_VERSION_MIGRATION_STRATEGY_ADD_VERSION_UPGRADE_INTERNAL_ACCOUNTS"
        ],
        "default": "PRODUCT_VERSION_MIGRATION_STRATEGY_UNKNOWN",
        "x-enum-value-release-info": {
          "PRODUCT_VERSION_MIGRATION_STRATEGY_ADD_VERSION_ASK_EXISTING_USERS": {
            "noticeVersion": {
              "major": 2,
              "minor": 7
            },
            "releaseVersion": {
              "major": 5
            },
            "changeType": "REMOVE_ENUM_VALUE",
            "description": "Removal planned, use the /v1/account-migrations endpoint instead."
          },
          "PRODUCT_VERSION_MIGRATION_STRATEGY_ADD_VERSION_AUTO_MIGRATE_USERS": {
            "noticeVersion": {
              "major": 2,
              "minor": 4
            },
            "releaseVersion": {
              "major": 5
            },
            "changeType": "REMOVE_ENUM_VALUE",
            "description": "Removal planned, use the /v1/account-migrations endpoint instead."
          },
          "PRODUCT_VERSION_MIGRATION_STRATEGY_ADD_VERSION_UPGRADE_INTERNAL_ACCOUNTS": {
            "noticeVersion": {
              "major": 2,
              "minor": 7
            },
            "releaseVersion": {
              "major": 5
            },
            "changeType": "REMOVE_ENUM_VALUE",
            "description": "Removal planned, use the /v1/account-migrations endpoint instead."
          }
        },
        "x-enum-value-descriptions": {
          "PRODUCT_VERSION_MIGRATION_STRATEGY_ADD_VERSION": "Creates a new product version, returning an error if the product does not exist. This strategy does not update the current version of the product. Existing accounts on this product are not migrated to this product version. This is not a valid strategy for internal products.",
          "PRODUCT_VERSION_MIGRATION_STRATEGY_ADD_VERSION_APPLY_NEW_USERS": "Creates a new product version, returning an error if the product does not exist. This strategy updates the current version of the product to this product version. Existing accounts on this product are not migrated to this product version. This is not a valid strategy for internal products.",
          "PRODUCT_VERSION_MIGRATION_STRATEGY_ADD_VERSION_ASK_EXISTING_USERS": "Creates a new product version, returning an error if the product does not exist. This strategy updates the current version of the product to this product version. Migrates all accounts on this product to this product version. This is not a valid strategy for internal products. Identical to `PRODUCT_VERSION_MIGRATION_STRATEGY_ADD_VERSION_AUTO_MIGRATE_USER`. Despite its name, this strategy will NOT warn existing users before migrating their accounts.",
          "PRODUCT_VERSION_MIGRATION_STRATEGY_ADD_VERSION_AUTO_MIGRATE_USERS": "Creates a new product version, returning an error if the product does not exist. This strategy updates the current version of the product to this product version. Migrates all accounts on this product to this product version. This is not a valid strategy for internal products. Identical to `PRODUCT_VERSION_MIGRATION_STRATEGY_ADD_VERSION_ASK_EXISTING_USERS`.",
          "PRODUCT_VERSION_MIGRATION_STRATEGY_ADD_VERSION_UPGRADE_INTERNAL_ACCOUNTS": "Creates a new product version, returning an error if the product does not exist. This strategy updates the current version of the product to this product version. Migrates all accounts on this product to this product version. This is a valid strategy for internal products.",
          "PRODUCT_VERSION_MIGRATION_STRATEGY_NEW_PRODUCT": "Creates a new product and initial product version, returning an error if the product already exists. This is a valid strategy for internal products.",
          "PRODUCT_VERSION_MIGRATION_STRATEGY_UNKNOWN": "The migration strategy is not known. This is not a valid strategy for internal products. Defaults to `PRODUCT_VERSION_MIGRATION_STRATEGY_NEW_PRODUCT`."
        }
      },
      "productsProductVersionView": {
        "type": "string",
        "enum": [
          "PRODUCT_VERSION_VIEW_BASIC",
          "PRODUCT_VERSION_VIEW_INCLUDE_TAGS",
          "PRODUCT_VERSION_VIEW_INCLUDE_PARAMETERS",
          "PRODUCT_VERSION_VIEW_INCLUDE_CODE"
        ],
        "default": "PRODUCT_VERSION_VIEW_BASIC",
        "x-enum-value-descriptions": {
          "PRODUCT_VERSION_VIEW_BASIC": "Default. Includes basic information about the product version.",
          "PRODUCT_VERSION_VIEW_INCLUDE_CODE": "Includes contract parameters and source code associated with the product.",
          "PRODUCT_VERSION_VIEW_INCLUDE_PARAMETERS": "Includes basic product version information and contract parameters associated with the product.",
          "PRODUCT_VERSION_VIEW_INCLUDE_TAGS": "Includes basic product version information and tags associated with the product."
        }
      },
      "productsUpdateProductVersionParamsRequest": {
        "type": "object",
        "properties": {
          "product_version_id": {
            "type": "string",
            "description": "The ID of the product version to be updated.\n\nRequired."
          },
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent.\n\nRequired.\nMax length: 512 characters."
          },
          "items_to_add": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/paramsParam"
            },
            "description": "A list of parameters that are to be added to the product version parameter timeseries. Each parameter in the `items_to_add` field must have its `name` and `value` populated. The `effective_timestamp` is optional and will default to current time. If set, the `effective_timestamp` must be in UTC format.\n\nWhen editing the value of one or more parameter(s), each parameter in `items_to_add` must correspond to a parameter in `items_to_remove` with a matching `name` and `effective_timestamp`."
          },
          "items_to_remove": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/paramsParam"
            },
            "description": "A list of the parameters that are to be removed from the product version parameter timeseries. Each parameter in the `items_to_remove` field must have its `name` and `effective_timestamp` populated. The `effective_timestamp` must be in UTC format. The `value` of the parameter(s) will be ignored. An error will be raised if the `items_to_remove` field is populated with a parameter `name` and `effective_timestamp` that do not already exist in the product version parameter timeseries.\n\nWhen editing the value of one or more parameter(s), each parameter in `items_to_remove` must correspond to a parameter in `items_to_add` with a matching `name` and `effective_timestamp`."
          }
        },
        "description": "Updates parameter values for a product version at current or future timestamps. This will not add or remove parameters from the product version.",
        "required": [
          "product_version_id",
          "request_id"
        ]
      },
      "restrictionsBatchGetRestrictionSetDefinitionVersionsResponse": {
        "type": "object",
        "properties": {
          "restriction_set_definition_versions": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/restrictionsRestrictionSetDefinitionVersion"
            },
            "description": "A map of the restriction set definition version ID to the restriction set definition version."
          }
        }
      },
      "restrictionsBatchGetRestrictionSetsResponse": {
        "type": "object",
        "properties": {
          "restriction_sets": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/restrictionsRestrictionSet"
            },
            "description": "A map of the restriction set ID to the restriction set."
          }
        }
      },
      "restrictionsCreateRestrictionSetDefinitionVersionRequest": {
        "type": "object",
        "properties": {
          "restriction_set_definition_version": {
            "$ref": "#/components/schemas/restrictionsRestrictionSetDefinitionVersion",
            "description": "The restriction set definition version to create. If the provided restriction set definition ID does not exist in the system, it will be created automatically. Required.",
            "x-excluded-fields": [
              "id",
              "create_timestamp",
              "is_current"
            ]
          },
          "request_id": {
            "type": "string",
            "description": "The unique string ID used to ensure this request is idempotent. Required.\n\nRequired.\nMax length: 256 characters."
          }
        },
        "required": [
          "request_id"
        ]
      },
      "restrictionsCreateRestrictionSetRequest": {
        "type": "object",
        "properties": {
          "restriction_set": {
            "$ref": "#/components/schemas/restrictionsRestrictionSet",
            "description": "The restriction set to create. Required.",
            "x-excluded-fields": [
              "id",
              "restrictions",
              "is_active"
            ]
          },
          "request_id": {
            "type": "string",
            "description": "The unique string ID used to ensure this request is idempotent. Required.\n\nRequired.\nMax length: 256 characters."
          }
        },
        "required": [
          "request_id"
        ]
      },
      "restrictionsListRestrictionSetDefinitionVersionsResponse": {
        "type": "object",
        "properties": {
          "restriction_set_definition_versions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/restrictionsRestrictionSetDefinitionVersion"
            },
            "description": "A list of matching restriction set definition versions, ordered by ascending `create_timestamp`."
          }
        }
      },
      "restrictionsListRestrictionSetDefinitionsResponse": {
        "type": "object",
        "properties": {
          "restriction_set_definitions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/restrictionsRestrictionSetDefinition"
            },
            "description": "A list of restriction set definitions, ordered by ascending `name`."
          },
          "previous_page_token": {
            "type": "string",
            "description": "The pagination token used to retrieve the previous page. If empty, this is the first page of results."
          },
          "next_page_token": {
            "type": "string",
            "description": "The pagination token used to retrieve the next page. If empty, this is the last page of results."
          }
        }
      },
      "restrictionsListRestrictionSetsResponse": {
        "type": "object",
        "properties": {
          "restriction_sets": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/restrictionsRestrictionSet"
            },
            "description": "A list of matching restriction sets. The order of the items is arbitrary."
          }
        }
      },
      "restrictionsListRestrictionsResponse": {
        "type": "object",
        "properties": {
          "restrictions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/restrictionsRestriction"
            },
            "description": "A list of matching restrictions."
          }
        }
      },
      "restrictionsRestriction": {
        "type": "object",
        "properties": {
          "restriction_type": {
            "$ref": "#/components/schemas/restrictionsRestrictionType",
            "description": "Enum value indicating which restriction type this applies to."
          },
          "parameters": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "title": "The restriction parameters. Param name (descriptor) -> Param value"
          },
          "customer_id": {
            "type": "string",
            "description": "The customer ID this restriction applies to."
          },
          "account_id": {
            "type": "string",
            "description": "The account ID this restriction applies to."
          },
          "payment_device_id": {
            "type": "string",
            "description": "The payment device ID this restriction applies to."
          },
          "effective_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time the restriction applies from."
          },
          "expiry_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time the restriction will expire. If empty, the restriction will not expire automatically."
          },
          "id": {
            "type": "string",
            "description": "The unique identifier for this restriction."
          }
        },
        "description": "Primitive restriction. This is an output-only object and is always part of a RestrictionSet."
      },
      "restrictionsRestrictionDefinition": {
        "type": "object",
        "properties": {
          "restriction_type": {
            "$ref": "#/components/schemas/restrictionsRestrictionType",
            "description": "The restriction type of this restriction definition. Required for create requests and must be unique among restriction definitions within a request and not set to unknown."
          },
          "required_restriction_levels": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/restrictionsRestrictionLevel"
            },
            "description": "The restriction levels required when instantiating from the definition. Required for create requests; no duplicates; may not be unknown."
          }
        },
        "description": "Definition of a restriction used in describing a restriction set definition."
      },
      "restrictionsRestrictionLevel": {
        "type": "string",
        "enum": [
          "RESTRICTION_LEVEL_UNKNOWN",
          "RESTRICTION_LEVEL_CUSTOMER",
          "RESTRICTION_LEVEL_ACCOUNT",
          "RESTRICTION_LEVEL_PAYMENT_DEVICE"
        ],
        "default": "RESTRICTION_LEVEL_UNKNOWN",
        "description": "The level the restriction is applied at.",
        "x-enum-value-descriptions": {
          "RESTRICTION_LEVEL_ACCOUNT": "Restriction will be applied for an account.",
          "RESTRICTION_LEVEL_CUSTOMER": "Restrictions will be applied for a customer.",
          "RESTRICTION_LEVEL_PAYMENT_DEVICE": "Restrictions will be applied for a payment device.",
          "RESTRICTION_LEVEL_UNKNOWN": "An unknown restriction level."
        }
      },
      "restrictionsRestrictionSet": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The unique identifier for this restriction set. Output only."
          },
          "restriction_set_definition_id": {
            "type": "string",
            "description": "The ID of a restriction set definition. Optional for create requests; if not provided for creation, a restriction set definition version ID must be provided.\n"
          },
          "restriction_set_definition_version_id": {
            "type": "string",
            "description": "The ID of a restriction set definition version. Optional for create requests; if not provided for creation, a restriction set definition ID must be provided.\n"
          },
          "name": {
            "type": "string",
            "description": "The name of the restriction set. Optional.\n"
          },
          "restrictions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/restrictionsRestriction"
            },
            "description": "The restrictions that constitute this restriction set. Output only."
          },
          "description": {
            "type": "string",
            "description": "A description of the restriction set. Optional.\n"
          },
          "restriction_set_parameters": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "The restriction parameters for the parameterised restriction types in the restriction set definition. For example, the restriction type LIMIT_DEBITS requires `limit_debits_amount` and`limit_debits_currency` to be included here. Optional unless the restriction set definition version contains restriction types that require parameters.\n"
          },
          "customer_id": {
            "type": "string",
            "description": "The ID of the customer the CUSTOMER level restrictions are to be applied to. Required for create requests if there is at least one restriction definition with level CUSTOMER.\n"
          },
          "account_id": {
            "type": "string",
            "description": "The ID of the account the ACCOUNT level restrictions are to be applied to. Required for create requests if there is at least one restriction definition with level ACCOUNT.\n"
          },
          "payment_device_id": {
            "type": "string",
            "description": "The ID of the payment device the PAYMENT_DEVICE level restrictions are to be applied to. Required for create requests if there is at least one restriction definition with level PAYMENT_DEVICE.\n"
          },
          "effective_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time the restriction set should apply from; must be in the future. Optional; default is the current time.\n"
          },
          "expiry_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time the restriction will expire; must be after the effective_timestamp. Optional; if left empty, the restriction will not expire automatically.\n"
          },
          "is_active": {
            "type": "boolean",
            "description": "Indicates if the restriction set is active at the current time or at the time provided when, for example listing restriction sets. Update only."
          }
        },
        "description": "An instantiated restriction set definition formed of restrictions that apply to specific `customer_id` or `account_id` or `payment_device_id`."
      },
      "restrictionsRestrictionSetDefinition": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The unique identifier for this restriction set."
          },
          "name": {
            "type": "string",
            "description": "The restriction set definition name."
          },
          "is_active": {
            "type": "boolean",
            "description": "Whether the restriction set definition is active. Inactive restriction set definitions may still apply to customers, accounts and payment devices after being made inactive if the entity is still assigned to them.",
            "x-release-info": {
              "noticeVersion": {
                "major": 4,
                "minor": 6
              },
              "releaseVersion": {
                "major": 6
              },
              "changeType": "REMOVE_FIELD",
              "description": "This is an immutable field which is hardcoded to true internally, so it is not necessary to return this on the API"
            }
          }
        },
        "description": "A set of definitions from which restriction sets can be created and applied to customers, accounts and payment devices. It's an output only object, derived from the versions created."
      },
      "restrictionsRestrictionSetDefinitionVersion": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "Unique identifier for this restriction set definition version. Output only."
          },
          "restriction_definitions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/restrictionsRestrictionDefinition"
            },
            "description": "The restriction definitions that constitute this restriction set definition version. Required for create requests."
          },
          "restriction_set_definition_id": {
            "type": "string",
            "description": "The ID or name of the restriction set definition this version belongs to. Required for create requests.\n\nRequired."
          },
          "description": {
            "type": "string",
            "description": "Description of the restriction set definition version. Optional.\n"
          },
          "create_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp of when the restriction set definition version was created. Output only."
          },
          "is_current": {
            "type": "boolean",
            "description": "Indicates whether the restriction set definition version is the current version. Output only."
          }
        },
        "description": "A specific version of a restriction set definition.",
        "required": [
          "restriction_set_definition_id"
        ]
      },
      "restrictionsRestrictionType": {
        "type": "string",
        "enum": [
          "RESTRICTION_TYPE_UNKNOWN",
          "RESTRICTION_TYPE_PREVENT_CREDITS",
          "RESTRICTION_TYPE_REVIEW_CREDITS",
          "RESTRICTION_TYPE_PREVENT_DEBITS",
          "RESTRICTION_TYPE_REVIEW_DEBITS",
          "RESTRICTION_TYPE_PREVENT_CLOSURE",
          "RESTRICTION_TYPE_PREVENT_OPENING",
          "RESTRICTION_TYPE_LIMIT_DEBITS",
          "RESTRICTION_TYPE_LIMIT_CREDITS",
          "RESTRICTION_TYPE_PREVENT_UPDATES",
          "RESTRICTION_TYPE_PREVENT_ACCOUNT_CREATION"
        ],
        "default": "RESTRICTION_TYPE_UNKNOWN",
        "description": "The restriction type that should be applied.",
        "x-enum-value-descriptions": {
          "RESTRICTION_TYPE_LIMIT_CREDITS": "A restriction type that limits credits for a customer, account or payment device. Applies to individual posting amounts, not a cumulative amount across one or more postings. This restriction requires `limit_credits_amount` and `limit_credits_currency` to be included as part of the restriction_set_parameters when creating a restriction set. Enforced restriction level combinations are: [RESTRICTION_LEVEL_CUSTOMER] - Prevents the customer from receiving credits above the specified amount. [RESTRICTION_LEVEL_ACCOUNT] - Prevents the account from receiving credits above the specified amount. [RESTRICTION_LEVEL_PAYMENT_DEVICE] - Prevents the payment device from receiving credits above the specified amount.",
          "RESTRICTION_TYPE_LIMIT_DEBITS": "A restriction type that limits debits being made by a customer, account or payment device. Applies to individual posting amounts, not a cumulative amount across one or more postings. This restriction requires `limit_debits_amount` and `limit_debits_currency` to be included as part of the restriction_set_parameters when creating a restriction set. Enforced restriction level combinations are: [RESTRICTION_LEVEL_CUSTOMER] - Limits the debits the customer can make to the specified amount. [RESTRICTION_LEVEL_CUSTOMER, RESTRICTION_LEVEL_ACCOUNT] - Limits the debits the customer can make from an account to the specified amount. [RESTRICTION_LEVEL_ACCOUNT] - Limits the debits the account can make to the specified amount. [RESTRICTION_LEVEL_PAYMENT_DEVICE] - Limits the debits the payment device can make to the specified amount.",
          "RESTRICTION_TYPE_PREVENT_ACCOUNT_CREATION": "A restriction type that prevents a customer from applying for any accounts, and from being added as a new stakeholder when updating an account. A stakeholder with a restriction of this type can be removed from the stakeholder list. Enforced restriction level combinations are: [RESTRICTION_LEVEL_CUSTOMER] - Prevents the customer from applying for any accounts.",
          "RESTRICTION_TYPE_PREVENT_CLOSURE": "A restriction type that prevents closing a customer, account or payment device. Enforced restriction level combinations are: [RESTRICTION_LEVEL_ACCOUNT] - Prevents all stakeholders from closing the account. [RESTRICTION_LEVEL_PAYMENT_DEVICE] - Prevents the payment device from being made inactive.",
          "RESTRICTION_TYPE_PREVENT_CREDITS": "A restriction type that prevents credits. Enforced restriction level combinations are: [RESTRICTION_LEVEL_CUSTOMER] - Prevents the customer from receiving credits [RESTRICTION_LEVEL_ACCOUNT] - Prevents the account from receiving credits. [RESTRICTION_LEVEL_PAYMENT_DEVICE] - Prevents the payment device from receiving credits. [RESTRICTION_LEVEL_ACCOUNT, RESTRICTION_LEVEL_PAYMENT_DEVICE] - Prevents the account from receiving credits using this payment device. The optional parameter, `\"prevent_credits_exemption_conditions\"`, defines special conditions under which the RESTRICTION_TYPE_PREVENT_CREDITS restriction will not apply. The `\"prevent_credits_exemption_conditions\"` parameter must be formatted as a JSON string with one or more key-value pairs. For example, to prevent credits on an account except when the debtor account number is \"1234\", the `\"prevent_credits_exemption_conditions\"` parameter may look like `\"{\"debitor_account_number\":\"1234\", \"debitor_bank_id\":\"4321\"}\"`. The restriction exemption is only applied if all the specified key-value pairs are present in the PostingInstructions' `instruction_details`.",
          "RESTRICTION_TYPE_PREVENT_DEBITS": "A restriction type that prevents debits. Enforced restriction level combinations are: [RESTRICTION_LEVEL_CUSTOMER] - Prevents debits for the customer. [RESTRICTION_LEVEL_CUSTOMER, RESTRICTION_LEVEL_ACCOUNT] - Prevents debits for the customer on a specific account. [RESTRICTION_LEVEL_ACCOUNT] - Prevents debits for the account. [RESTRICTION_LEVEL_PAYMENT_DEVICE] - Prevents debits for the payment device. The optional parameter, `\"prevent_debits_exemption_conditions\"`, defines special conditions under which the RESTRICTION_TYPE_PREVENT_DEBITS restriction will not apply. The `\"prevent_debits_exemption_conditions\"` parameter must be formatted as a JSON string with one or more key-value pairs. For example, to prevent debits on an account except when the creditor account number is \"1234\", the `\"prevent_debits_exemption_conditions\"` parameter may look like `\"{\"creditor_account_number\":\"1234\", \"creditor_bank_id\":\"4321\"}\"`. The restriction exemption is only applied if all the specified key-value pairs are present in the PostingInstructions' `instruction_details`.",
          "RESTRICTION_TYPE_PREVENT_OPENING": "A restriction type that prevents opening a customer, account or payment device. Enforced restriction level combinations are: [RESTRICTION_LEVEL_ACCOUNT] - Prevents an account from being approved [RESTRICTION_LEVEL_PAYMENT_DEVICE] - Prevents a payment device from being made active",
          "RESTRICTION_TYPE_PREVENT_UPDATES": "A restriction type that prevents updating a customer, account or payment device. Enforced restriction level combinations are: [RESTRICTION_LEVEL_CUSTOMER] - Prevents the customer from being updated. [RESTRICTION_LEVEL_ACCOUNT] - Prevents the account from being updated. [RESTRICTION_LEVEL_PAYMENT_DEVICE] - Prevents the payment device from being updated.",
          "RESTRICTION_TYPE_REVIEW_CREDITS": "A restriction type that will require reviewing credits. Enforced restriction level combinations are: [RESTRICTION_LEVEL_CUSTOMER] - Forces a review of credits for a customer (NOT YET IMPLEMENTED IN POSTINGS PROCESSOR). [RESTRICTION_LEVEL_ACCOUNT] - Forces a review of credits for an account. [RESTRICTION_LEVEL_PAYMENT_DEVICE] - Forces a review of credits for a payment device.",
          "RESTRICTION_TYPE_REVIEW_DEBITS": "A restriction type that requires reviewing debits. Enforced restriction level combinations are: [RESTRICTION_LEVEL_CUSTOMER] - Forces a review of customer debits. [RESTRICTION_LEVEL_ACCOUNT] - Forces a review of account debits. [RESTRICTION_LEVEL_PAYMENT_DEVICE] - Forces a review of payment device debits.",
          "RESTRICTION_TYPE_UNKNOWN": "An unknown restriction type. There are no enforced combinations."
        }
      },
      "restrictionsUpdateRestrictionSetRequest": {
        "type": "object",
        "properties": {
          "restriction_set": {
            "$ref": "#/components/schemas/restrictionsRestrictionSet",
            "description": "The restriction set to update. Only is_active can be updated and only from True to False at the current time. Required.",
            "x-excluded-fields": [
              "restriction_set_definition_id",
              "restriction_set_definition_version_id",
              "name",
              "restrictions",
              "description",
              "restriction_set_parameters",
              "customer_id",
              "account_id",
              "payment_device_id",
              "effective_timestamp",
              "expiry_timestamp"
            ]
          },
          "request_id": {
            "type": "string",
            "description": "The unique string ID used to ensure this request is idempotent. Required.\n\nRequired.\nMax length: 256 characters."
          },
          "update_mask": {
            "$ref": "#/components/schemas/protobufFieldMask",
            "description": "The field mask used to indicate which fields in the resource are to be updated. Required. The only valid update path is \"is_active\"."
          }
        },
        "required": [
          "request_id"
        ]
      },
      "schedulerBatchGetJobsResponse": {
        "type": "object",
        "properties": {
          "jobs": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/schedulerJob"
            },
            "description": "Maps the Job ID to the requested Job."
          }
        }
      },
      "schedulerBatchGetSchedulesResponse": {
        "type": "object",
        "properties": {
          "schedules": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/schedulerSchedule"
            },
            "description": "Maps the Schedule ID to the requested Schedules."
          }
        }
      },
      "schedulerCreateScheduleTagRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID used to ensure the request is idempotent.\n\nRequired.\nMax length: 256 characters."
          },
          "schedule_tag": {
            "$ref": "#/components/schemas/schedulerScheduleTag",
            "description": "The ScheduleTag that is to be created. Required."
          }
        },
        "required": [
          "request_id"
        ]
      },
      "schedulerJob": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "A Unique identifier for a Job."
          },
          "status": {
            "$ref": "#/components/schemas/schedulerJobStatus",
            "description": "The execution status of the Job."
          },
          "schedule_id": {
            "type": "string",
            "description": "The Schedule ID references the Schedule that the Job belongs to."
          },
          "schedule_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time the job was scheduled to be triggered."
          },
          "publish_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time the job was actually published by the Scheduler."
          },
          "completed_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "Indicates the time that a successful job outcome was received. This timestamp is UTC.",
            "x-release-info": {
              "releaseVersion": {
                "major": 2,
                "minor": 7
              },
              "changeType": "ADD_FIELD",
              "description": "Add a new field: completed timestamp"
            }
          }
        }
      },
      "schedulerJobStatus": {
        "type": "string",
        "enum": [
          "JOB_STATUS_UNKNOWN",
          "JOB_STATUS_PUBLISHED",
          "JOB_STATUS_SUCCEEDED",
          "JOB_STATUS_FAILED",
          "JOB_STATUS_SKIPPED"
        ],
        "default": "JOB_STATUS_UNKNOWN",
        "description": "The status of the Job.",
        "x-enum-value-release-info": {
          "JOB_STATUS_SKIPPED": {
            "releaseVersion": {
              "major": 2
            },
            "changeType": "ADD_ENUM_VALUE",
            "description": "Adds a new status value: Skipped",
            "featureFlag": "KERN_199_SCHEDULER_SKIP"
          }
        },
        "x-enum-value-descriptions": {
          "JOB_STATUS_FAILED": "A Job has failed to complete.",
          "JOB_STATUS_PUBLISHED": "A Job has been published but not executed.",
          "JOB_STATUS_SKIPPED": "A Job has been skipped.",
          "JOB_STATUS_SUCCEEDED": "A Job has completed sucessfully.",
          "JOB_STATUS_UNKNOWN": "Default Value."
        }
      },
      "schedulerListJobsResponse": {
        "type": "object",
        "properties": {
          "jobs": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/schedulerJob"
            },
            "description": "A list of Jobs that belongs to the specified Schedule ID. Results are not ordered but guarenteed to remain the same."
          },
          "previous_page_token": {
            "type": "string",
            "description": "Token used to retrieve the previous page. Empty token if it is the first page."
          },
          "next_page_token": {
            "type": "string",
            "description": "Token used to retrieve the next page. Empty token if it is the last page."
          }
        }
      },
      "schedulerListSchedulesResponse": {
        "type": "object",
        "properties": {
          "schedules": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/schedulerSchedule"
            },
            "description": "Contains the list of requested Schedules ordered by the time of creation ascending."
          },
          "previous_page_token": {
            "type": "string",
            "description": "Token used to retrieve the previous page. Empty token if it is the first page."
          },
          "next_page_token": {
            "type": "string",
            "description": "Token used to retrieve the next page. Empty token if it is the last page."
          }
        }
      },
      "schedulerRepublishJobRequest": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The ID of the Job to be republished."
          }
        }
      },
      "schedulerRepublishJobResponse": {
        "type": "object",
        "title": "Placeholder for empty response"
      },
      "schedulerSchedule": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The UUID of the Schedule."
          },
          "name": {
            "type": "string",
            "description": "The name of the Schedule."
          },
          "display_name": {
            "type": "string",
            "description": "The user-friendly display name for the Schedule."
          },
          "status": {
            "$ref": "#/components/schemas/schedulerScheduleStatus",
            "description": "The Status of the Schedule."
          },
          "create_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time the Schedule was created."
          },
          "start_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time that the Schedule will first run."
          },
          "end_timestamp": {
            "type": "string",
            "format": "date-time",
            "title": "The time when the Schedule will stop running"
          },
          "next_run_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The next time the Schedule will run, calculated from the Time Expression."
          },
          "disabled_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time the Schedule became disabled."
          },
          "time_expression": {
            "type": "string",
            "description": "The time expression that defines when Jobs will be run. This could be a CRON expression or a single timestamp."
          },
          "timezone": {
            "type": "string",
            "description": "The timezone the Schedule is in. All timestamps attached to a Schedule are in UTC. The timezone reflects when the `next_run_timestamp` is calculated according to the time expression.",
            "x-release-info": {
              "releaseVersion": {
                "major": 1,
                "minor": 8
              },
              "changeType": "ADD_FIELD"
            }
          },
          "tags": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The tags for a given Schedule.",
            "x-release-info": {
              "releaseVersion": {
                "major": 1,
                "minor": 8
              },
              "changeType": "ADD_FIELD"
            }
          },
          "group": {
            "$ref": "#/components/schemas/schedulerScheduleGroupMembership",
            "description": "The Group the Schedule belongs to.",
            "x-release-info": {
              "releaseVersion": {
                "major": 1,
                "minor": 8
              },
              "changeType": "ADD_FIELD"
            }
          },
          "skip_start_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "A timestamp indicating when to start skipping a schedule. Optional. The timestamp is in UTC format.",
            "x-release-info": {
              "releaseVersion": {
                "major": 3,
                "minor": 1
              },
              "changeType": "ADD_FIELD"
            }
          },
          "skip_end_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "A timestamp indicating when to resume a skipped schedule. Optional. The timestamp is in UTC format.",
            "x-release-info": {
              "releaseVersion": {
                "major": 3,
                "minor": 1
              },
              "changeType": "ADD_FIELD"
            }
          }
        },
        "description": "This is the response structure when returning Schedules."
      },
      "schedulerScheduleGroupMembership": {
        "type": "object",
        "properties": {
          "group_id": {
            "type": "string",
            "description": "The ID of the Group the Schedule belongs to."
          },
          "group_order": {
            "type": "integer",
            "format": "int64",
            "description": "The order of execution of Schedules in the Group."
          }
        },
        "description": "The ScheduleGroupMembership stores the details of the Group that the Schedule belongs to."
      },
      "schedulerScheduleStatus": {
        "type": "string",
        "enum": [
          "SCHEDULE_STATUS_UNKNOWN",
          "SCHEDULE_STATUS_ENABLED",
          "SCHEDULE_STATUS_DISABLED",
          "SCHEDULE_STATUS_COMPLETED",
          "SCHEDULE_STATUS_FAILED",
          "SCHEDULE_STATUS_PENDING",
          "SCHEDULE_STATUS_DELAYED",
          "SCHEDULE_STATUS_SKIPPED"
        ],
        "default": "SCHEDULE_STATUS_UNKNOWN",
        "x-enum-value-release-info": {
          "SCHEDULE_STATUS_DELAYED": {
            "releaseVersion": {
              "major": 2
            },
            "changeType": "ADD_ENUM_VALUE",
            "description": "Adds a new status value: Delayed"
          },
          "SCHEDULE_STATUS_SKIPPED": {
            "noticeVersion": {
              "major": 3,
              "minor": 1
            },
            "releaseVersion": {
              "major": 5
            },
            "changeType": "REMOVE_ENUM_VALUE",
            "description": "This field's functionality is to be replaced by skip_start_timestamp/skip_end_timestamp"
          }
        },
        "x-enum-value-descriptions": {
          "SCHEDULE_STATUS_COMPLETED": "The Schedule has completed and is inactive.",
          "SCHEDULE_STATUS_DELAYED": "A Schedule is in a DELAYED State.",
          "SCHEDULE_STATUS_DISABLED": "The Schedule is disabled and inactive.",
          "SCHEDULE_STATUS_ENABLED": "The Schedule is enabled and active.",
          "SCHEDULE_STATUS_FAILED": "The Schedule has failed and is inactive.",
          "SCHEDULE_STATUS_PENDING": "The Schedule is in a PENDING State.",
          "SCHEDULE_STATUS_SKIPPED": "A Schedule is in a SKIPPED State.",
          "SCHEDULE_STATUS_UNKNOWN": "When selected, a filter is applied to ScheduleStatus. Default is unselected."
        }
      },
      "schedulerScheduleTag": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "The ID (or human-readable name) of the ScheduleTag. Required.\n\nRequired.\nMax length: 256 characters."
          },
          "description": {
            "type": "string",
            "description": "The description of the ScheduleTag. Optional.\n",
            "x-create-only": true
          },
          "sends_scheduled_operation_reports": {
            "type": "boolean",
            "description": "Indicates if the ScheduleTag is set to produce execution notifications."
          }
        },
        "required": [
          "id"
        ]
      },
      "balancesPostingBalance": {
        "type": "object",
        "properties": {
          "posting_instruction_batch_id": {
            "type": "string",
            "description": "The posting instruction batch that originally created this balance update."
          },
          "as_of_posting_instruction_batch_id": {
            "type": "string",
            "description": "The posting instruction batch that most recently updated (or created) this balance."
          },
          "amount": {
            "type": "string",
            "description": "The net value of the balance."
          },
          "account_id": {
            "type": "string",
            "description": "The ID of the account this balance belongs to."
          },
          "account_address": {
            "type": "string",
            "description": "Represents one partition of the total balances held on the account."
          },
          "phase": {
            "$ref": "#/components/schemas/v1PostingPhase",
            "description": "The posting phase the balance applies to."
          },
          "asset": {
            "type": "string",
            "description": "The asset in which the balance is held."
          },
          "denomination": {
            "type": "string",
            "description": "The denomination in which the balance is held for the given asset."
          },
          "value_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The effective timestamp of the posting batch."
          }
        }
      },
      "commonExecutionSchedule": {
        "type": "object",
        "properties": {
          "start_date": {
            "type": "string",
            "title": "Earliest possible date/time to trigger on (inclusive)"
          },
          "end_date": {
            "type": "string",
            "title": "Latest possible date/time to trigger on (inclusive)"
          },
          "day": {
            "type": "string",
            "title": "The following are used to generate a CRON-style expression used by apscheduler which will trigger an event when the current time matches all the specified time constraints. For a more detailed spec see the apscheduler documentation Day of the month (1-31)"
          },
          "day_of_week": {
            "type": "string",
            "title": "Day of the week (0-6 or mon-sun)"
          },
          "hour": {
            "type": "string",
            "title": "Hour (0-23)"
          },
          "minute": {
            "type": "string",
            "title": "Minute (0-59)"
          },
          "second": {
            "type": "string",
            "title": "Second (0-59)"
          },
          "month": {
            "type": "string",
            "title": "Month (1-12)"
          },
          "year": {
            "type": "string",
            "title": "Year (4-digit year)"
          },
          "week": {
            "type": "string",
            "title": "ISO week (1-53)"
          }
        }
      },
      "smart_contractsDerivedParametersValues": {
        "type": "object",
        "properties": {
          "derived_parameters": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "A map of key-value pairs for the derived parameters."
          },
          "simulation_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time the simulation event occurred."
          },
          "effective_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time that the derived parameters values were calculated for."
          }
        }
      },
      "smart_contractsExternalEvent": {
        "type": "object",
        "properties": {
          "timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The simulation time the event should occur at."
          },
          "update_param": {
            "$ref": "#/components/schemas/smart_contractsUpdateParamEvent",
            "required": false
          },
          "posting_instruction_batch": {
            "$ref": "#/components/schemas/v1PostingInstructionBatch",
            "required": false
          },
          "set_flag": {
            "$ref": "#/components/schemas/smart_contractsSetFlagEvent",
            "required": false
          },
          "get_derived_parameters": {
            "$ref": "#/components/schemas/smart_contractsGetDerivedParametersEvent",
            "required": false
          }
        }
      },
      "smart_contractsGetDerivedParametersEvent": {
        "type": "object",
        "properties": {
          "effective_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time that the derived parameters values should be calculated for."
          }
        },
        "description": "Contract simulation event - get derived Smart Contract parameters."
      },
      "smart_contractsScheduledEvent": {
        "type": "object",
        "properties": {
          "account_id": {
            "type": "string",
            "description": "The ID of the account the event applies to."
          },
          "event_type": {
            "type": "string",
            "description": "The `event_type` string as specified by the Smart Contract."
          },
          "schedule": {
            "$ref": "#/components/schemas/commonExecutionSchedule",
            "description": "The schedule the scheduled event triggers the Smart Contract at."
          }
        }
      },
      "smart_contractsSetFlagEvent": {
        "type": "object",
        "properties": {
          "flag_definition_id": {
            "type": "string",
            "description": "ID of the flag."
          },
          "effective_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time the flag becomes effective."
          },
          "expiry_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time the flag expires."
          }
        },
        "title": "Contract simulation event - flag update"
      },
      "smart_contractsSimulateExistingAccountRequest": {
        "type": "object",
        "properties": {
          "account_id": {
            "type": "string",
            "description": "The account ID to be simulated."
          },
          "start_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time the simulation should start. Optional (defaults to current time)."
          },
          "end_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time the simulation should end."
          },
          "events": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/smart_contractsExternalEvent"
            },
            "description": "The list of events that should be fed into the simulator to simulate external actions on either Vault or the account."
          },
          "return_event_log": {
            "type": "boolean",
            "description": "If set to true, the event log will be returned."
          }
        }
      },
      "smart_contractsSimulateSmartContractResponse": {
        "type": "object",
        "properties": {
          "account_notes": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/accounts_commonAccountNote"
            },
            "description": "All notes added to the simulated account."
          },
          "scheduled_events": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/smart_contractsScheduledEvent"
            },
            "description": "All scheduled events on the simulated account (these are schedules and not all materialised times)."
          },
          "workflows": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/smart_contractsStartedWorkflow"
            },
            "description": "All instructions to start Workflows that were created by the simulated account."
          },
          "postings_batches": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/v1PostingInstructionBatch"
            },
            "description": "Return all of the Posting instruction batches that were simulated."
          },
          "v3_balance_timeseries": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/balancesPostingBalance"
            },
            "description": "Return the balance timeseries for the simulation."
          },
          "derived_parameters_values": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/smart_contractsDerivedParametersValues"
            },
            "description": "Return all derived Smart Contract parameter values that were simulated."
          },
          "event_log_json": {
            "type": "string",
            "description": "Return the event log."
          }
        }
      },
      "smart_contractsStartedWorkflow": {
        "type": "object",
        "properties": {
          "account_id": {
            "type": "string",
            "description": "The ID of the account that started the Workflow."
          },
          "workflow_definition_id": {
            "type": "string",
            "description": "The ID of the Workflow that the account started."
          },
          "context": {
            "type": "object",
            "additionalProperties": {
              "type": "string"
            },
            "description": "The initial data that was sent to the Workflow."
          },
          "start_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "The time the Workflow was started."
          }
        }
      },
      "smart_contractsUpdateParamEvent": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string",
            "description": "The name of the contract parameter being updated."
          },
          "value": {
            "type": "string",
            "description": "The new value of the contract parameter being updated."
          }
        },
        "description": "Contract simulation event - parameter update. NOTE: Currently only supports INSTANCE level parameter updates."
      },
      "supervisor_contractsBatchGetSupervisorContractVersionsRequestIncludeField": {
        "type": "string",
        "enum": [
          "INCLUDE_FIELD_CODE",
          "INCLUDE_FIELD_DETAILS_API_VERSION",
          "INCLUDE_FIELD_DETAILS_NOTIFICATION_TYPES"
        ],
        "default": "INCLUDE_FIELD_CODE"
      },
      "supervisor_contractsBatchGetSupervisorContractVersionsResponse": {
        "type": "object",
        "properties": {
          "supervisor_contract_versions": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/supervisor_contractsSupervisorContractVersion"
            },
            "description": "Map of ID to Supervisor Contract Version."
          }
        }
      },
      "supervisor_contractsBatchGetSupervisorContractsResponse": {
        "type": "object",
        "properties": {
          "supervisor_contracts": {
            "type": "object",
            "additionalProperties": {
              "$ref": "#/components/schemas/supervisor_contractsSupervisorContract"
            },
            "description": "Map of ID to Supervisor Contract."
          }
        }
      },
      "supervisor_contractsCreateSupervisorContractRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID that is used to ensure the request is idempotent.\n\nRequired."
          },
          "supervisor_contract": {
            "$ref": "#/components/schemas/supervisor_contractsSupervisorContract",
            "description": "The Supervisor Contract to be created.\n\nRequired.",
            "x-excluded-fields": [
              "create_timestamp"
            ]
          }
        },
        "required": [
          "request_id",
          "supervisor_contract"
        ]
      },
      "supervisor_contractsCreateSupervisorContractVersionRequest": {
        "type": "object",
        "properties": {
          "request_id": {
            "type": "string",
            "description": "A unique string ID that is used to ensure the request is idempotent.\n\nRequired."
          },
          "supervisor_contract_version": {
            "$ref": "#/components/schemas/supervisor_contractsSupervisorContractVersion",
            "description": "The Supervisor Contract Version to be created.\n\nRequired.",
            "x-excluded-fields": [
              "create_timestamp",
              "details"
            ]
          }
        },
        "required": [
          "request_id",
          "supervisor_contract_version"
        ]
      },
      "supervisor_contractsListSupervisorContractVersionsRequestIncludeField": {
        "type": "string",
        "enum": [
          "INCLUDE_FIELD_DETAILS_API_VERSION",
          "INCLUDE_FIELD_DETAILS_NOTIFICATION_TYPES"
        ],
        "default": "INCLUDE_FIELD_DETAILS_API_VERSION"
      },
      "supervisor_contractsListSupervisorContractVersionsResponse": {
        "type": "object",
        "properties": {
          "supervisor_contract_versions": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/supervisor_contractsSupervisorContractVersion"
            },
            "description": "A list of Supervisor Contract Versions, ordered by descending creation timestamp."
          },
          "next_page_token": {
            "type": "string",
            "description": "The token used to retrieve the next page. If empty, this returns the last page of results."
          },
          "previous_page_token": {
            "type": "string",
            "description": "The token used to retrieve the previous page. If empty, this returns the first page of results."
          }
        }
      },
      "supervisor_contractsListSupervisorContractsResponse": {
        "type": "object",
        "properties": {
          "supervisor_contracts": {
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/supervisor_contractsSupervisorContract"
            },
            "description": "A list of Supervisor Contracts, ordered by descending creation timestamp."
          },
          "next_page_token": {
            "type": "string",
            "description": "The token used to retrieve the next page. If empty, this returns the last page of results."
          },
          "previous_page_token": {
            "type": "string",
            "description": "The token used to retrieve the previous page. If empty, this returns the first page of results."
          }
        }
      },
      "supervisor_contractsSupervisorContract": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "A unique ID. Can be provided by the client, otherwise it will be a service-generated UUID.\n"
          },
          "create_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp indicating when it was created."
          },
          "display_name": {
            "type": "string",
            "description": "The human-readable name.\n\nRequired."
          }
        },
        "description": "A parent resource for zero or more `SupervisorContractVersion`s.",
        "required": [
          "display_name"
        ]
      },
      "supervisor_contractsSupervisorContractCodeDetails": {
        "type": "object",
        "properties": {
          "api_version": {
            "$ref": "#/components/schemas/versionSemVer",
            "description": "Contracts API version used by the Supervisor Contract."
          },
          "display_version": {
            "$ref": "#/components/schemas/versionSemVer",
            "description": "Human-readable semantic version of the Supervisor Contract Version."
          },
          "notification_types": {
            "type": "array",
            "items": {
              "type": "string"
            },
            "description": "The notification types supported by this Supervisor Contract.",
            "x-release-info": {
              "changeType": "ADD_FIELD",
              "featureFlag": "TM_66923_CONTRACTS_NOTIFICATION_EVENT"
            }
          }
        },
        "description": "Holds information derived from Supervisor code."
      },
      "supervisor_contractsSupervisorContractVersion": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "A unique ID. Can be provided by the client, otherwise it will be a service-generated UUID.\n"
          },
          "create_timestamp": {
            "type": "string",
            "format": "date-time",
            "description": "Timestamp indicating when it was created."
          },
          "supervisor_contract_id": {
            "type": "string",
            "description": "The ID of the `SupervisorContract` of which this is a version.\n\nRequired."
          },
          "display_name": {
            "type": "string",
            "description": "The human-readable name.\n\nRequired."
          },
          "description": {
            "type": "string",
            "description": "The human-readable description.\n\nRequired."
          },
          "code": {
            "type": "string",
            "description": "The source code.\n\nRequired."
          },
          "details": {
            "$ref": "#/components/schemas/supervisor_contractsSupervisorContractCodeDetails",
            "description": "Additional information about the Supervisor Contract derived from the code (API version, etc.)."
          }
        },
        "description": "Contains the original source code of the Supervisor Contract and the structured information about it (e.g. version, event types, hooks, etc.). The latter is derived from the source code and may not be directly set.",
        "required": [
          "supervisor_contract_id",
          "display_name",
          "description",
          "code"
        ]
      },
      "vaultversionVaultVersion": {
        "type": "object",
        "properties": {
          "version": {
            "$ref": "#/components/schemas/versionSemVer",
            "description": "The Vault version."
          },
          "pre_release": {
            "type": "string",
            "description": "The pre-release tag."
          },
          "build": {
            "type": "string",
            "description": "The build tag."
          }
        }
      },
      "account_config_group_id": {
        "type": "string",
        "description": "The ID of the account config group that owns this value. When set to `account-config-group`, this is owned by the root group and is therefore global."
      },
      "account_config_entity_id": {
        "type": "string",
        "description": "The ID of the AccountConfigEntity that owns this value."
      },
      "account_id": {
        "type": "string",
        "description": "The ID of an account in Vault."
      },
      "string_value": {
        "type": "string",
        "description": "The value of a string Parameter."
      },
      "decimal_value": {
        "type": "string",
        "description": "The value of a decimal Parameter."
      },
      "enumeration_value": {
        "type": "string",
        "description": "The value of an enumeration Parameter."
      },
      "date_time_value": {
        "type": "string",
        "description": "The value of a date-time Parameter. UTC."
      },
      "account_id_value": {
        "type": "string",
        "description": "The ID of an Account, may be Internal or Customer."
      },
      "customer_id": {
        "type": "string",
        "description": "The customer ID the flag applies to.\n"
      },
      "payment_device_id": {
        "type": "string",
        "description": "The payment device ID the flag applies to.\n"
      },
      "amount": {
        "type": "string",
        "description": "A delta amount. The sign of the delta can be given explicitly (`\"+3.40\"`, `\"-20\"`) or implicitly if it is positive (e.g \"3.40\" is the same as \"+3.40\")."
      },
      "replacement_amount": {
        "type": "string",
        "description": "A new amount, to replace the existing authorised amount."
      },
      "payment_device_token": {
        "type": "string",
        "description": "A payment device token that uniquely identifies a payment device link based on the value_timestamp of the posting instruction. When the target_account is specified via the token, Vault will resolve the token to a Vault account and the account_id will be returned in the posting instruction target_account_id field."
      },
      "event_identifier": {
        "type": "string"
      },
      "last_payment_date": {
        "type": "string",
        "description": "The date of the last payment with format YYYY-MM-DDTHH:MM. The recurring schedule will not generate PaymentOrderExecution events with `recurring_amount` on and after this date. A PaymentOrderExecution object with `last_payment_amount` (or `recurring_amount` if it is not set) will be streamed out on this date and the PaymentOrderStatus will be set to COMPLETED. This can be set to an empty string on resource creation and on resource updates to represent an open-ended recurring payment."
      },
      "number_of_payments": {
        "type": "string",
        "description": "The number of payments that will be executed. The last PaymentOrderExecution object will use the `last_payment_amount` (or `recurring_amount` if it is not set) and after it is streamed out the PaymentOrderStatus will be set to COMPLETED."
      }
    },
    "securitySchemes": {
      "ApiKeyAuth": {
        "type": "apiKey",
        "in": "header",
        "name": "X-Auth-Token"
      }
    },
    "requestBodies": {
      "account_schedule_tagsCreateAccountScheduleTagRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/account_schedule_tagsCreateAccountScheduleTagRequest"
            }
          }
        }
      },
      "account_schedule_tagsUpdateAccountScheduleTagRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/account_schedule_tagsUpdateAccountScheduleTagRequest"
            }
          }
        }
      },
      "accountsCreateAccountMigrationRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/accountsCreateAccountMigrationRequest"
            }
          }
        }
      },
      "accountsUpdateAccountMigrationRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/accountsUpdateAccountMigrationRequest"
            }
          }
        }
      },
      "accountsCreateAccountUpdateBatchRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/accountsCreateAccountUpdateBatchRequest"
            }
          }
        }
      },
      "accountsCreateAccountUpdateRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/accountsCreateAccountUpdateRequest"
            }
          }
        }
      },
      "accountsCreateAccountRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/accountsCreateAccountRequest"
            }
          }
        }
      },
      "accountsUpdateAccountRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/accountsUpdateAccountRequest"
            }
          }
        }
      },
      "accountsUpdateAccountDetailsRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/accountsUpdateAccountDetailsRequest"
            }
          }
        }
      },
      "authCreateServiceAccountRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/authCreateServiceAccountRequest"
            }
          }
        }
      },
      "authUpdateServiceAccountRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/authUpdateServiceAccountRequest"
            }
          }
        }
      },
      "authUpdateServiceAccountPermissionsRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/authUpdateServiceAccountPermissionsRequest"
            }
          }
        }
      },
      "calendarCreateCalendarRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/calendarCreateCalendarRequest"
            }
          }
        }
      },
      "calendarCreateCalendarEventRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/calendarCreateCalendarEventRequest"
            }
          }
        }
      },
      "calendarUpdateCalendarEventRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/calendarUpdateCalendarEventRequest"
            }
          }
        }
      },
      "calendarCreateCalendarPeriodDescriptorRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/calendarCreateCalendarPeriodDescriptorRequest"
            }
          }
        }
      },
      "calendarUpdateBookkeepingDateRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/calendarUpdateBookkeepingDateRequest"
            }
          }
        }
      },
      "calendarChangeCurrentCalendarPeriodRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/calendarChangeCurrentCalendarPeriodRequest"
            }
          }
        }
      },
      "calendarUpdateCalendarRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/calendarUpdateCalendarRequest"
            }
          }
        }
      },
      "contract_modulesCreateContractModuleVersionRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/contract_modulesCreateContractModuleVersionRequest"
            }
          }
        }
      },
      "contract_modulesCreateContractModuleRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/contract_modulesCreateContractModuleRequest"
            }
          }
        }
      },
      "contract_modulesCreateSmartContractModuleVersionsLinkRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/contract_modulesCreateSmartContractModuleVersionsLinkRequest"
            }
          }
        }
      },
      "contractsSimulateContractsRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/contractsSimulateContractsRequest"
            }
          }
        }
      },
      "customersCreateCustomerAddressRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/customersCreateCustomerAddressRequest"
            }
          }
        }
      },
      "customersUpdateCustomerAddressRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/customersUpdateCustomerAddressRequest"
            }
          }
        }
      },
      "customersCreateCustomerRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/customersCreateCustomerRequest"
            }
          }
        }
      },
      "customersUpdateCustomerRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/customersUpdateCustomerRequest"
            }
          }
        }
      },
      "customersUpdateCustomerAdditionalDetailsRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/customersUpdateCustomerAdditionalDetailsRequest"
            }
          }
        }
      },
      "eventsReplayJournalEventsRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/eventsReplayJournalEventsRequest"
            }
          }
        }
      },
      "flagsCreateFlagDefinitionRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/flagsCreateFlagDefinitionRequest"
            }
          }
        }
      },
      "flagsUpdateFlagDefinitionRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/flagsUpdateFlagDefinitionRequest"
            }
          }
        }
      },
      "flagsCreateFlagRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/flagsCreateFlagRequest"
            }
          }
        }
      },
      "flagsUpdateFlagRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/flagsUpdateFlagRequest"
            }
          }
        }
      },
      "global_parametersCreateGlobalParameterValueRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/global_parametersCreateGlobalParameterValueRequest"
            }
          }
        }
      },
      "global_parametersCreateGlobalParameterRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/global_parametersCreateGlobalParameterRequest"
            }
          }
        }
      },
      "internal_accountsCreateInternalAccountRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/internal_accountsCreateInternalAccountRequest"
            }
          }
        }
      },
      "payment_devicesCreatePaymentDeviceLinkRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/payment_devicesCreatePaymentDeviceLinkRequest"
            }
          }
        }
      },
      "payment_devicesUpdatePaymentDeviceLinkRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/payment_devicesUpdatePaymentDeviceLinkRequest"
            }
          }
        }
      },
      "payment_devicesCreatePaymentDeviceRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/payment_devicesCreatePaymentDeviceRequest"
            }
          }
        }
      },
      "payment_devicesUpdatePaymentDeviceRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/payment_devicesUpdatePaymentDeviceRequest"
            }
          }
        }
      },
      "payment_ordersCreatePaymentOrderRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/payment_ordersCreatePaymentOrderRequest"
            }
          }
        }
      },
      "payment_ordersUpdatePaymentOrderRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/payment_ordersUpdatePaymentOrderRequest"
            }
          }
        }
      },
      "plansCreatePlanMigrationRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/plansCreatePlanMigrationRequest"
            }
          }
        }
      },
      "plansCreatePlanUpdateRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/plansCreatePlanUpdateRequest"
            }
          }
        }
      },
      "plansCreatePlanRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/plansCreatePlanRequest"
            }
          }
        }
      },
      "policy_managementCreatePolicyRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/policy_managementCreatePolicyRequest"
            }
          }
        }
      },
      "policy_managementUpdatePolicyRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/policy_managementUpdatePolicyRequest"
            }
          }
        }
      },
      "post_posting_republisherRepublishPostPostingFailureRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/post_posting_republisherRepublishPostPostingFailureRequest"
            }
          }
        }
      },
      "posting_instruction_batchesValidateCreatePostingInstructionBatchRequestRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/posting_instruction_batchesValidateCreatePostingInstructionBatchRequestRequest"
            }
          }
        }
      },
      "v1posting_instruction_batchesCreatePostingInstructionBatchRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/v1posting_instruction_batchesCreatePostingInstructionBatchRequest"
            }
          }
        }
      },
      "postings_api_clientsCreatePostingsAPIClientRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/postings_api_clientsCreatePostingsAPIClientRequest"
            }
          }
        }
      },
      "postings_api_clientsUpdatePostingsAPIClientRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/postings_api_clientsUpdatePostingsAPIClientRequest"
            }
          }
        }
      },
      "productsCreateProductVersionRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/productsCreateProductVersionRequest"
            }
          }
        }
      },
      "productsUpdateProductVersionParamsRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/productsUpdateProductVersionParamsRequest"
            }
          }
        }
      },
      "restrictionsCreateRestrictionSetDefinitionVersionRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/restrictionsCreateRestrictionSetDefinitionVersionRequest"
            }
          }
        }
      },
      "restrictionsCreateRestrictionSetRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/restrictionsCreateRestrictionSetRequest"
            }
          }
        }
      },
      "restrictionsUpdateRestrictionSetRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/restrictionsUpdateRestrictionSetRequest"
            }
          }
        }
      },
      "schedulerRepublishJobRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/schedulerRepublishJobRequest"
            }
          }
        }
      },
      "schedulerCreateScheduleTagRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/schedulerCreateScheduleTagRequest"
            }
          }
        }
      },
      "smart_contractsSimulateExistingAccountRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/smart_contractsSimulateExistingAccountRequest"
            }
          }
        }
      },
      "supervisor_contractsCreateSupervisorContractVersionRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/supervisor_contractsCreateSupervisorContractVersionRequest"
            }
          }
        }
      },
      "supervisor_contractsCreateSupervisorContractRequest": {
        "required": true,
        "content": {
          "application/json": {
            "schema": {
              "$ref": "#/components/schemas/supervisor_contractsCreateSupervisorContractRequest"
            }
          }
        }
      }
    }
  },
  "security": [
    {
      "ApiKeyAuth": []
    }
  ]
}